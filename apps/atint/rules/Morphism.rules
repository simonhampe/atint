########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
#
#  This file describes the object representing a morphism of tropical varieties
########################################################################

########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains the description of the type RationalFunction
########################################################################

object Morphism {
  
# #   use overload('^' => 'powerf');
#   use overload('*' => 'mult','""' => 'to_string', 'bool' => 'bool','^' => 'powerf', '+' => 'sum','-' => 'minus','neg'=>'neg');
  
  # @category Tropical geometry
  # This property describes the domain of the morphism. I.e. the morphism is
  # defined on this complex and is locally affine integral linear. It is of type WeightedComplex, but
  # actually only the basic geometric properties [[RAYS]]/[[CMPLX_RAYS]],[[MAXIMAL_CONES]]/[[CMPLX_MAXIMAL_CONES]],[[LINEALITY_SPACE]] and [[USES_HOMOGENEOUS_C]] are of any interest. Further properties are ignored and can be omitted during generation.
  property DOMAIN : WeightedComplex;
  
  # @category Tropical geometry
  # The vector at row i describes the function value of ray [[DOMAIN]]->CMPLX_RAYS->row(i). More precisely, if the
  # corresponding ray is a vertex, it describes its function value. If it is a directional ray, it describes 
  # the slope on that ray.
  property RAY_VALUES : Matrix<Rational>;
  
  # @category Tropical geometry
  # The vector in row i describes the function value (slope) of [[DOMAIN]]->LINEALITY_SPACE->row(i)
  property LIN_VALUES : Matrix<Rational>; 
  
  # @category Tropical geometry / Morphism
  # Is TRUE, iff the morphism is a global affine linear integral map
  # In this case, the morphism's description can be read off from the properties
  # [[MATRIX]] and [[TRANSLATE]]. Setting any of these properties during initialization 
  # will make this TRUE by default.
  property IS_GLOBAL : Bool;
  
  # @category Tropical geometry / Morphism
  # If the morphism is a global affine linear map x |-> Ax+v, i.e. IS_GLOBAL is or should be true, 
  # then this contains the matrix A (in non-homog. coordinates). If [[TRANSLATE]] is set, but this property is not set, then it
  # is the identity by default.
  property MATRIX : Matrix<Rational>;
  
  # @category Tropical geometry / Morphism
  # If the morphism is a global affine linear map x |-> Ax+v, i.e. IS_GLOBAL is or should be true, 
  # then this contains the translation vector v (in non-homog. coordinates). If [[MATRIX]] is set, but this property is not set,
  # then it is the zero vector by default.
  property TRANSLATE : Vector<Rational>;
  
  
  ############################### RULES #######################################
  
  
  rule RAY_VALUES : LIN_VALUES, DOMAIN {
    $this->RAY_VALUES = new Matrix<Rational>($this->DOMAIN->CMPLX_RAYS->rows(), $this->LIN_VALUES->cols());
  }
  
  rule LIN_VALUES : RAY_VALUES, DOMAIN {
    $this->LIN_VALUES = new Matrix<Rational>($this->DOMAIN->LINEALITY_SPACE->rows(), $this->RAY_VALUES->cols());
  }
  
  rule IS_GLOBAL : MATRIX | TRANSLATE {
    $this->IS_GLOBAL = TRUE;
  }
  weight 0.01;
  
  rule IS_GLOBAL : {
    $this->IS_GLOBAL = FALSE;
  }
  weight 0.02;
  
  rule MATRIX : TRANSLATE {
    $this->MATRIX = unit_matrix($this->TRANSLATE->dim());
  }
  
  rule TRANSLATE : MATRIX {
    $this->TRANSLATE = zero_vector<Rational>($this->MATRIX->rows());
  }
  
  rule DOMAIN, RAY_VALUES, LIN_VALUES : MATRIX,TRANSLATE {
    my $lspace = linear_nspace($this->MATRIX->cols())->homogenize;
    $this->DOMAIN = new WeightedComplex(RAYS=>$lspace->RAYS,MAXIMAL_CONES=>$lspace->MAXIMAL_CONES,
					LINEALITY_SPACE=>$lspace->LINEALITY_SPACE, USES_HOMOGENEOUS_C=>$lspace->USES_HOMOGENEOUS_C);
    my $raymatrix = new Matrix<Rational>(0,$this->TRANSLATE->dim());
      $raymatrix = $raymatrix / $this->TRANSLATE;
    $this->RAY_VALUES = $raymatrix;
    $this->LIN_VALUES = transpose($this->MATRIX);
  }
  
  ############################## METHODS #######################################
   
  #   @category Morphisms
  #   If the domain of the function is in homogeneous coordinates, it returns the function. Otherwise it homogenizes
  #   the domain and assigns the value (0,..,0) to the additional vertex at the origin
  user_method homogenize {
    my $this = shift;
    return morphism_homogenize($this);    
  }

# ----------------------------- OVERLOADED OPERATORS -----------------
  
  
  
}

######################################## FUNCTIONS ###################################

# @category Tropical geometry / Rational functions
# Computes the pull back of a rational function (or a list of rational functions) along a morphism
# @param Morphism f A morphism
# @param RationalFunction phi A rational function whose [[DOMAIN]] contains the image of f (or a list of RationalFunction objects)
# @return RationalFunction The pull-back of phi along f. If a list of functions was given, it returns an array with the pull-backs of these functions
user_function pull_back {
  my ($f,@phi_list) = @_;
  
  my @result = ();
  
  for my $phi (@phi_list) {
    #Distinguish cases
    if($f->IS_GLOBAL) {
      if($phi->isa("MinMaxFunction")) {
	@result = (@result, pb_minmax_global($f,$phi));
      }
      else {
	die "Not implemented yet\n";
      }
    }
    else  {
      die "Not implemented yet\n";
    }
  }
  
  if(scalar(@result) == 1) {
    return $result[0];
  }
  return @result;
  
}