########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
#
#  This file describes the object representing a morphism of tropical varieties
########################################################################

########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains the description of the type RationalFunction
########################################################################

object Morphism {
  
  use overload('*' => 'mult','""' => 'to_string', 'bool' => 'bool', '+' => 'sum','-' => 'minus','neg'=>'neg');
  
  # @category Tropical geometry
  # This property describes the domain of the morphism. I.e. the morphism is
  # defined on this complex and is locally affine integral linear. It is of type WeightedComplex, but
  # actually only the basic geometric properties [[RAYS]]/[[CMPLX_RAYS]],[[MAXIMAL_CONES]]/[[CMPLX_MAXIMAL_CONES]],[[LINEALITY_SPACE]] and [[USES_HOMOGENEOUS_C]] are of any interest. Further properties are ignored and can be omitted during generation.
  property DOMAIN : WeightedComplex;
  
  # @category Tropical geometry
  # The vector at row i describes the function value of ray [[DOMAIN]]->CMPLX_RAYS->row(i). More precisely, if the
  # corresponding ray is a vertex, it describes its function value. If it is a directional ray, it describes 
  # the slope on that ray.
  property RAY_VALUES : Matrix<Rational>;
  
  # @category Tropical geometry
  # The vector in row i describes the function value (slope) of [[DOMAIN]]->LINEALITY_SPACE->row(i)
  property LIN_VALUES : Matrix<Rational>; 
  
  # @category Tropical geometry / Morphism
  # Is TRUE, iff the morphism is a global affine linear integral map
  # In this case, the morphism's description can be read off from the properties
  # [[MATRIX]] and [[TRANSLATE]]. Setting any of these properties during initialization 
  # will make this TRUE by default.
  property IS_GLOBAL : Bool;
  
  # @category Tropical geometry / Morphism
  # If the morphism is a global affine linear map x |-> Ax+v, i.e. IS_GLOBAL is or should be true, 
  # then this contains the matrix A (in non-homog. coordinates). If [[TRANSLATE]] is set, but this property is not set, then it
  # is the identity by default.
  property MATRIX : Matrix<Rational>;
  
  # @category Tropical geometry / Morphism
  # If the morphism is a global affine linear map x |-> Ax+v, i.e. IS_GLOBAL is or should be true, 
  # then this contains the translation vector v (in non-homog. coordinates). If [[MATRIX]] is set, but this property is not set,
  # then it is the zero vector by default.
  property TRANSLATE : Vector<Rational>;
  
  
  ############################### RULES #######################################
  
  
  rule RAY_VALUES : LIN_VALUES, DOMAIN {
    $this->RAY_VALUES = new Matrix<Rational>($this->DOMAIN->CMPLX_RAYS->rows(), $this->LIN_VALUES->cols());
  }
  
  rule LIN_VALUES : RAY_VALUES, DOMAIN {
    $this->LIN_VALUES = new Matrix<Rational>($this->DOMAIN->LINEALITY_SPACE->rows(), $this->RAY_VALUES->cols());
  }
  
  rule IS_GLOBAL : MATRIX | TRANSLATE {
    $this->IS_GLOBAL = TRUE;
  }
  weight 0.01;
  
  rule IS_GLOBAL : {
    $this->IS_GLOBAL = FALSE;
  }
  weight 0.02;
  
  rule MATRIX : TRANSLATE {
    $this->MATRIX = unit_matrix($this->TRANSLATE->dim());
  }
  
  rule TRANSLATE : MATRIX {
    $this->TRANSLATE = zero_vector<Rational>($this->MATRIX->rows());
  }
  
  rule DOMAIN, RAY_VALUES, LIN_VALUES : MATRIX,TRANSLATE {
    my $lspace = linear_nspace($this->MATRIX->cols())->homogenize;
    $this->DOMAIN = new WeightedComplex(RAYS=>$lspace->RAYS,MAXIMAL_CONES=>$lspace->MAXIMAL_CONES,
					LINEALITY_SPACE=>$lspace->LINEALITY_SPACE, USES_HOMOGENEOUS_C=>$lspace->USES_HOMOGENEOUS_C);
    my $raymatrix = new Matrix<Rational>(0,$this->TRANSLATE->dim());
      $raymatrix = $raymatrix / $this->TRANSLATE;
    $this->RAY_VALUES = $raymatrix;
    $this->LIN_VALUES = transpose($this->MATRIX);
  }
  
  ############################## METHODS #######################################
   
  #   @category Morphisms
  #   If the domain of the function is in homogeneous coordinates, it returns the function. Otherwise it homogenizes
  #   the domain and assigns the value (0,..,0) to the additional vertex at the origin
  user_method homogenize {
    my $this = shift;
    return morphism_homogenize($this);    
  }
  
  # @category Morphisms
  # Computes the composition of this morphism with another morphism. The other morphism should either be global 
  # and surjective or its image should be contained in the [[DOMAIN]] of this morphism
  # @param Morphism g Another morphism. 
  # @return Morphism The composition "this after g" (The converse composition is computed using "before")
  user_method after {
    my ($this, $g) = @_;
    return morphism_composition($g, $this);
  }
  
  # @category Morphisms
  # Computes the composition of another morphism with this morphism. This morphism should either be global 
  # and surjective or its image should be contained in the [[DOMAIN]] of the other morphism
  # @param Morphism g Another morphism. 
  # @return Morphism The composition "g after this" (The converse composition is computed using "after")
  user_method before {
    my ($this, $g) = @_;
    return morphism_composition($this,$g);
  }

  #----------------------------- OVERLOADED OPERATORS -----------------
  
  sub bool {
      my $this = shift;
      return !undef($this);
  }

  sub mult {
      my ($f,$g ) = @_;
      if($g->isa("RationalFunction")) {
	return pull_back($f,$g);
      }
      else {
	return morphism_composition($g, $f);
      }
  }
  
  sub to_string {
    my $this = shift;  
    my $result = "Morphism on (".$this->DOMAIN->DESCRIPTION.") with values: \n".join(",",$this->RAY_VALUES)."\n".join(",",$this->LIN_VALUES);
    return $result;
  }
  
  sub sum {
    my ($f,$g) = @_;
    return add_morphisms($f,$g);
  }
  
  sub mult {
      my ($f,$r ) = @_;
      if($r->isa("RationalFunction") ) {
	  return pull_back($f,$r);
      }
      if($f->IS_GLOBAL) {
	return new Morphism(MATRIX=>$r * $f->MATRIX, TRANSLATE=>$r * $f->TRANSLATE);
      }
      return new Morphism(DOMAIN=>$f->DOMAIN, RAY_VALUES=>$r * ($f->RAY_VALUES), LIN_VALUES=>$r * ($f->LIN_VALUES));
  }
  
  sub minus {
    my ($f,$g) = @_;
    return add_morphisms($f, (-1) * $g);
  }
  
  sub neg {
    my $f = shift;
    return mult($f,-1);
  }
  
}

######################################## FUNCTIONS ###################################

# @category Tropical geometry / Rational functions
# Computes the pull back of a rational function (or a list of rational functions) along a morphism
# @param Morphism f A morphism
# @param RationalFunction phi A rational function whose [[DOMAIN]] contains the image of f (or a list of RationalFunction objects)
# @return RationalFunction The pull-back of phi along f. If a list of functions was given, it returns an array with the pull-backs of these functions
user_function pull_back {
  my ($f,@phi_list) = @_;
  
  my @result = ();
  
  for my $phi (@phi_list) {
    #Distinguish cases
    if($f->IS_GLOBAL && $phi->isa("MinMaxFunction")) {
      @result = (@result, pb_minmax_global($f,$phi));
    }
    else {
      @result = (@result, pb_general($f,$phi));
    }
  }
  
  if(scalar(@result) == 1) {
    return $result[0];
  }
  return @result;
  
}

# @category Morphisms
# Restricts a morphism / rational function to a given domain (which should be contained in the [[DOMAIN]] of the function)
# @param Morphism f (or RationalFunction) The function to be restricted
# @param WeightedComplex domain The domain to which the function should be restricted
# @return Morphism or RationalFunction The restricted function
user_function restrict {
  my ($f, $X) = @_;
  
  #Define identity on $X
  my $rayvalues = $X->CMPLX_RAYS;
  my $linvalues = $X->LINEALITY_SPACE;
  if($X->USES_HOMOGENEOUS_C) {
    if($rayvalues->cols() > 0) { $rayvalues = $rayvalues->minor(All,~scalar2set(0));}
    if($linvalues->cols() > 0) {$linvalues = $linvalues->minor(All,~scalar2set(0));}
  }
  
  my $emb = new Morphism(DOMAIN=>$X, RAY_VALUES=>$rayvalues, LIN_VALUES=>$linvalues);
  if($f->isa("RationalFunction")) {
    return $emb * $f;
  }
  else {
    return $f * $emb;
  }
 
 
}