########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains the declaration of the type RationalCurve and all associated
# functionality. A RationalCurve is a point in the moduli space M_0,n of n-marked
# rational abstract tropical curves.
# The standard representation of a rational curve is via the primitive generators v_I of the
# metric tree - embedding, where v_I represents a tree with leafs in I on one side and leafs not in
# I on the other side. The curve is given as a positive linear combination of some of those.
# A curve can be created in several ways:
# 1) By converting a point from the moduli space, which is given in matroid coordinates, via 
# curveFromModuli(...)
# 2) By specifying a list of sets I in (1,..,n) (together with n) and corresponding positive 
# coefficients. This can either be done directly via N_LEAVES, INPUT_SETS and INPUT_COEFFS or be parsed
# as a string via INPUT_STRING. If your coefficients are all > 0 and the sets are non-redundant, you
# can also use SETS and COEFFS directly.
# 3) By giving a metric satisfying the four-point condition as an (n over 2)-vector and converting it
# via curveFromMetric(...)
########################################################################

object RationalCurve {
  
  # @category Basic properties
  # A list of partitions of [n] that define the tree of the curve: For each bounded edge we have 
  # the corresponding partition of the n leaves. These should be irredundant. If you want to input
  # a possibly redundant list, use [[INPUT_SETS]] and [[INPUT_COEFFS]] instead. The number of marked leaves
  # should always be given by [[N_LEAVES]]
  property SETS : Array<Set<Int>>;
  
  # @category Basic properties
  # A list of positive rational coefficients. The list should have the same length as [[SETS]] and
  # contain only entries > 0. The i-th entry then gives the length of the bounded edge defined by
  # the i-th partition. If you're not sure if all your coefficients are > 0, use [[INPUT_SETS]] and
  # [[INPUT_COEFFS]] instead.
  property COEFFS : Vector<Rational>;
  
  # @category Basic properties
  # Same as [[SETS]], except that sets may appear several times.
  property INPUT_SETS : Array<Set<Int>>;
  
  # @category Basic properties
  # Same as [[COEFFS]], except that entries may be <=0. This should have the same length as [[INPUT_SETS]].
  property INPUT_COEFFS : Vector<Rational>;
  
  # @category Basic properties
  # The number of leaves of the rational curve.
  property N_LEAVES : Int;
  
  # @category Basic properties
  # This property can also be used to define a rational curve: A linear combination of partitions is
  # given as a string, using the following syntax:
  # A partition is given as a subset of {1,..,n} and written as a comma-separated list of leaf
  # indices in round brackets, e.g. "(1,2,5)"
  # A linear combination can be created using rational numbers, "+","+" and "-" in the obvious way, 
  # e.g. "2*(1,2,5) + 1*(3,4,7) - 2(1,2) (The "*" is optional)
  # Of course, each set should contain at least two elements. If you don't specify N_LEAVES, it is
  # set to be the largest leaf index occuring in the sets.
  # Partitions needn't be irredundant and coefficients can be any rational number. If the resulting 
  # element is not in the moduli space, an error is thrown.
  property INPUT_STRING : String;
  
}