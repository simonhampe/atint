########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains the description of the type RationalFunction
########################################################################

object RationalFunction {
  
#   use overload('^' => 'powerf');
  
  # @category Tropical geometry
  # This property describes the linearity domains of the function. I.e. the function is
  # affine integral linear on each maximal cone of [[DOMAIN]]. It is of type WeightedComplex, but
  # actually only the basic geometric properties [[RAYS]]/[[CMPLX_RAYS]],[[MAXIMAL_CONES]]/[[CMPLX_MAXIMAL_CONES]],[[LINEALITY_SPACE]] and [[USES_HOMOGENEOUS_C]] are of any interest. Further properties are ignored and can be omitted upon generation.
  property DOMAIN : WeightedComplex;
  
  # @category Tropical geometry
  # The value at index i describes the function value of ray [[DOMAIN]]->CMPLX_RAYS->row(i). More precisely, if the
  # corresponding ray is a vertex, it describes its function value. If it is a directional ray, it describes 
  # the slope on that ray.
  property RAY_VALUES : Vector<Rational>;
  
  # @category Tropical geometry
  # The value at index i describes the function value of [[DOMAIN]]->LINEALITY_SPACE->row(i)
  property LIN_VALUES : Vector<Rational>; 
  
  # @category Tropical geometry / Rational functions
  # This property describes how many times a function should be applied, if it occurs in a divisor term
  # E.g. if you create a MinMaxFunction f and you set its POWER property to 2, a call to
  # divisor(X,f) actually computes f*f*X
  property POWER : Int;
  
  ############################### RULES #######################################
  
  rule RAY_VALUES : LIN_VALUES {
    $this->RAY_VALUES = new Vector<Rational>();
  }
  
  rule LIN_VALUES : RAY_VALUES {
    $this->LIN_VALUES = new Vector<Rational>();
  }
  
  rule POWER : {
    $this->POWER = 1;
  }
  
  
  # @category Rational functions
  # This creates a RationalFunction from this one, simply by changing the power
  # @param Int k
  # @return Returns the function f with a power set to k. Note that the original power of f is ignored.
  user_method pow {
    my ($this,$k) = @_;
    return new RationalFunction(DOMAIN=>$this->DOMAIN,RAY_VALUES=>$this->RAY_VALUES,LIN_VALUES=>$this->LIN_VALUES,POWER=>$k);
  }
  
  # @category Rational functions
  # If the domain of the function is in homogeneous coordinates, it returns the function. Otherwise it homogenizes
  # the domain and assigns the value 0 to the additional vertex at the origin
  user_method homogenize {
    my $this = shift;
    if($this->DOMAIN->USES_HOMOGENEOUS_C) { return $this;}
    my @v = @{$this->RAY_VALUES};
    my $ndomain = $this->DOMAIN->homogenize;
    my $crays = $ndomain->CMPLX_RAYS;
    my $index = 0;
    #Find the new ray with x0 = 1
    for(my $i = 0; $i < $crays->rows(); $i++) {
      if($crays->row($i)->[0] != 0) {
	$index = $i;
	last;
      }
    }
    #Insert the 0-value at the right position
    @v = (@v[0..($index-1)],0,@v[$index..(scalar(@v)-1)]);
    
    return new RationalFunction(DOMAIN=>$ndomain, RAY_VALUES=>\@v, LIN_VALUES=>$this->LIN_VALUES,POWER=>$this->POWER);
    
  }

# ----------------------------- OVERLOADED OPERATORS -----------------
#   
#   sub powerf {
#     my ($f,$k) = @_;
#     return $f->to_the($k);
#   }

  
}

# @category Rational functions
# This function takes a fan::PolyhedralFan and converts it into a WeightedComplex object.
# @param fan::PolyhedralFan fan The fan to be converted
# @param Bool homog Whether the fan is to be interpreted in homogeneous coordinates
# @return WeightedComplex A complex with no weights but with the same geometry as fan.
user_function wfan {
  my ($fan,$homog) = @_;
  return new WeightedComplex(RAYS=>$fan->RAYS,MAXIMAL_CONES=>$fan->MAXIMAL_CONES,LINEALITY_SPACE=>$fan->LINEALITY_SPACE, USES_HOMOGENEOUS_C=>$homog);
}

# @category Rational functions
# This creates a RationalFunction by directly defining it on the rays of a given domain. It is simply shorter then
# using the constructor.
# @param WeightedComplex X The DOMAIN of the function
# @param Rational An arbitrarily long list of function values. It should be as long as 
# X->CMPXL_RAYS->rows + X->LINEALITY_DIM. Function values will be assigned in this order 
# (first rays, then linspace). Superfluous values are ignored, missing ones replaced by zero
# @return RationalFunction
user_function function_value {
  my ($X,@values) = @_;
  
  my $nrays = $X->CMPLX_RAYS->rows;
  my $nlin = $X->LINEALITY_DIM;
  
  #Adjust value length
  if(scalar(@values) > $nrays + $nlin) {
    @values = @values[0..($nrays+$nlin-1)];
  }
  while(scalar(@values) < $nrays + $nlin ) {
    @values = (@values,0);
  }
  my @rvalues = @values[0..($nrays-1)];
  my @lvalues = @values[$nrays..(scalar(@values)-1)];
  
  return new RationalFunction(DOMAIN=>$X,
			      RAY_VALUES=>(new Vector<Rational>(@rvalues)),
			      LIN_VALUES=>(new Vector<Rational>(@lvalues)),POWER=>1);
}



