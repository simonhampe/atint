########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
#
# This file extends the polyhedral fan of polymake to a tropical variety by assigning weights to the maximal cones
# and by allowing the fan to be interpreted as a polyhedral complex by intersecting it at x0 = 1
########################################################################

object WeightedComplex {

	## PROPERTIES ###########################################################
  
	# @category Tropical properties
	# Vector of (integer) weights for maximal cones. Indices refer to (the rows of) [[MAXIMAL_CONES]]
	# Note that, if the fan only consists of a lineality space, it specifies the weight of the single empty maximal
	# cone 
	property TROPICAL_WEIGHTS : Vector<Integer>;

	# @category Tropical properties
	# Indicates whether the fan is balanced with the given [[TROPICAL_WEIGHTS]]. If there is a 
	# [[LOCAL_RESTRICTION]], this will only be checked at the compatible codim one faces.
	property IS_BALANCED : Bool;	

	# @category Basic properties
	# An incidence matrix of all codimension one faces. Each row is a face and column indices refer to [[RAYS]].
	# If the fan uses homogeneous coordinates, only those faces that intersect {x0 = 1} are listed here.
	# If there is a [[LOCAL_RESTRICTION]], only compatible codimension one faces are kept.
	property CODIM_1_FACES : IncidenceMatrix;
	
	# @category Basic properties
	# An incidence matrix indicating which codim 1 faces are contained in which maximal cone. Rows refer
	# to (rows of) [[CODIM_1_FACES]], columns to (rows of) [[MAXIMAL_CONES]]
	property CODIM_1_IN_MAXIMAL_CONES : IncidenceMatrix;
	
	# @category Tropical properties
	# A list of lattice normal vectors. They are associated to the faces and maximal cones in the following 
	# way: For codimension one face i and adjacent maximal cone j, the element [[LATTICE_NORMALS]]->{i}->{j} is the corresp.
	# lattice normal vector. There is a convenience method lattice_normal(i,j)
	# If [[USES_HOMOGENEOUS_C]] is TRUE, this actually computes a lattice normal of the cone (face i)\cap {x0 =1} wrt the
	# cone (maximal cone j) \cap {x0=1} to ensure that the normal is of the form (0,...)
	# If there is a [[LOCAL_RESTRICTION]], only lattice normals for compatible codim one faces
	# are computed (naturally, since [[CODIM_1_FACES]] only contains those)
	property LATTICE_NORMALS : Map<Int,Map<Int,Vector<Integer>>>; 
	
	# @category Tropical geometry
	# For each lattice normal vector, this gives a vector of length (number of rays) + (lineality dim.), such that
	# if a rational function is given by values on the rays and lin space generators, the value of the corresponding
	# normal [[LATTICE_NORMALS]]->{i}->{j} can be computed by multiplying the function value vector with 
	# the vector [[LATTICE_NORMAL_FCT_VECTOR]]->{i}->{j}. This is done in the following way:  If this fan does not 
	# use homogeneous coordinates, it computes a representation of the lattice normal in the generating system 
	# consisting of the rays of [[MAXIMAL_CONES]]->row(j) and the generators 
	# of the lineality space. It then inserts the coefficients of the representation at the right position. 
	# If the fan uses homog. coordinates, however, we use a different generating system (and indices refer to CMPLX_RAYS)
	# <(r_i-r_0)_i>0, s_j, l_k>, where r_0 is the ray of the maximal cone 
	# with the lowest index in [[CMPLX_RAYS]], such that it fulfills x0 = 1, r_i are the remaining rays with x0 = 1, ordered
	# according to their index in [[CMPLX_RAYS]], s_j are the rays of the cone with x0 = 0 and l_k are the lineality space 
	# generators. We will then store the coefficients a_i of (r_i - r_0) at the index of r_i, then - sum(a_i) at 
	# the index of r_0 and the remaining coefficients at the appropriate places.
	property LATTICE_NORMAL_FCT_VECTOR : Map<Int,Map<Int,Vector<Rational>>>;
	
	# @category Tropical geometry
	# Rows of this matrix correspond to [[CODIM_1_FACES]], and each row contains the weighted sum:
	# sum_{cone > codim-1-face}( weight(cone) * [[LATTICE_NORMALS]]->{codim-1-face}->{cone})
	property LATTICE_NORMAL_SUM : Matrix<Rational>;
	
	# @category Tropical geometry
	# Rows of this matrix correspond to [[CODIM_1_FACES]] (or [[CMPLX_CODIM_1_FACES]] in the homog. case), and each row 
	# contains a function vector for the corresponding row of [[LATTICE_NORMAL_SUM]]. This function vector is computed 
	# in the same way as described under [[LATTICE_NORMAL_FCT_VECTOR]].
	# Note that for any codim-1-faces at which the complex is not balanced, the corresponding row is a zero row
	# If a face is balanced can be checked under [[BALANCED_FACES]].
	property LATTICE_NORMAL_SUM_FCT_VECTOR : Matrix<Rational>;
	
	# @category Tropical geometry
	# A vector whose entries correspond to the rows of CODIM_1_FACES. The i-th entry is true, if and only 
	# if the complex is balanced at that face
	property BALANCED_FACES : Vector<Bool>;
	
	# @category Polyhedral complex
	# A matrix of the rays of the fan. This should be used *instead of* [[INPUT_RAYS]], if the coordinates of the
	# fan should be interpreted as homogeneous coordinates and the fan as the complex at x0 = 1.
	# The input rays are normalized to x0 = 1 and the fan is then initialized with the normalized rays as
	# [[INPUT_RAYS]].
	# [[INPUT_CONES]] can be combined with this as usual. If your rays are already homogenized and you are sure they
	# are also your rays, you can directly put this into RAYS and manually set USES_HOMOGENEOUS_C=>TRUE
	property INPUT_HOM_RAYS: Matrix<Rational>;
	
	# @category Polyhedral complex
	# A matrix of generators of the lineality space, but in homogeneous coordinates (i.e. x0 should be 0, otherwise 
	# this throws an error). This should be used *instead of* [[INPUT_LINEALITY]] / [[LINEALITY_SPACE]]
	property INPUT_HOM_LINEALITY : Matrix<Rational>;
	
	# @category Polyhedral complex
	# Indicates whethere this fan's coordinates should be interpreted as affine coordinates or as homogeneous coordinates.
	# In the latter case the fan would actually represent the polyhedral complex that comes from intersecting the fan
	# (in affine coordinates) with the affine hyperplane x0 = 1. This property should not be set manually. It will be set
	# as true, if [[INPUT_HOM_RAYS]] or [[INPUT_HOM_LINEALITY]] are used and to false, if [[INPUT_RAYS]] or [[INPUT_LINEALITY]]
	# are used.
	property USES_HOMOGENEOUS_C : Bool;
	
	# @category Polyhedral complex
	# If the fan does not use homogeneous coordinates, this is just a copy of RAYS and actually needn't be requested. Otherwise this computes
	# a matrix of rays of the complex obtained by intersecting the fan with {x0 = 1}. More precisely, each ray r from [[RAYS]] occurs  
	# as a row in this matrix...
	# - once, if r_0 = 1
	# - k times, if r_0 = 0 and k is the number of equivalence classes of maximal cones containing r with respect to the following relation:
	# Two maximal cones m, m' containing r are equivalent, if they are equal or there exists a sequence of maximal cones
	# m = m_1,...m_r = m', such that r is contained in each m_i and each intersection m_i cap m_i+1 contains at least one ray s with s_0 = 1.
	# The reason for this is that, when specifying a piecewise affine linear function on a polyhedral complex, the same directional ray with 
	# x0 = 0 might be assigned two different values, if it is contained in two "non-connected" maximal cones (where connectedness is to be 
	# understood as described above).
	# If there is a [[LOCAL_RESTRICTION]] the above equivalence relation is changed in such a 
	# way that the affine ray s with s_0 = 1 that must be contained in the intersection of
	# two subsequent cones must be a compatible ray
	property CMPLX_RAYS : Matrix<Rational>;
	
	# @category Polyhedral complex
	# An incidence matrix describing which maximal cone in the complex at x0 = 1 is generated by which rays. 
	# Each row corresponds to a maximal cone (More precisely, the i-th element represents the
	# same maximal cone as the i-th element of [[MAXIMAL_CONES]]). The indices in a row refer to rows of [[CMPLX_RAYS]], i.e. the maximal
	# cone described by the i-th element is generated by the rays corresponding to these row indices.
	# If the fan does not use homogeneous coordinates, it is just a copy of [[MAXIMAL_CONES]]
	property CMPLX_MAXIMAL_CONES : IncidenceMatrix;
	
	# @category Polyhedral complex
	# An incidence matrix describing which codim 1 cone in the complex at x0 = 1 is generated by which rays. 
	# Each row corresponds to a codimension one cone (More precisely, the i-th element represents the
	# same codim 1 cone as the i-th element of [[CODIM_1_FACES]]). The indices in a row refer to rows of [[CMPLX_RAYS]], i.e. the cone
	# cone described by the i-th element is generated by the rays corresponding to these row indices.
	# If the fan does not use homogeneous coordinates, it is just a copy of [[CODIM_1_FACES]].
	property CMPLX_CODIM_1_FACES : IncidenceMatrix;
		
	# @category Polyhedral complex
	# This incidence matrix describes the complete polyhedral complex, i.e. it contains all faces
	# of the polyhedral complex
	property CMPLX_CONES : IncidenceMatrix;

	# @category Polyhedral complex
	# A vector with an entry for each row in [[CMPLX_RAYS]]. More precisely, the i-th entry gives the row index
	# of the ray in [[RAYS]] that is equal to the i-th row of [[CMPLX_RAYS]].
	property CMPLX_CONVERSION_VECTOR : Vector<Int>;	
	
	# @category Polyhedral complex
	# Returns the dimension of the polyhedral complex. In the case of non-homogeneous coordinates, this is 
	# just DIM, otherwise DIM-1. When computing this property, it is assumed that the complex is pure.
	property CMPLX_DIM: Int;
	
	# @category Polyhedral complex
	# Returns the ambient dimension of the polyhedral complex. In the case of non-homogeneous coordinates, this is 
	# just FAN_AMBIENT_DIM, otherwise FAN_AMBIENT_DIM-1
	property CMPLX_AMBIENT_DIM: Int;
	
	# @category Polyhedral complex
	# Returns the codimension of the polyhedral complex in its ambient vector space. More precisely, this
	# value is equal to [[CMPLX_AMBIENT_DIM]] - [[CMPLX_DIM]]
	property CMPLX_CODIMENSION: Int;
	
	# @category Polyhedral complex
	# Computes the subset of row indices of RAYS, such that the corresponding rows describe a vertex of the complex.
	# This set is empty if [[USES_HOMOGENEOUS_C]] is false and is the complement of [[DIRECTIONAL_RAYS]]
	property VERTICES : Set<Int>;
	
	# @category Polyhedral complex
	# Computes the subset of row indices of RAYS, such that the corresponding rows describe a directional ray of the complex.
	# This set contains all row indices  if [[USES_HOMOGENEOUS_C]] is false and is the complement of [[VERTICES]]
	property DIRECTIONAL_RAYS : Set<Int>;
	
	# @category Basic properties
	# An arbitrary textual description of the complex, to be specified by the user. Some
	# operations that produce a WeightedComplex automatically set this property to something
	# informative.
	property DESCRIPTION : String;
	
	# @category Tropical geometry/Local computations
	# This contains a list of sets of ray indices (referring to RAYS). All of these sets should 
	# describe cones of the polyhedral complex (though not necessarily maximal ones).
	# A cone is now called compatible with this property, if contains one of these cones
	# If this list is not empty, all computations will be
	# done only on (or around) compatible cones. The documentation of each property will explain
	# in what way this restriction is enforced. 
	# If this list is empty or not defined, there is no restriction.
	# Careful: The implementation assumes that ALL maximal cones are compatible. If in doubt,
	# you can create a complex with a local restriction from a given complex by using one of
	# the "local_..." creation methods
	# This list is assumed to be irredundant, i.e. there are no doubles and no element
	# is a subset of another element.
	property LOCAL_RESTRICTION : IncidenceMatrix;

	# @category Tropical geometry / Lattice normals
	# This is an irredundant list of all lattice generators of all maximal cones
	# If this property exists, lattice normals might be computed faster
	# If you create a variety with the property [[IS_UNIMODULAR]] set to TRUE, then
	# this will simply be a copy of [[RAYS]] (made primitive integer)
	property LATTICE_GENERATORS : Matrix<Integer>;
	
	# @category Tropical geometry / Lattice normals
	# This incidence matrix gives a lattice basis for each maximal cone. More precisely it 
	# gives a lattice basis whose span contains the lattice of the maximal cone. Row i 
	# corresponds to cone i and gives lattice generator indices referring to
	# [[LATTICE_GENERATORS]]
	# If this property is computed via rules, it does indeed give a lattice basis for the
	# cone lattice, but when it is computed during an operation like refinement or divisor
	# it will in general be larger.
	# If this property exists, lattice normals might be computed faster.
	# If you create a variety with the property [[IS_UNIMODULAR]] set to TRUE, then
	# this will simply be a copy of [[MAXIMAL_CONES]]
	property LATTICE_BASES : IncidenceMatrix;
	
	# @category Tropical geometry / Lattice normals
	# This property is not computed anywhere but should be set to TRUE by the user upon 
	# initialization, if all cones of the fan/complex are unimodular in the sense that 
	# ANY linearly independent subset of their rays generates 
	# the lattice of the cone
	# If this property is TRUE, [[LATTICE_GENERATORS]] and [[LATTICE_BASES]] can be computed
	# much faster.
	property IS_UNIMODULAR : Bool; 
	
	
	## RULES ################################################################
	
	# The different weights for the following two rules make sure that existence of INPUT_HOM_* is checked first (since INPUT_* will always be set by INPUT_HOM_*
	
	rule USES_HOMOGENEOUS_C : INPUT_RAYS | INPUT_LINEALITY {
	    $this->USES_HOMOGENEOUS_C = FALSE;
	}
	weight 0.2;
		
	rule USES_HOMOGENEOUS_C : INPUT_HOM_RAYS | INPUT_HOM_LINEALITY {
	    $this->USES_HOMOGENEOUS_C = TRUE;
	}
	weight 0.1;
	
	rule USES_HOMOGENEOUS_C : RAYS {
	  $this->USES_HOMOGENEOUS_C = FALSE;
	}
	weight 0.3;
	
	#------------------------------------------------------------------------#
	
	rule LOCAL_RESTRICTION : {
	  $this->LOCAL_RESTRICTION = new IncidenceMatrix();
	}
	
	#------------------------------------------------------------------------#
	
	rule INPUT_RAYS : INPUT_HOM_RAYS {
	    #Normalize rays first
	    my $m = new Matrix<Rational>($this->INPUT_HOM_RAYS->rows(), $this->INPUT_HOM_RAYS->cols());
	    for(my $r = 0; $r < $this->INPUT_HOM_RAYS->rows(); $r++) {
		if($this->INPUT_HOM_RAYS->row($r)->[0] == 0) {
		    $m->row($r) = $this->INPUT_HOM_RAYS->row($r);
		}
		else {
		    $m->row($r) = ($this->INPUT_HOM_RAYS->row($r)) * (1 / $this->INPUT_HOM_RAYS->row($r)->[0]);
		}
	    }
	    $this->INPUT_RAYS = $m;
	} 
	weight 0.1; 
	#Need this weight, otherwise this function won't be called when I ask for 
	# RAYS in some rule condition
	
	#------------------------------------------------------------------------#
	
	## !!!!!!!!!!!!! FIXME: This should probably be INPUT_LINEALITY, but as long as polymake doesn't actually use that property, it makes no sense to do that
	rule LINEALITY_SPACE : INPUT_HOM_LINEALITY {
	    #Just check if all the first entries are 0
	    for(my $r = 0; $r < $this->INPUT_HOM_LINEALITY->rows(); $r++) {
		if($this->INPUT_HOM_LINEALITY->row($r)->[0] != 0) {
		    die "Invalid coordinates for lineality space, x0 should be 0";
		}
	    }
	
	    $this->LINEALITY_SPACE = $this->INPUT_HOM_LINEALITY;
	}
	weight 0.02;
		
	#------------------------------------------------------------------------#
	
	rule RAYS, MAXIMAL_CONES: LINEALITY_SPACE {
	  my @a = ();
	  my $s = new Set<Int>();
	  @a = (@a,$s);
	  $this->MAXIMAL_CONES = \@a;
	  $this->RAYS = new Matrix<Rational>(0,$this->LINEALITY_SPACE->cols());
	}
	weight 6.10;
		
	#------------------------------------------------------------------------#
	
	rule CODIM_1_FACES, CODIM_1_IN_MAXIMAL_CONES : MAXIMAL_CONES, USES_HOMOGENEOUS_C, FAN_AMBIENT_DIM, LINEALITY_SPACE, LOCAL_RESTRICTION{
	  computeCodimensionOne($this);
# 	  my @cones = ();
# 	  for my $c (0 .. $this->MAXIMAL_CONES->rows()-1) {
# 	    my $cone = new Cone<Rational>(RAYS=>$this->RAYS->minor($this->MAXIMAL_CONES->row($c),All));
# 	    $cone->RAYS_IN_FACETS;
# 	    @cones = (@cones,$cone);
# 	  }
# 	  computeCodimensionOneViaCones($this,@cones);
	}
	
	#------------------------------------------------------------------------#
	  
	rule LATTICE_NORMALS : CODIM_1_FACES, MAXIMAL_CONES,  CODIM_1_IN_MAXIMAL_CONES, LINEALITY_SPACE, FAN_AMBIENT_DIM {
	  computeLatticeNormals($this);
	}
	weight 3.10;
	
	#------------------------------------------------------------------------#
	  
# 	We prefer this rule since it seems to be always faster
	rule LATTICE_NORMALS : CODIM_1_FACES, MAXIMAL_CONES,  CODIM_1_IN_MAXIMAL_CONES, LINEALITY_SPACE, FAN_AMBIENT_DIM, USES_HOMOGENEOUS_C, LATTICE_GENERATORS, LATTICE_BASES {
	  computeProjectionLattice($this);
	}
	weight 3.5;
	
	#------------------------------------------------------------------------#
	
	rule IS_BALANCED : CODIM_1_FACES, LATTICE_NORMAL_SUM, FAN_AMBIENT_DIM{
	  computeIfBalanced($this);
	}
	
	#------------------------------------------------------------------------#
	
	rule LATTICE_NORMAL_FCT_VECTOR, LATTICE_NORMAL_SUM_FCT_VECTOR, BALANCED_FACES : LATTICE_NORMAL_SUM, LATTICE_NORMALS, TROPICAL_WEIGHTS, N_RAYS, LINEALITY_SPACE, LINEALITY_DIM, CMPLX_RAYS, CMPLX_CODIM_1_FACES, CMPLX_MAXIMAL_CONES, FAN_AMBIENT_DIM {
	  computeFunctionVectors($this);
	}
	
	#------------------------------------------------------------------------#
	
	rule LATTICE_NORMAL_SUM : LATTICE_NORMALS, TROPICAL_WEIGHTS, FAN_AMBIENT_DIM {
	    computeLatticeNormalSum($this);
	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_RAYS, CMPLX_MAXIMAL_CONES, CMPLX_CODIM_1_FACES, CMPLX_CONVERSION_VECTOR : RAYS, MAXIMAL_CONES, CODIM_1_FACES, CODIM_1_IN_MAXIMAL_CONES, FAN_AMBIENT_DIM, LOCAL_RESTRICTION {
	  computeComplexData($this);
	}
	
	#------------------------------------------------------------------------#
# 	
# 	rule INPUT_RAYS, INPUT_CONES : LINEALITY_SPACE {
# 	  $this->INPUT_RAYS = new Matrix<Rational>(0,$this->LINEALITY_SPACE->cols());
# 	  $this->INPUT_CONES = new Vector<Set<Int>>();
# 	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_AMBIENT_DIM : RAYS, LINEALITY_SPACE, USES_HOMOGENEOUS_C { # FIXME: Copy ambient_dim
	  my $d = max($this->RAYS->cols(), $this->LINEALITY_SPACE->cols());
	  $this->CMPLX_AMBIENT_DIM = $this->USES_HOMOGENEOUS_C? 
	      $d-1 :
	      $d;		     
	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_DIM : RAYS,MAXIMAL_CONES,LINEALITY_DIM, USES_HOMOGENEOUS_C { # FIXME: Copy dim
	  my $d = $this->LINEALITY_DIM;
	  if($this->MAXIMAL_CONES->rows() > 0) {
	    my $m = new Matrix<Rational>($this->RAYS->minor($this->MAXIMAL_CONES->row(0),All));
	    $d = $d + rank($m);
	  }
	  $this->CMPLX_DIM = $this->USES_HOMOGENEOUS_C?
	    ($d-1) : $d;
	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_CODIMENSION : CMPLX_AMBIENT_DIM, CMPLX_DIM {
	  $this->CMPLX_CODIMENSION = $this->CMPLX_AMBIENT_DIM - $this->CMPLX_DIM;
	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_CONES : RAYS, MAXIMAL_CONES, USES_HOMOGENEOUS_C{
	  $this->CMPLX_CONES = computeAllCones($this->RAYS,$this->MAXIMAL_CONES,$this->USES_HOMOGENEOUS_C);
	}
	
	#------------------------------------------------------------------------#
	
	rule VERTICES, DIRECTIONAL_RAYS : RAYS, USES_HOMOGENEOUS_C {
	  my @a = separateRayMatrix($this->RAYS,$this->USES_HOMOGENEOUS_C);
	  $this->VERTICES = $a[0];
	  $this->DIRECTIONAL_RAYS = $a[1];
	}
	
	#------------------------------------------------------------------------#
	
	rule DESCRIPTION : {
	  $this->DESCRIPTION = "No description available";
	}
	
	#------------------------------------------------------------------------#
	
	rule IS_UNIMODULAR : {
	  $this->IS_UNIMODULAR = FALSE;
	}
	
	#------------------------------------------------------------------------#
	
	rule LATTICE_BASES, LATTICE_GENERATORS : RAYS, MAXIMAL_CONES, DIRECTIONAL_RAYS, VERTICES, IS_UNIMODULAR, LINEALITY_SPACE {
	  computeLatticeBases($this);
	}
	
	## METHODS #################################################################
	
	# @category Basic properties
	# This computes the dimension of the fan in the following way: If the fan has rays, it simply
	# calls DIM, otherwise it returns LINEALITY_DIM.
	# FIXME: This is a fix for the problem that a fan only defined with lineality space will have 'dimension 0'
	# (Actually, if we give only one ray [0,..0], it will break and start filling up the RAM)
	# So we should delete this function when this is fixed.
# 	user_method dim_fix {
# 	  my $this = shift;
# 	  if(defined($this->lookup("INPUT_RAYS")) || defined($this->lookup("INPUT_HOM_RAYS")) || defined($this->lookup("RAYS"))) {
# 	    if($this->RAYS->rows() > 0) {
# 	      return $this->DIM;
# 	    }
# 	  }
# 	  return $this->LINEALITY_DIM;
# 	}
	
	# @category Basic properties
	# This computes the ambient dimension in the following way: If the fan has rays, it simply
	# calls AMBIENT_DIM, otherwise it returns LINEALITY_SPACE->cols().
	# FIXME: This is a fix for the problem that a fan only defined with lineality space will have 'ambient dimension 0'
	# (if I give INPUT_RAYS=>[])
	# So we should delete this function when this is fixed.
# 	user_method ambient_dim_fix {
# 	  my $this = shift;
# 	  my $ir = $this->lookup("INPUT_RAYS");
# 	  if(defined($ir)) {
# 	    if($ir->cols() == 0) {
# 	      return $this->LINEALITY_SPACE->cols();
# 	    }
# 	  }
# 	  return $this->AMBIENT_DIM;
# 	}
	
	# @category Basic properties
	# This computes the ambient dimension ignoring homogeneous coordinates. More precisely, returns
	# ambient_dim_fix, if the fan does not use homog. coordinates, otherwise it returns ambient_dim_fix-1
# 	user_method real_ambient_dim {
# 	  my $this = shift;
# 	  return $this->USES_HOMOGENEOUS_C? $this->ambient_dim_fix-1 : $this->ambient_dim_fix; # FIXME
# 	}
	
	# @category Tropical methods
	# Convenience method, returns LATTICE_NORMALS->{i}->{j}
	# @param Int i The index of the facet
	# @param Int j The index of the maximal cone
	# @return The lattice normal vector of cone j wrt. facet i
	user_method lattice_normal {
	    my $this = shift;
	    my $i = shift;
	    my $j = shift;
	    
	    return $this->LATTICE_NORMALS->{$i}->{$j};
	}
	
	# @category Polyhedral geometry
	# Transforms the fan into homogeneous coordinates
	# @return If this fan uses homog. coordinates, returns the fan itself, Otherwise it will replace the ray matrix
	# by the following matrix: [0,ray] for any ray of the original fan and one affine ray [1,0,...0] appended. In [[MAXIMAL_CONES]]
	# all get the additional affine ray and [[TROPICAL WEIGHTS]] is simply copied
	user_method homogenize {
	  my $this = shift;
	  if($this->USES_HOMOGENEOUS_C) {
	    return $this;
	  }
	  
	  #Create the new ray matrix
	  my $rayMatrix = new Matrix<Rational>(0,$this->CMPLX_AMBIENT_DIM+1);
	  
	  #Add the remaining rays with a zero at front
	  my $origRays = (zero_vector<Rational>($this->RAYS->rows())) | $this->RAYS;
	  $rayMatrix = $rayMatrix / $origRays;
	  #Add the affine ray
	  my $affineRay = (new Vector<Rational>([1])) | (zero_vector<Rational>($this->CMPLX_AMBIENT_DIM)); 
	  $rayMatrix = (new Matrix<Rational>($rayMatrix)) / $affineRay;
	  my $affineIndex = $rayMatrix->rows()-1;
	  
	  
	  
	  #Now add the last ray to each maximal cone
	  my @mcones = @{$this->MAXIMAL_CONES};
	  my @newmcones = ();
	  for my $set (@mcones) {
	    @newmcones = (@newmcones, $set + $affineIndex);
	  }
	  
	  #Now add the last ray to all local restriction cones
	  my @local_restriction = @{$this->LOCAL_RESTRICTION};
	  my @new_local_restriction = ();
	  for my $lr (@local_restriction) {
	    @new_local_restriction = (@new_local_restriction, $lr + $affineIndex);
	  }
	  
	  #If there are no maximal cones (because the fan is only lineality space),we add a maximal cone
	  # with just the origin
	  if(scalar(@newmcones) == 0) {
	    my $aSet = new Set<Int>(); $aSet = $aSet + $affineIndex;
	    @newmcones = (@newmcones, $aSet);
	  }
	  
	  my @weight = defined($this->lookup("TROPICAL_WEIGHTS"))? @{$this->TROPICAL_WEIGHTS} : ();
	  
	  #If lattice bases have been computed, we need to copy them
	  my $lattice_exists = defined($this->lookup("LATTICE_BASES"));
	  my $lattice_bases = new IncidenceMatrix();
	  my $lattice_generators = new Matrix<Integer>();
	  if($lattice_exists) {
	    $lattice_bases = $this->LATTICE_BASES;
	    $lattice_generators = $this->LATTICE_GENERATORS;
	    $lattice_generators = (zero_vector<Integer>($lattice_generators->rows())) | $lattice_generators;
	  }
	  
	  if(!$lattice_exists) {
	    return new WeightedComplex(RAYS=>$rayMatrix,MAXIMAL_CONES=>\@newmcones,TROPICAL_WEIGHTS=>\@weight,
				   USES_HOMOGENEOUS_C=>TRUE, LINEALITY_SPACE=> (zero_vector<Rational>($this->LINEALITY_DIM)) | $this->LINEALITY_SPACE, LOCAL_RESTRICTION=>\@new_local_restriction);
	  }
	  else {
	    return new WeightedComplex(RAYS=>$rayMatrix,MAXIMAL_CONES=>\@newmcones,TROPICAL_WEIGHTS=>\@weight,
				   USES_HOMOGENEOUS_C=>TRUE, LINEALITY_SPACE=> (zero_vector<Rational>($this->LINEALITY_DIM)) | $this->LINEALITY_SPACE, LOCAL_RESTRICTION=>\@new_local_restriction, LATTICE_BASES=>$lattice_bases, LATTICE_GENERATORS=>$lattice_generators);
	  }
	}
	
# 	# @category Polyhedral geometry
# 	# Removes the lineality space of the weighted complex
# 	# @return WeightedComplex The same fan, but without its lineality space
# 	user_method remove_lineality {
# 	  my $this = shift;
# 	  return defined($this->lookup("TROPICAL_WEIGHTS")) ? 
# 	    new WeightedComplex(RAYS=>$this->RAYS,MAXIMAL_CONES=>$this->MAXIMAL_CONES, TROPICAL_WEIGHTS=>$this->TROPICAL_WEIGHTS, USES_HOMOGENEOUS_C=>$this->USES_HOMOGENEOUS_C) :
# 	    new WeightedComplex(RAYS=>$this->RAYS,MAXIMAL_CONES=>$this->MAXIMAL_CONES, USES_HOMOGENEOUS_C=>$this->USES_HOMOGENEOUS_C) ;
# 	}
	
# 	user_method adjHomology {
# 	  my $this = shift;
# 	  #Create set graph
# 	  my $facets = new Vector<Set<Int> >();
# 	  my $maximalInCodim = $this->CODIM_1_IN_MAXIMAL_CONES;
# 	  my $codimInMaximal = transpose($this->CODIM_1_IN_MAXIMAL_CONES);
# 	  for my $mc (0 .. $this->MAXIMAL_CONES->rows() -1) {
# 	      print "Finding adjacencies of cone $mc...\n";
# 	      my $cdset = $codimInMaximal->row($mc);
# 	      for my $cd (@{$cdset}) {
# 		my $mcset = ($maximalInCodim->row($cd) - $mc);
# 		for my $othermc (@{$mcset}) {
# 		  if($othermc > $mc) {
# 		    my $s = new Set<Int>($mc,$othermc);
# 		    $facets = $facets | $s;
# 		  }
# 		}
# 	      }
# 	  }
# 	  my $cplx = new topaz::SimplicialComplex(FACETS=>$facets);
# 	  $cplx->VISUAL;
# 	  return $cplx->HOMOLOGY;
# 	}

	user_method characteristic {
	  my $this = shift;
	  my $cplx = equivalenceComplex($this);
	  if($cplx->HOMOLOGY->size() > 1) {return $cplx->HOMOLOGY->[1]->[1];}
	  else { return 0;}
	}
	
	# @category Tropical geometry / Local computations
	# Takes a WeightedComplex and returns the same complex, but without any 
	# [[LOCAL_RESTRICTION]]
	# @param WeightedComplex w
	# @return WeightedComplex
	user_method delocalize {
	  my $this = shift;
	  return new WeightedComplex(RAYS=>$this->RAYS,MAXIMAL_CONES=>$this->MAXIMAL_CONES,LINEALITY_SPACE=>$this->LINEALITY_SPACE,TROPICAL_WEIGHTS=>$this->TROPICAL_WEIGHTS, USES_HOMOGENEOUS_C=>$this->USES_HOMOGENEOUS_C);
	}

}
