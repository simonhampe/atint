########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file defines the visualization of a weighted polyhedral complex
# (defined as an extension to fan::PolyhedranFan). 
########################################################################

package Visual::WeightedComplex;
# use Polymake::Struct (
#   [ '@ISA' => 'Container' ],
#    '$PolyhedralComplex',
# );

# require Visual;
# require Visual::PointSet;
# require Visual::Wire;
# require Visual::Polygon;

options %Visual::WeightedComplex::decorations=(
    %Visual::Polygons::decorations,
      
    # Flexible<Rational> length of the directional rays
    DirScale => 1,
    
    # String if set to "hidden", the labels indicating the weights are hidden
    WeightLabels => enum("hidden"),
				
    # String If set to "show", the labels indicating the vertex coordinates are displayed, otherwise they are not. Note that this is expensive and significantly increases computation time.
    CoordLabels => enum("show"),
				
    # String If set to "pinned", the weight labels are computed in such a way that they stick to the cells when the complex
    # is exploded. Note that this is expensive and significantly increases computation time.
   # WeightLabelStyle => "",
);

options %Visual::WeightedComplex::BoundingDecorations=(
    %Visual::WeightedComplex::decorations,
    
    # Flexible<Rational> The distance of the border of the bounding box from the smallest box 
    # containing the affine points of the complex. This is only relevant, if BoundingMode is "relative"
    BoundingDistance => 1,

    # Matrix<Rational> A fixed bounding box, determined by two row vectors that specify two of its vertices (on "on top" and one "at the bottom"). Is only relevant, if BoundingMode is "absolute"
    BoundingBox => undef,
							  
    # String If set to "relative", the function determines the smallest possible box containing all affine points of the complex and then enlarges the box by BoundingDistance to all sides. If set to "absolute", BoundingBox must be specified and the complex will be intersected with that box. By default this is set to "relative".
    BoundingMode => enum("relative","absolute"),
						       
    # Array<String> A list of strings to be displayed as labels for the maximal cones. If this is empty, the weight labels (if present and not suppressed by WeightLabels=>"hidden") are displayed
    ConeLabels => undef,
);

object WeightedComplex {
  
  
  # @category Visualization
  # Displays a weighted polyhedral complex in ambient dimension up to 3 (4 in homog. coordinates) by visualizing all its
  # cells in the following way: For each cell, every directional ray is added to every affine ray (which is only the origin
  # in the non-homog. case) and the resulting polytope is displayed. The visualization has the following options:
  # * DirScale: A rational number with which the directional rays are multiplied before added to the affine rays
  # * WeightLabels:  if set to "hidden", the labels indicating the weights are hidden 
  # * CoordLabels: If set to "show", the labels indicating the vertex coordinates are displayed, otherwise they are not. Note that this is expensive and significantly increases computation time.
  user_method CMPLX_VISUAL(%Visual::WeightedComplex::decorations, {CutOff => $Visual::Color::cutoff}) : RAYS, MAXIMAL_CONES {
    my ($this,$decor,$cutoff_decor)=@_;
    
    my $fanDim = $this->CMPLX_DIM;
    
    #Extract self-definded values and delete them
   
    my $dirScale = 1;
    if(defined($$decor{"DirScale"})) {
      $dirScale = $$decor{"DirScale"};
    }
    delete($$decor{"DirScale"});
    my $showWeights = 1;
    if(defined($$decor{"WeightLabels"})) {
      if($$decor{"WeightLabels"} eq "hidden") {
	$showWeights = 0;
      }
    }
    if(!defined($this->lookup("TROPICAL_WEIGHTS"))) {
      $showWeights = 0;
    }
    delete($$decor{"WeightLabels"});
    my $showCoordinates = 0;
    if(defined($$decor{"CoordLabels"})) {
      if($$decor{"CoordLabels"} eq "show") {
	$showCoordinates = 1;
      }
    }
    delete($$decor{"CoordLabels"});
    if($showCoordinates == 0) {
      $$decor{"VertexLabels"} = "hidden";
    }
    
    $cutoff_decor=$cutoff_decor->{CutOff};
    my $cutoff_decor3d=$cutoff_decor;
    my $cutoff_decor2d=$cutoff_decor;
    unless (is_hash($cutoff_decor)) {
      $cutoff_decor3d={ FacetColor => $cutoff_decor };
      $cutoff_decor2d={ EdgeColor => $cutoff_decor };
    }
    
    #Set some default values
    if(!defined($$decor{"FacetTransparency"}) && $fanDim >= 2 ) {
      $$decor{"FacetTransparency"} = 1;
    }
    
    #Compute geometry
    my @result = computeVisualPolyhedra($this->homogenize,new Rational($dirScale),$showWeights);
    my $weightCenters = pop(@result);
    
    #Compute visualizations
    
    my @cells_visual;
    #my $index = 0;
    for my $cell (@result) {
      #$cell->VERTEX_LABELS = ();
      #Compute coordinate labels if necessary
      if($showCoordinates != 0) {
	  #Create labels for vertices
	  my @labels = ();
	  my $vtx = $cell->VERTICES;
	  for(my $row = 0; $row < $vtx->rows(); $row++) {
	      my $coords = $this->USES_HOMOGENEOUS_C? 
				$vtx->row($row)->slice(1,$vtx->cols()-1) :
				$vtx->row($row);
	      @labels = (@labels,"(".$coords.")");
	  }
	  $cell->VERTEX_LABELS = \@labels;
      }
      
      push @cells_visual, ($cell->VISUAL( $decor ));
    }
    
    if($showWeights != 0) {
      push @cells_visual, $weightCenters->VISUAL_POINTS(PointColor=>'black', PointThickness=>0.1);
    }
    
    
    
    visualize(new Visual::PolyhedralFan( Name => $this->name,
					  PolyhedralFan => $this,
					  @cells_visual));
					
  }
  precondition : CMPLX_AMBIENT_DIM { $this->CMPLX_AMBIENT_DIM<=3 }
  
  # ---------------------------------------------------------------------------------------------------------
  
  # @category Visualization
  # Displays a (possibly weighted) polyhedral complex by intersecting it with a bounding box. This bounding box
  # is either defined by the vertices of the complex and the option "BoundingDistance" or explicitly given by
  # "BoundingBox" and by setting "BoundingMode" to "absolute"
  user_method BB_VISUAL(%Visual::WeightedComplex::BoundingDecorations, {CutOff => $Visual::Color::cutoff}) : RAYS, MAXIMAL_CONES, CMPLX_DIM, CMPLX_AMBIENT_DIM {
    my ($this,$decor,$cutoff_decor)=@_;
    
    #Take care of self-defined decor options and delete them
    if(is_zerocycle($this)) {
      die "Cannot draw zero cycle";
    }
    
    my $showWeights = 1;
    if(defined($$decor{"WeightLabels"})) {
      if($$decor{"WeightLabels"} eq "hidden") {
	$showWeights = 0;
      }
    }
    if(!defined($this->lookup("TROPICAL_WEIGHTS"))) {
      $showWeights = 0;
    }
    delete($$decor{"WeightLabels"});
    my $showCoordinates = 0;
    if(defined($$decor{"CoordLabels"})) {
      if($$decor{"CoordLabels"} eq "show") {
	$showCoordinates = 1;
      }
    }
    delete($$decor{"CoordLabels"});
    if($showCoordinates == 0) {
      $$decor{"VertexLabels"} = "hidden";
    }
    my $isRelative = 1;
    if(defined($$decor{"BoundingMode"})) {
      if($$decor{"BoundingMode"} eq "absolute") {
	$isRelative = 0;
      }
    }
    delete($$decor{"BoundingMode"});
    my $boundingDistance = new Rational(1);
    if(defined($$decor{"BoundingDistance"})) {
      $boundingDistance = $$decor{"BoundingDistance"};
    }
    delete($$decor{"BoundingDistance"});
    my $boundingBox = new Matrix<Rational>();
    if(defined($$decor{"BoundingBox"})) {
      $boundingBox = $$decor{"BoundingBox"};
    }
    delete($$decor{"BoundingBox"}); 
    my $haveConeLabels = 0;
    my $clabels = new Array<String>();
    if(defined($$decor{"ConeLabels"})) {
      $haveConeLabels = 1;
      $clabels = $$decor{"ConeLabels"};
    }
    delete($$decor{"ConeLabels"});
    
    #We don't need that here
    delete($$decor{"DirScale"});
    
    #Set some default values
    my $dim = $this->CMPLX_DIM;
    if(!defined($$decor{"FacetTransparency"}) && $dim >= 2) {
      $$decor{"FacetTransparency"} = 1;
    }
    
    #Make sure that the bounding box has the right dimension, otherwise, we get a segfault
    if(!$isRelative) {
      my $m = new Matrix<Rational>($boundingBox);
      if($m->rows() < 2 || $m->cols() < $this->CMPLX_AMBIENT_DIM) {
	die "Bounding box has invalid dimension\n";
      }
    }
    my @result = computeBoundedVisual($this->homogenize,$isRelative,$showWeights, new Rational($boundingDistance),0,(new Matrix<Rational>($boundingBox)),$clabels);
    my @cells_visual;
    my $weightCenters = pop(@result);
    
    for my $cell (@result) {
      $cell->VERTEX_LABELS = ();
	
      #Compute coordinate labels if necessary
      if($showCoordinates != 0) {
	  #Create labels for vertices
	  my @labels = ();
	  my $vtx = $cell->VERTICES;
	  for(my $row = 0; $row < $vtx->rows(); $row++) {
	      my $coords = $this->USES_HOMOGENEOUS_C? 
				$vtx->row($row)->slice(1,$vtx->cols()-1) :
				$vtx->row($row);
	      @labels = (@labels,"(".$coords.")");
	  }
	  $cell->VERTEX_LABELS = \@labels;
      }
      
      push @cells_visual, ($cell->VISUAL( $decor ));
  }
  if($showWeights != 0 || $haveConeLabels != 0) {
      push @cells_visual, $weightCenters->VISUAL_POINTS(PointColor=>'black', PointThickness=>0.2);
  }
  
  visualize(new Visual::PolyhedralFan( Name => $this->name,
					  PolyhedralFan => $this,
					  @cells_visual));
  }
  
  # ---------------------------------------------------------------------------------------------------------
  
  # @category Visualization
  # Takes a tropical variety and a (positive) Rational as input and computes the relative bounding box of the visualization with the Rational as BoundingDistance (see also the description of [[BB_VISUAL]]
  # @param Rational distance The distance of the bounding box from the affine part of the variety (Can also be a standard perl number type)
  # @return Matrix<Rational>  A 2x[[CMPLX_AMBIENT_DIM]]-matrix specifying the bounding box (it can be used as input for BoundingBox in [[BB_VISUAL]]
  user_method boundingBox {
    my ($variety, $distance) = @_;
    my @r =  computeBoundedVisual($variety->homogenize, 1, 0, new Rational($distance),1,new Matrix<Rational>());
    return $r[0];
  }
  
}