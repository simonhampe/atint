#######################################################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file defines the functionality necessary to define divisors on tropical varieties
########################################################################################################


#USE fan polytope

# @category Tropical geometry
# NOTE: Deprecated. Use divisor(...) or divisor_nr(...) in conjunction with function_value instead
# Takes as input a tropical fan / tropical variety and an array of rational values. The array length should coincide 
# with the number of [[CMPLX_RAYS]] of the fan plus the dimension of the lineality space and will be interpreted as a rational
# function, where each value has been assigned to the rays given by $fan->CMPLX_RAYS and to the generators given by $fan->LINEALITY_SPACE  
# (in that order). Missing values will be filled up by 0's, superfluous ones will be ignored. 
# The function will then compute the corresponding Weil divisor and return it as a 
# tropical variety given as a fan. The fan uses homogeneous coordinates, if and only the input fan does.
# Note that this still produces a meaningful result, if the WeightedComplex is not balanced: The "divisor" of a given function is computed by taking all codim-1-faces, at which the complex is balanced and computing weights there.
# @param WeightedComplex A tropical variety on which the divisor is computed. 
# @param values An array of rational values that define an integer affine map on the fan. 
# @return The divisor of the function defined by values on the given fan, as a tropical variety.
user_function divisorByValue {
  my ($fan,@values) = @_;
  return divisorByValueVector($fan,new Vector<Rational>(@values));
}

# @category Tropical geometry
# Takes as input a tropical variety X , a rational function f and optionally a positive integer k. It then computes
# f^k * X
#Note that this still produces a meaningful result, if the WeightedComplex is not balanced: The "divisor" of a given function is computed by taking all codim-1-faces, at which the complex is balanced and computing weights there.
# @param WeightedComplex X A tropical variety
# @param RationalFunction f A rational function, defined on a DOMAIN that contains X. It can be in non-homog. coordinates, even if X is in homog. coordinates, but then its AMBIENT_DIM has to be equal to X->AMBIENT_DIM. Otherwise you will have to homogenize the function first.
# @param Int k Optional. A positive integer. Note that if k is given, this will actually ignore f->POWER. Is 1 by default.
# @return WeightedComplex The divisor f^k * X. It is given in homogeneous coordinates, if and only if: Either X is already in homogeneous coordinates or f is defined on a homogeneous DOMAIN (which is implicitly the case for ALL MinMaxFunctions)
user_function divisor {
  my ($X,$f,$k) = @_;
  
  $k = -1 unless defined($k);
  
  if(is_zerocycle($X)) {
    return $X;
  }
  
  if($f->isa("MinMaxFunction")) {
    return divisor_minmax($X,$f,($k == -1? $f->POWER : $k));
  }
  else {
    return divisor_rational($X,$f,($k == -1? $f->POWER : $k));
  }
}

# @category Tropical geometry
# Takes as input a tropical variety and an arbitrarily long list of RationalFunction objects f_1,...,f_k. It will 
## then compute f_k^a_k * ... * f_1^a_1 * X, where a_i = f_i->POWER
# @param WeightedComplex X
# @param RationalFunction A list f_1,...,f_k
# @return WeightedComplex The divisor f_k * ... * f_1 * X. It is in homogeneous coordinates, if and only if: 
# Either X is in homog. coordinates or one of the functions is defined on a homogeneous domain.
user_function divisor_list {
  my ($X,@functions) = @_;
  
  if(scalar(@functions) == 0) { return $X;}
  if(scalar(@functions) > $X->CMPLX_DIM) {
    return zero_cycle();
  }
  
  for my $f (@functions) {
      $X = divisor($X,$f,$f->POWER);
  }
  return $X;
}

# @category Tropical geometry
# Works exactly as divisor_list(WeightedComplex;RationalFunction,...). Should be called
# ONLY,when every occuring function f is defined on a DOMAIN equal to X (in the sense that
# all properties like RAYS, MAXIMAL_CONES, etc. agree. Being equal as varieties is not
# sufficient). In this case this function will in general be faster.
user_function divisor_list_nr {
  my ($X,@functions) = @_;
  if(scalar(@functions) == 0) { return $X; }
  if(scalar(@functions) > $X->CMPLX_DIM) {
    return zero_cycle();
  }
  
  my $fmatrix = new Matrix<Rational>(0,$functions[0]->RAY_VALUES->dim() + $functions[0]->LIN_VALUES->dim());
  
  for my $f (@functions) {
    my $rvalues = $f->RAY_VALUES;
    my $lvalues = $f->LIN_VALUES;
    my $values = $rvalues | $lvalues;
    for(my $p = 1; $p <= $f->POWER; $p++) {
      $fmatrix /= $values;
    }
  }
  
  return divisorByValueMatrix($X,$fmatrix);
  
}
