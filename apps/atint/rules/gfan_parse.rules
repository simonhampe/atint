########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2012, Simon Hampe hampe@mathematik.uni-kl.de
#
#  Contains a function to parse a standard gfan output file into a WeightedComplex
########################################################################

# @category External programs / Gfan
# This takes as input the name of a file containing a fan with or without multiplicities in standard gfan output 
# (not xml!) and parses it into a tropical variety
# @param String path The file name
# @return WeightedComplex
user_function variety_from_gfan {
    my $path = shift;
    
    #Open file and load into string
    my $file;
    open($file, $path) or die "Cannot open file";
    my $content;
    while(<$file>) {
	$content .= $_;
    }
    close $file;
    
    #Remove all comments and curly braces
    $content =~ s/\#.*//g;
    $content =~ s/[\{\}]//g;
    
    #First: Find the rays --------------------------------------
    my $rays = new Matrix<Rational>();
    if(!($content =~ /.*RAYS\n\n..*/si)) { #Skip RAYS if empty
      my ($raytext)= ($content =~ /RAYS\n(.*?)\n\n/si);
      
      #Separate by line break
      my @vectors = split /\n/, $raytext;
      for(my $ray = 0; $ray < scalar(@vectors); $ray++) {
	#Separate by whitespace
	my @digits = split /\s+/, $vectors[$ray];
	my $v = new Vector<Rational>(\@digits);
	if($ray == 0) {
	    $rays = new Matrix<Rational>(0,$v->dim());
	}
	$rays = $rays / $v;
      }
    }
    
    #Second: Find lineality space --------------------------------
    my $lineality = new Matrix<Rational>();
    if(!($content =~ /.*LINEALITY_SPACE\n\n..*/si)) {
      my ($lintext) = ($content =~/LINEALITY_SPACE\n(.*?)\n\n/si);
      
      #Separate by line break
      my @linrows = split /\n/, $lintext;
      for(my $lin = 0; $lin < scalar(@linrows); $lin++) {
	my @digits = split /\s+/, $linrows[$lin];
	my $l = new Vector<Rational>(\@digits);
	if($lin == 0) {
	    $lineality = new Matrix<Rational>(0,$l->dim());
	    if($rays->rows() == 0) {
		$rays = new Matrix<Rational>(0,$lineality->cols());
	    }
	}
	$lineality = $lineality / $l;
      }
    }
    if($lineality->rows() == 0) {
	$lineality = new Matrix<Rational>(0,$rays->cols());
    }
    
    #Third: Find the weights -------------------------------------
    my $weights;
    my ($weighttext) = ($content =~ /MULTIPLICITIES\n(.*)/si);
    
    #Separate by line break
    my @weightrows = split /\n/, $weighttext;
    my @weightarray;
    for(my $w = 0; $w < scalar(@weightrows); $w++) {
	@weightarray = (@weightarray, new Integer($weightrows[$w]));
    }
    $weights = new Vector<Integer>(\@weightarray);
    
    #Fourth: Find the cones ---------------------------------------
    my $cones = new IncidenceMatrix(0,$rays->rows());
    my $conetext;
    if($weighttext eq "") { ($conetext) = ($content =~ /MAXIMAL_CONES\n(.*)/si);}
    else { ($conetext) = ($content =~ /MAXIMAL_CONES\n(.*?)\n\n/si); }
    
    #Separate by line break
    my @conerows = split /\n/, $conetext;
    for(my $co = 0; $co < scalar(@conerows); $co++) {
	my @digits = split /\s+/, $conerows[$co];
	my $s = new Set<Int>(\@digits);
	$cones = new IncidenceMatrix($cones / $s);
    }
    
    
    
    
    #Create result -----------------------
    
    if($weights->dim() > 0) {
	return new WeightedComplex(RAYS=>$rays, MAXIMAL_CONES=>$cones, LINEALITY_SPACE=>$lineality,TROPICAL_WEIGHTS=>$weights);
    }
    else {
	return new WeightedComplex(RAYS=>$rays, MAXIMAL_CONES=>$cones, LINEALITY_SPACE=>$lineality);
    }
    
}