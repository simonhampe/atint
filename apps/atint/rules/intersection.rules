########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains functionality to compute intersection products
########################################################################

# @category Tropical geometry
# Computes the intersection product of two tropical cycles in a common ambient vector space V.
# @param WeightedComplex X The first tropical variety
# @param WeightedComplex Y The second tropical variety. Should have the same actual ambient dimension (homogeneous coordinates don't count) as X.
# @return WeightedComplex Z The intersection product X*Y in V = R^n, where n is the ambient dimension of X and Y. The result has homogeneous coordinates, if and only if X or Y has homog. coordinates.
user_function cycle_intersection {
  my ($X,$Y) = @_;
  
  #If the codimensions of the varieties add up to something larger then CMPLX_AMBIENT_DIM, return the 0-fan
  my $codimsum = $X->CMPLX_CODIMENSION + $Y->CMPLX_CODIMENSION;
  if($codimsum > $X->CMPLX_AMBIENT_DIM) {
    return zero_cycle();
  }
  
  #Compute the cross product
  my $Z = product_complex( $X,$Y);
  
  #Compute the diagonal divisor on the cross product
  my $ad = $X->CMPLX_AMBIENT_DIM;
  my @psi = diagonal_functions($ad);
  for my $f (@psi) {
    $Z = divisorByPLF($Z,$f);
  }
  
  #Then project
  my $raymatrix = $Z->RAYS->minor(All,sequence(0,$Z->USES_HOMOGENEOUS_C? $ad+1 : $ad));
  my @cones = @{$Z->MAXIMAL_CONES};
  my @weights = @{$Z->TROPICAL_WEIGHTS};
  my $uses_homog = $Z->USES_HOMOGENEOUS_C;
  return new WeightedComplex( RAYS=>$raymatrix,MAXIMAL_CONES=>\@cones,TROPICAL_WEIGHTS=>\@weights,USES_HOMOGENEOUS_C=>$uses_homog);
}

# @category Tropical geometry
# Computes the degree of a tropical variety as the degree of the 0-dimensional complex obtained when intersecting
# the variety with an appropriate linear space L^n_k
# @param WeightedComplex complex
# @return Int
user_function degree {
  my $cplx = shift;
  #If its 0-dimensional, just add up the weights
  if($cplx->CMPLX_DIM == 0) {
    my $degree = 0;
    for my $tw (@{$cplx->TROPICAL_WEIGHTS}) {
      $degree += $tw;
    }
    return $degree;
  }
  #Otherwise compute the appropriate intersection product
  my $n = $cplx->CMPLX_AMBIENT_DIM;
  my $k = $cplx->CMPLX_CODIMENSION;
  return degree(cycle_intersection($cplx,tropical_lnk($n,$k)));
}