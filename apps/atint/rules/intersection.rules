########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains functionality to compute intersection products
########################################################################

# @category Tropical geometry
# Computes the intersection product of two tropical cycles in a common ambient vector space V.
# @param WeightedComplex X The first tropical variety
# @param WeightedComplex Y The second tropical variety. Should have the same actual ambient dimension (homogeneous coordinates don't count) as X.
# @return WeightedComplex Z The intersection product X*Y in V = R^n, where n is the ambient dimension of X and Y. The result has homogeneous coordinates, if and only if X or Y has homog. coordinates.
# user_function cycle_intersection {
#   my ($X,$Y) = @_;
#   
#   #If the codimensions of the varieties add up to something larger then CMPLX_AMBIENT_DIM, return the 0-fan
#   my $codimsum = $X->CMPLX_CODIMENSION + $Y->CMPLX_CODIMENSION;
#   if($codimsum > $X->CMPLX_AMBIENT_DIM) {
#     return zero_cycle();
#   }
#   
#   #Compute the cross product
#   my $Z = product_complex( $X,$Y);
#   
#   #Compute the diagonal divisor on the cross product
#   my $ad = $X->CMPLX_AMBIENT_DIM;
#   my @psi = diagonal_functions($ad);
#   for my $f (@psi) {
#     $Z = divisorByPLF($Z,$f);
#   }
#   
#   #Then project
#   my $raymatrix = $Z->RAYS->minor(All,sequence(0,$Z->USES_HOMOGENEOUS_C? $ad+1 : $ad));
#   my @cones = @{$Z->MAXIMAL_CONES};
#   my @weights = @{$Z->TROPICAL_WEIGHTS};
#   my $uses_homog = $Z->USES_HOMOGENEOUS_C;
#   return new WeightedComplex( RAYS=>$raymatrix,MAXIMAL_CONES=>\@cones,TROPICAL_WEIGHTS=>\@weights,USES_HOMOGENEOUS_C=>$uses_homog);
# }

# @category Tropical geometry
# Computes whether a given tropical variety is locally isomorphic to a matroid fan. If the variety 
# is a fan itself, it just checks whether the degree is 1. Otherwise it calls fan_decomposition and 
# checks this on every local fan
# @param WeightedComplex complex
# @param Bool returnNonSmooth Optional, false by default. If true, the function does not return true or false but the index of the first vertex, where the local fan is not smooth and -1, it it is smooth
# @return Bool (or Int)
# user_function is_smooth {
#   my ($this,$pns) = @_;
#   $pns = 0 unless defined($pns);
#     if($pns eq TRUE) {$pns = 1;}
#   if(!$this->USES_HOMOGENEOUS_C) {
#     my $d = degree($this);
#     if($d == 1) {
#       return $pns? -1 : 1;
#     }
#     else {
#       return 0;
#     }
#   }
#   my @a = fan_decomposition($this);
#   my $result = check_smoothness(@a);
#   if($result == -1) {
#     return $pns? -1 : 1;
#   }
#   else {
#     return $result;
#   }
# }