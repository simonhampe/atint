########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains methods treating cubic surfaces in R^3 and collections of
# (families of) lines in this surface, including a data type to represent the result
# of lines_in_cubic
########################################################################

object LinesInCubic {
  
  # @category Defining properties
  # The tropical polynomial defining the surface
  property POLYNOMIAL : MinMaxFunction;
  
  # @category Defining properties
  # The surface containing the lines
  property DIVISOR : WeightedComplex;
  
  # @category Lists of lines
  # A list of all isolated lines without a bounded edge
  property LIST_ISOLATED_NO_EDGE : WeightedComplex : multiple;
  
  # @category Lists of lines
  # A list of all isolated lines with bounded edge
  property LIST_ISOLATED_EDGE : WeightedComplex : multiple;
  
  # @category Lists of lines
  # A list of all families of lines without a bounded edge at a fixed vertex
  property LIST_FAMILY_FIXED_VERTEX : WeightedComplex : multiple;
  
  # @category Lists of lines
  # A list of all families of lines without a bounded  edge and a moving vertex.
  property LIST_FAMILY_MOVING_VERTEX : WeightedComplex : multiple;
  
  # @category Lists of lines
  # A list of all families of lines with (part of) the bounded edge fixed
  property LIST_FAMILY_FIXED_EDGE : WeightedComplex : multiple;
  
  # @category Lists of lines
  # A list of all families of lines with the bounded edge moving in transversal direction
  property LIST_FAMILY_MOVING_EDGE : WeightedComplex : multiple;
  
  # @category Counts
  # The total number of elements in [[LIST_ISOLATED_EDGE]] and [[LIST_ISOLATED_NO_EDGE]]
  property N_ISOLATED : Int;
  
  # @category Counts
  # The total number of families in [[LIST_FAMILY_FIXED_EDGE]], [[LIST_FAMILY_FIXED_VERTEX]], 
  # [[LIST_FAMILY_MOVING_EDGE]] and [[LIST_FAMILY_MOVING_VERTEX]]
  property N_FAMILIES : Int;
  
  
  ### RULES ################################################
  
  rule N_ISOLATED : {
    $this->N_ISOLATED = scalar($this->array_isolated_edge) + scalar($this->array_isolated_no_edge);
  }
  
  rule N_FAMILIES : {
    $this->N_FAMILIES = scalar($this->array_family_fixed_edge) + scalar($this->array_family_fixed_vertex) +
			scalar($this->array_family_moving_edge) + scalar($this->array_family_moving_vertex);
  }
  
  ### METHODS ##############################################
  
  user_method array_isolated_no_edge {
    my $this = shift;
    if(defined($this->lookup("LIST_ISOLATED_NO_EDGE"))) {
      return @{$this->LIST_ISOLATED_NO_EDGE};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
  user_method array_isolated_edge {
    my $this = shift;
    if(defined($this->lookup("LIST_ISOLATED_EDGE"))) {
      return @{$this->LIST_ISOLATED_EDGE};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
  user_method array_family_fixed_vertex {
    my $this = shift;
    if(defined($this->lookup("LIST_FAMILY_FIXED_VERTEX"))) {
      return @{$this->LIST_FAMILY_FIXED_VERTEX};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
  user_method array_family_moving_vertex {
    my $this = shift;
    if(defined($this->lookup("LIST_FAMILY_MOVING_VERTEX"))) {
      return @{$this->LIST_FAMILY_MOVING_VERTEX};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
  user_method array_family_fixed_edge {
    my $this = shift;
    if(defined($this->lookup("LIST_FAMILY_FIXED_EDGE"))) {
      return @{$this->LIST_FAMILY_FIXED_EDGE};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
  user_method array_family_moving_edge {
    my $this = shift;
    if(defined($this->lookup("LIST_FAMILY_MOVING_EDGE"))) {
      return @{$this->LIST_FAMILY_MOVING_EDGE};
    }
    else {
      my @a = ();
      return @a;
    }
  }
  
}

# @category Visualization
# This visualizes a surface in R^3 and an arbitrary list of (possibly non-pure)
# WeightedComplex objects. A common bounding box is computed for all objects and a 
# random color is chosen for each object (except the surface)
user_function visualize_in_surface {
  my ($X,@p) = @_;
  
  
  
  #First determine bounding box
  my $bb = $X->boundingBox(1);
  my $xmax = $bb->row(1)->[0];
    for my $i (1 .. $bb->cols()-1) {
      if($bb->row(1)->[$i] > $xmax) {$xmax = $bb->row(1)->[$i];}
    }
    
 
#   my @minv = @{$bb->row(0)};
#   my @maxv = @{$bb->row(1)};
  for my $p ( @p) {
    my $pb = $p->boundingBox(1);
    $bb = new Matrix<Rational>($bb / $pb);
#     print "$pb\n";
#     for my $i (0 .. 2) {
#       print $pb->row(0)->[$i],",",$pb->row(1)->[$i],"\n";
#       if($pb->row(0)->[$i] < $minv[$i]) {
# 	$minv[$i] = $pb->row(0)->[$i];
#       }
#       if($pb->row(1)->[$i] > $maxv[$i]) {
# 	$maxv[$i] = $pb->row(1)->[$i];
#       }
#     }
  }
  
  $bb = compute_bounding_box($bb,0);
# 
#   print join(",",@minv),"\n";
#   print join(",",@maxv),"\n";
#   
#   my $maxvec = new Vector<Rational>(\@maxv);
#   my $minvec = new Vector<Rational>(\@minv);
#   $bb = new Matrix<Rational>($bb / $minvec);
#   $bb = new Matrix<Rational>( $bb / $maxvec);

#   print $bb,"\n";
  
  
  my @vis = ();
  @vis = (@vis, $X->BB_VISUAL(WeightLabels=>"hidden",VertexStyle=>"hidden",BoundingMode=>"absolute",BoundingBox=>$bb));
  
  
  #Then produce visuals
  for my $p (@p) {
    my $vertno = $p->VERTICES->size();
    my $r = randomInteger(255,3);
    my @ra = @{$r};
    my $color = new RGB(@ra);
    
    #Subdivide p into pure parts
    my $points = new Set<Int>();
    my $edges = new Set<Int>();
    my $cells = new Set<Int>();
    for my $mc (0 .. $p->MAXIMAL_CONES->rows()-1) {
      if($p->MAXIMAL_CONES->row($mc)->size() == 1) { $points = $points + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() == 2) { $edges = $edges + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() > 2) { $cells = $cells + $mc;}
      
    }#END iterate cells of p
    my $ppoints = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($points,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pedges = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($edges,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pcells  = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($cells,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    if($points->size() > 0) {
      @vis = (@vis, $ppoints->BB_VISUAL(VertexThickness=>2,VertexColor=>$color, BoundingMode=>"absolute",BoundingBox=>$bb));
    }
    if($edges->size() > 0) {
      @vis = (@vis,$pedges->BB_VISUAL(EdgeThickness=>2,EdgeColor=>$color,VertexStyle=>"hidden", BoundingMode=>"absolute",BoundingBox=>$bb));
    }
    if($cells->size() > 0) {
      @vis = (@vis,$pcells->BB_VISUAL(EdgeColor=>$color,EdgeThickness=>2,FacetColor=>$color, BoundingMode=>"absolute",BoundingBox=>$bb));
    }
  }#END iterate p's
  
  compose(@vis);
  
}#END visualize_in_surface


