########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains methods treating cubic surfaces in R^3 and collections of
# (families of) lines in this surface.
########################################################################

# @category Visualization
# This visualizes a surface in R^3 and an arbitrary list of (possibly non-pure)
# WeightedComplex objects. A common bounding box is computed for all objects and a 
# random color is chosen for each object (except the surface)
user_function visualize_in_surface {
  my ($X,@p) = @_;
  
  
  
  #First determine bounding box
  my $bb = $X->boundingBox(1);
  my $xmax = $bb->row(1)->[0];
    for my $i (1 .. $bb->cols()-1) {
      if($bb->row(1)->[$i] > $xmax) {$xmax = $bb->row(1)->[$i];}
    }
    
 
#   my @minv = @{$bb->row(0)};
#   my @maxv = @{$bb->row(1)};
  for my $p ( @p) {
    my $pb = $p->boundingBox(1);
    $bb = new Matrix<Rational>($bb / $pb);
#     print "$pb\n";
#     for my $i (0 .. 2) {
#       print $pb->row(0)->[$i],",",$pb->row(1)->[$i],"\n";
#       if($pb->row(0)->[$i] < $minv[$i]) {
# 	$minv[$i] = $pb->row(0)->[$i];
#       }
#       if($pb->row(1)->[$i] > $maxv[$i]) {
# 	$maxv[$i] = $pb->row(1)->[$i];
#       }
#     }
  }
  
  $bb = compute_bounding_box($bb,0);
# 
#   print join(",",@minv),"\n";
#   print join(",",@maxv),"\n";
#   
#   my $maxvec = new Vector<Rational>(\@maxv);
#   my $minvec = new Vector<Rational>(\@minv);
#   $bb = new Matrix<Rational>($bb / $minvec);
#   $bb = new Matrix<Rational>( $bb / $maxvec);

#   print $bb,"\n";
  
  
  my @vis = ();
  @vis = (@vis, $X->BB_VISUAL(WeightLabels=>"hidden",VertexStyle=>"hidden",BoundingMode=>"absolute",BoundingBox=>$bb));
  
  
  #Then produce visuals
  for my $p (@p) {
    my $vertno = $p->VERTICES->size();
    my $r = randomInteger(255,3);
    my @ra = @{$r};
    my $color = new RGB(@ra);
    
    #Subdivide p into pure parts
    my $points = new Set<Int>();
    my $edges = new Set<Int>();
    my $cells = new Set<Int>();
    for my $mc (0 .. $p->MAXIMAL_CONES->rows()-1) {
      if($p->MAXIMAL_CONES->row($mc)->size() == 1) { $points = $points + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() == 2) { $edges = $edges + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() > 2) { $cells = $cells + $mc;}
      
    }#END iterate cells of p
    my $ppoints = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($points,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pedges = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($edges,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pcells  = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($cells,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    if($points->size() > 0) {
      @vis = (@vis, $ppoints->BB_VISUAL(VertexThickness=>2,VertexColor=>$color, BoundingMode=>"absolute",BoundingBox=>$bb));
    }
    if($edges->size() > 0) {
      @vis = (@vis,$pedges->BB_VISUAL(EdgeThickness=>2,EdgeColor=>$color,VertexStyle=>"hidden", BoundingMode=>"absolute",BoundingBox=>$bb));
    }
    if($cells->size() > 0) {
      @vis = (@vis,$pcells->BB_VISUAL(EdgeColor=>$color,EdgeThickness=>2,FacetColor=>$color, BoundingMode=>"absolute",BoundingBox=>$bb));
    }
  }#END iterate p's
  
  compose(@vis);
  
}#END visualize_in_surface

# @category Enumerative geometry
# This takes a result of [[lines_in_cubic]] and returns all lines (or families) of a chosen type, represented
# by an integer:
# 0 = isolated solutions (i.e. non-families)
# 1 = non-pure families, i.e. the corresponding complex has 1- and 2-dimensional maximal cells
# 2 = pure families
# @param Int type The type as described above
# @param WeightedComplex An arbitrary list, supposedly created via [[lines_in_cubic]].
# @return WeightedComplex A list of all lines of that type
user_function lines_of_type {
  my ($type, @l) = @_;
  if($type < 0 || $type > 2) {
    die "Know only types 0,1,2";
  }
  my @result = ();
  
  for my $p (@l) {
    if($p->PURE && $p->CMPLX_DIM == 1 && $type == 0) {
      @result = (@result,$p);
    }
    if($p->PURE && $p->CMPLX_DIM == 2 && $type == 2) {
	@result = (@result,$p);
    }
    if(!$p->PURE && $type == 1) {
	@result = (@result,$p);
    }
  }
  
  return @result;  
}

