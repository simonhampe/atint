###################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file subsumes all atint extensions to the application tropical. It also includes
# a function that tests termination of all functions in a-tint.
#####################################################################

# @topic application
# a-tint is an application for polymake (see [[http://polymake.mathematik.tu-darmstadt.de]]). 
# It aims to implement algorithmic aspects of tropical intersection theory. 
# Tropical varieties are realized as weighted polyhedral complexes. This project is part of and
# financed by the DFG Priority Project SPP 1489 (see also [[http://www.computeralgebra.de/index.php]])
# For more information see [[https://bitbucket.org/hampe/atint/]]

IMPORT common graph

USE fan matroid 

#IMPORT polytope 

file_suffix atint

# A weighted complex, derived from fan::PolyhedralFan. Complexes are realized by
# using homogeneous coordinates (i.e. adding a 1 to the front of all vertices and a 0 to all rays)
# and setting USES_HOMOGENEOUS_C to true
declare object WeightedComplex : fan::PolyhedralFan<Rational>;

# An n-marked rational curve, identified by its [[SETS]], i.e. its partitions of {1,...,n}
# and its [[COEFFS]], i.e. the length of the corresponding edge
declare object RationalCurve;

# A rational function on a polyhedral complex. It is given by its [[DOMAIN]], a WeightedComplex
# and values on this domain, i.e. [[RAY_VALUES]] and [[LIN_VALUES]]
declare object RationalFunction;

# A special case of a rational function, a tropical polynomial (using either min or max)
declare object MinMaxFunction : RationalFunction;

# This represents a morphism as a "rational function to R<sup>n</sup>", i.e. it is given via its [[DOMAIN]]
# and [[RAY_VALUES]] and [[LIN_VALUES]] now lying in some R<sup>n</sup>  instead of R. The user has to take
# care that the function is locally linear, this is not checked in any way.
declare object Morphism;

INCLUDE
  WeightedComplex_properties.rules
  RationalFunction.rules
  minmaxfunction.rules
  basic_operations.rules
  specialfans.rules
  cmplx_visual.rules
  divisor.rules
  intersection.rules
  RationalCurve.rules
  RationalCurve_visual.rules
  Bergman_Rincon.rules
  Morphism.rules
  Function_visual.rules
  gfan_parse.rules
  matroid_intersection.rules
  lines_in_cubic.rules

  
## TESTRUN FUNCTION #######################


# user_function atint_testrun {
#   
#   ## FAN ##
#   
#   print "Testing application fan...\n";
#   print "Creating a homogeneous weighted polyhedral fan...";
#   my $f = new WeightedComplex(INPUT_HOM_RAYS=>[[1,0,0],[1,1,0],[0,0,1],[0,-1,-1,],[0,1,-1]],INPUT_CONES=>[[0,1],[0,2],[1,2],[0,3],[1,4]],TROPICAL_WEIGHTS=>[1,1,1,1,1]);
#   print "OK\nComputing properties...";
#   $f->USES_HOMOGENEOUS_C;
#   $f->CODIM_1_FACES;
#   $f->CODIM_1_IN_MAXIMAL_CONES;
#   $f->CMPLX_RAYS;
#   $f->CMPLX_MAXIMAL_CONES;
#   $f->CMPLX_CODIM_1_FACES;
#   $f->LATTICE_NORMALS;
#   $f->LATTICE_NORMAL_SUM;
#   $f->LATTICE_NORMAL_FCT_VECTOR;
#   $f->LATTICE_NORMAL_SUM_FCT_VECTOR;
#   $f->IS_BALANCED;
#   $f->CMPLX_DIM;
#   $f->CMPLX_AMBIENT_DIM;
#   print "OK\nHomogenizing a fan...";
#   $f->homogenize;
#   print "OK\nComputing a skeleton...";
#   skeleton_complex($f,0,FALSE);
#   print "OK\nComputing a product...";
#   product_complex($f,$f);
#   print "OK\n";
#   
#   ## TROPICAL ##
#   
#   print "Testing application tropical...\n";
#   print "Creating linear spaces...\n";
#   print "by matrix...";
#   atint::linear_space_by_matrix(new Matrix<Rational>([[1,3,4],[1,2,1],[0,0,1],[3,0,1]]));
#   print "OK\nby basis...";
#   atint::linear_space_by_basis(new Matrix<Rational>([[1,0,0],[0,1,0],[0,0,1]]));
#   print "OK\nas n-space...";
#   atint::linear_nspace(5);
#   print "OK\nCreating tropical M_0,5...";
#   tropical_m0n(5);
#   print "OK\nCreating a matroid fan...";
#   atint::bergman_fan(matroid::uniform_matroid(2,3));
#   print "OK\nCreating L^3_2..:";
#   atint::tropical_lnk(3,2);
#   print "OK\nCreating a random divisor...";
#   atint::random_minmaxdivisor(3,5,5,FALSE);
#   
#   print "OK\nCreating a MinMaxFunction...";
#   my $func = new atint::MinMaxFunction(INPUT_STRING=>"max(3x+4,x-y-z,y+z+3)");
#   print "OK\nComputing properties...";
#   $func->STANDARD_FORM;
#   $func->USES_MIN;
#   $func->DOMAIN;
#   $func->LINEAR_COEFFICIENTS;
#   $func->CONSTANT_COEFFICIENTS;
#   $func->FUNCTION_MATRIX;
#   print "OK\nComputing a refinement of R^3 along this function...";
#   atint::intersect_complete_fan(atint::linear_nspace(3)->homogenize,$func->linearityDomains);
#   print "OK\nComputing its divisor on L^3,2...";
#   atint::divisorByPLF(tropical_lnk(3,2),$func);
#   print "OK\nComputing a divisor by values...";
#   atint::divisorByValue($f,2,2,3,3,5,6);
#   print "OK\nComputing an intersection product of cycles...";
#   atint::cycle_intersection($f,tropical_lnk(2,1));
#   print "OK\n";
#   print "Done.\n";
#   
#   
# }