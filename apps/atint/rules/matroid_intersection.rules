########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains methods for computing intersection products in (certain) matroid fans
########################################################################


# @category Intersection products
# Computes the intersection product of two cycles living in the bergman fan B(U_n,k) (given in max-coordinates)
# @param WeightedComplex X A cycle in B(U_n,k)
# @param WeightedComplex Y A cycle in B(U_n,k)
# @param Int k The dimension k of the ambient U_n,k
# @param Bool verbose Optional. Whether some progress information should be printed
# @return WeightedComplex The intersection product of X and Y in B(U_n,k)
user_function intersect_in_unk {
  my ($X,$Y,$k, $verbose) = @_;
  my $n = $X->CMPLX_AMBIENT_DIM;
  
  if(!(defined($verbose))) {
    $verbose = FALSE;
  }
  
  #Computing diagonal functions
  if($verbose eq TRUE) {
    print "Computing diagonal functions\n";
  }
  my @diag = diagonal_unk($n,$k);
  
  return intersect_by_diagonal($X,$Y,FALSE,$verbose,@diag);
 
}

# @category Intersection products
# # Computes the intersection product of two cycles living in L^n_k 
# @param WeightedComplex X A cycle in L^n_k 
# @param WeightedComplex Y A cycle in L^n_k 
# @param Int k The dimension k of the ambient L^n_k 
# @param Bool verbose Optional. Whether some progress information should be printed
# @return WeightedComplex The intersection product of X and Y in B(U_n,k)
user_function intersect_in_lnk {
  my ($X,$Y,$k, $verbose) = @_;
  
  my $n = $X->CMPLX_AMBIENT_DIM+1;
  
  #Computing diagonal functions
  if($verbose eq TRUE) {
    print "Computing diagonal functions\n";
  }
  my @diagonals = diagonal_unk($n,$k+1);
  
  return intersect_by_diagonal($X,$Y,TRUE,$verbose,@diagonals);
}

# @category Intersection products
# Computes an intersection product of two tropical cycles by using a prescribed list of rational functions
# cutting out the diagonal
# @param WeightedComplex X A tropical cycle
# @param WeightedComplex Y A tropical cycle living in the same ambient space
# @param Bool liftLineality Whether both cycles have to be lifted into an ambient space of one dimension higher. If true, this will be done by adding a zero at the end of RAYS and LINEALITY_SPACE and adding the LINEALITY generator (1,..,1). After computation, this additional coordinate will be stripped 
# @param Bool Verbose Whether some progress information should be printed
# @param RationalFunction A list of rational functions cutting out the diagonal. These will be applied to the 
# cartesian product X x Y
# @return WeightedComplex The intersection product defined via the diagonal functions
user_function intersect_by_diagonal {
  my ($X,$Y,$liftLineality, $verbose,@diag) = @_;
  
  if(!(defined($verbose))) {
    $verbose = FALSE;
  }
    
  #Lift varieties
  if($liftLineality eq TRUE) {
    if($verbose eq TRUE) {
      print "Lifting varieties \n";
    }
    
    $X = lift_variety($X);
  
    $Y = lift_variety($Y);
    
  }# END lift varieties
  
  if($verbose eq TRUE) {
    print "Done. Computing product\n";
  }
  
  my $prod = product_complex($X,$Y);
  
  for(my $i = 0; $i < scalar(@diag); $i++) {
    if($verbose eq TRUE) {
      print "Intersecting with diagonal function ", ($i+1), " of ", scalar(@diag),"\n";
    }
    $prod = divisor($prod, $diag[$i]);
  }
  
  if($verbose eq TRUE) {
    print "Done. Projecting...\n";
  }
  
  my $homog = $X->USES_HOMOGENEOUS_C || $Y->USES_HOMOGENEOUS_C;
  my $Xproj = $X->CMPLX_AMBIENT_DIM + ($homog? 1 : 0);
  
  my $result_rays = $prod->RAYS->minor(All, sequence(0, $Xproj));
  my $result_lin = $prod->LINEALITY_SPACE->minor(All, sequence(0,$Xproj));
  
  my $result = new WeightedComplex(RAYS=>$result_rays, MAXIMAL_CONES=>$prod->MAXIMAL_CONES,
				   LINEALITY_SPACE=>$result_lin,TROPICAL_WEIGHTS=>$prod->TROPICAL_WEIGHTS, USES_HOMOGENEOUS_C=>TRUE); 
  
  if($liftLineality) {
    if($verbose eq TRUE) {
      print "Reversing lift.\n";
    }
    $result = project_variety($result);
  }
  
  return $result;
  
}