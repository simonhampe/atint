########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains methods for computing intersection products in (certain) matroid fans
########################################################################


# @category Intersection products
# Computes the intersection product of two cycles living in the bergman fan B(U_n,k) (given in max-coordinates)
# @param WeightedComplex X A cycle in B(U_n,k)
# @param WeightedComplex Y A cycle in B(U_n,k)
# @param Int k The dimension k of the ambient U_n,k
# @param Bool verbose Optional. Whether some progress information should be printed
# @return WeightedComplex The intersection product of X and Y in B(U_n,k)
user_function intersect_in_unk {
  my ($X,$Y,$k, $verbose) = @_;
  my $n = $X->CMPLX_AMBIENT_DIM;
  
  if(!(defined($verbose))) {
    $verbose = FALSE;
  }
  
  #Computing diagonal functions
  if($verbose eq TRUE) {
    print "Computing diagonal functions\n";
  }
  
  my @diag = diagonal_unk($n,$k);
  
  if($verbose eq TRUE) {
    print "Done. Computing product\n";
  }
  
  my $prod = product_complex($X,$Y);
  
  for(my $i = 0; $i < scalar(@diag); $i++) {
    if($verbose eq TRUE) {
      print "Intersecting with diagonal function ", ($i+1), " of ", scalar(@diag),"\n";
    }
    $prod = divisor($prod, $diag[$i]);
  }
  
  if($verbose eq TRUE) {
    print "Done. Projecting...\n";
  }
  
  my $result_rays = $prod->RAYS->minor(All, sequence(0, $n+1));
  my $result_lin = $prod->LINEALITY_SPACE->minor(All, sequence(0,$n+1));
  
  return new WeightedComplex(RAYS=>$result_rays, MAXIMAL_CONES=>$prod->MAXIMAL_CONES, LINEALITY_SPACE=>$result_lin,
			     TROPICAL_WEIGHTS=>$prod->TROPICAL_WEIGHTS, USES_HOMOGENEOUS_C=>TRUE); 
}

# @category Intersection products
# # Computes the intersection product of two cycles living in L^n_k 
# @param WeightedComplex X A cycle in L^n_k 
# @param WeightedComplex Y A cycle in L^n_k 
# @param Int k The dimension k of the ambient L^n_k 
# @param Bool verbose Optional. Whether some progress information should be printed
# @return WeightedComplex The intersection product of X and Y in B(U_n,k)
user_function intersect_in_lnk {
  my ($X,$Y,$k, $verbose) = @_;
  
  if(!(defined($verbose))) {
    $verbose = FALSE;
  }
    
  #Lift varieties
  if($verbose eq TRUE) {
    print "Lifting varieties to U_(n+1),(k+1)\n";
  }
  
  my $Xlift = new WeightedComplex(RAYS=>($X->RAYS | zero_vector<Rational>($X->RAYS->rows())),
				  MAXIMAL_CONES=>$X->MAXIMAL_CONES,
				  LINEALITY_SPACE=>( ($X->LINEALITY_SPACE | zero_vector<Rational>($X->LINEALITY_SPACE->rows())) / ones_vector<Rational>($X->LINEALITY_SPACE->cols()+1)),
				  TROPICAL_WEIGHTS=>$X->TROPICAL_WEIGHTS,
				  USES_HOMOGENEOUS_C=>$X->USES_HOMOGENEOUS_C);
  
  my $Ylift = new WeightedComplex(RAYS=>($Y->RAYS | zero_vector<Rational>($Y->RAYS->rows())),
				  MAXIMAL_CONES=>$Y->MAXIMAL_CONES,
				  LINEALITY_SPACE=>( ($Y->LINEALITY_SPACE | zero_vector<Rational>($Y->LINEALITY_SPACE->rows())) / ones_vector<Rational>($Y->LINEALITY_SPACE->cols()+1)),
				  TROPICAL_WEIGHTS=>$Y->TROPICAL_WEIGHTS,
				  USES_HOMOGENEOUS_C=>$Y->USES_HOMOGENEOUS_C);
  #Compute intersection product
  
  my $result = intersect_in_unk($Xlift, $Ylift, $k+1, $verbose);
  
  #Project
  
  if($verbose eq TRUE) {
    print "Projecting result back to L^n_k\n";
  }
  
  my $result_rays = $result->RAYS->minor(All,sequence(0,$result->RAYS->cols()-1));
  my $result_lin = $result->LINEALITY_SPACE->minor(All,sequence(0,$result->LINEALITY_SPACE->cols()-1));
  return new WeightedComplex(RAYS=>$result_rays, MAXIMAL_CONES=>$result->MAXIMAL_CONES,
			     LINEALITY_SPACE=>$result_lin,TROPICAL_WEIGHTS=>$result->TROPICAL_WEIGHTS,
			     USES_HOMOGENEOUS_C=>TRUE);
}

# @category Intersection products
# Computes an intersection product of two tropical cycles by using a prescribed list of rational functions
# cutting out the diagonal
# @param WeightedComplex X A tropical cycle
# @param WeightedComplex Y A tropical cycle living in the same ambient space
# @param Bool embedLineality Whether both cycles have to be embedded into an ambient space of one dimension higher. If true, this will be done by adding a zero at the end of RAYS and LINEALITY_SPACE and adding the LINEALITY generator (1,..,1). After computation, this additional coordinate will be stripped 
# @param Bool Verbose
# user_function intersect_by_diagonal {
#   
# }