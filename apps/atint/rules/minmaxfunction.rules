#######################################################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file creates a data type for a certain type of piecewise linear functions on R^n. 
# Every such function is supposed to be 
# of the form max(f_1,..,f_k) or min(f_1,...,f_k), where each f_i is an affine linear function from R^n to R.
# Such a function can be created in the following ways:
# 1) Specifying [[INPUT_STRING]] and (optionally) [[INPUT_VARS]]. [[INPUT_STRING]] is a string representing the
# function (the syntax is specified in the documentation of this property). [[INPUT_VARS]] is an array of strings representing
# the variables. If this is not given, the variables (and hence the domain of the function) are automatically detected.
#
# 2) Directly specifying the linear coefficient matrix [[LINEAR_COEFFICIENTS]] and the [[CONSTANT_COEFFICIENTS]], together
# with [[USES_MIN]] (This is optional, if you don't specify it, FALSE is the default value)
########################################################################################################

object MinMaxFunction {
  
  ## PROPERTIES ###################################################################################################
  
  # @category Basic properties
  # The syntax for STRING in pseudo-regex is the following (after deleting any whitespace): 
  # "(min|max)\((SUM)+(,SUM)*\)"
  # where SUM = "(TERM)+([\+\-](TERM))*"
  # where TERM = (RAT)|(RAT[:alpha:][^\+,\)]*)
  # where RAT is any string that can be parsed to a polymake Rational and does not contain any letters.
  # To make this more comprehensible: STRING takes anything of the form min(...) or max(...), 
  # where ... is a comma-separated list of strings of the form a + bx + cy + ... , where a,b,c are rational 
  # numbers and x,y are variables. Any string that starts with a letter and does not contain "+" or "," can be 
  # a variable. Such a sum can contain several such terms for the same variable and they need not be in any order.
  # A term can be of the form "3x", "3*x", but "x3" will be interpreted as 1 * "x3". Coefficients should not contain letters,
  # i.e. 3E10*x would be interpreted as 3 * "E10*x". Empty terms are allowed.
  # If no INPUT_VARS are given, MinMaxFunction will recognize the dimension of the domain from the number of variables and will
  # assign the variables to the standard basis vectors by sorting them alphabetically. 
  # E.g. INPUT_STRING=>"min(x+2z,3+z)",INPUT_VARS=>["x","y","z"] is a different function than INPUT_STRING=>"min(x+2z,3+z)",
  # since the second is the function f:R² -> R, (a,b) -> min(a+2b,3+b) and the first is f: R³->R, (a,b,c)->min(a+2c,3+c)
  # If however, [[INPUT_VARS]] is given, the parse will *ignore* any terms containing variables that are not 
  # defined in [[INPUT_VARS]]. The variables will be assigned to the standard basis vectors in order of their
  # appearance in [[INPUT_VARS]].
  # E.g. INPUT_STRING=>"min(x+2c,3+x)",INPUT_VARS=>["x","y"] will give the function f:R²->R, (a,b) -> min(a,3+a)
  # Note that ANY whitespace in [[INPUT_STRING]] is ignore, as well as any brackets '(',')' besides the ones enclosing
  # the function list.
  property INPUT_STRING : String;
  
  # @category Basic properties
  # A list of strings that are variables. Any string that starts with a letter (i.e. [a-zA-Z]) and does not contain
  # '+' or ',' can be a variable. Illegal variable names will not cause an error, but the parser will not detect them
  # in [[INPUT_STRING]], so their coefficients will be 0. If you assign a value to this, only terms with variables in 
  # this array will be parsed. Note that ANY whitespace in a variable name will be ignored. The i-th element of this array
  # will be assigned to the i-th standard basis vector.
  property INPUT_VARS : Array<String>;
  
  # @category Basic properties
  # This will give a nice string representation of the function, where all variables are of the form 'x_i',
  # i = 1,..,[[DOMAIN]]. There are no redundancies and terms are sorted in ascending alphabetic order of their variable,
  # with the constant term at the end
  property STANDARD_FORM : String;
  
  # @category Basic properties
  # Indicates whether this function uses min (TRUE) or max (FALSE). The default (if you directly give a coefficient matrix,
  # but not this value) is FALSE
  property USES_MIN : Bool;
  
  # @category Basic properties
  # The dimension n of the domain R^n of the function. Is equal to the columns of [[LINEAR_COEFFICIENTS]]
  property DOMAIN : Int;
  
  # @category Basic properties
  # A matrix of the linear coefficients of the functions. Each row corresponds to a linear function within
  # the min or max and the entry in column j is the coefficient of variable x_j
  property LINEAR_COEFFICIENTS : Matrix<Rational>;
  
  # @category Basic properties
  # A vector of the constant coefficients of the function. The i-th entry is the constant term of the function 
  # represented by the i-th row of [[LINEAR_COEFFICIENTS]].
  property CONSTANT_COEFFICIENTS : Vector<Rational>;
  
  # @category Basic properties
  # This is simply the concatenation of [[LINEAR_COEFFICIENTS]] and [[CONSTANT_COEFFICIENTS]]
  property FUNCTION_MATRIX : Matrix<Rational>;
  
  # @category Tropical geometry
  # This computes the (homogenized version of the) domains of linearity of the function. More precisely, it computes the 
  # normal fan of the polytope defined by this function in the following way:
  # If the positive form reads max(a_i*x + c_i,i=1,..,k) with a_i in Q^n and c_i in Q, then the polytope is
  # conv( (c_i,a_i) ) in Q^{n+1} (in homog. coordinates its actually in n+2 coordinates).
  # If you want to refine a tropical variety along these domains, you have to do the following: If the variety is already
  # in homogeneous coordinates, simply call intersect_complete_fan(variety, linearityDomains). Otherwise you have to 
  # homogenize the variety (call method homogenize on the variety) and intersect then.
  # If the function uses min, the coefficients are multiplied by -1 before computing the polytope. Note that, since
  # min(f_i) = - max (-f_i), this doesn't change the domain of linearity.
  property LINEARITY_DOMAINS : fan::PolyhedralFan;
  
  ## RULES ###################################################################################################
  
  rule USES_MIN, LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS : INPUT_STRING {
      #Make a copy of [[INPUT_STRING]] for parsing
      my $string = $this->INPUT_STRING;
      $string =~ s/\s+//g; #Remove any whitespace before parsing
      
      #If [[INPUT_VARIABLES]] exists, make a copy and remove whitespace
      my $vars = $this->lookup("INPUT_VARS");
      my @vararray;
      if(defined($vars)) {
	@vararray = @{$vars};
	if(scalar(@vararray) == 0) {
	  die "Error: Domain dimension must be at least 1";
	}
	for my $v (@vararray) {
	  $v =~ s/\s+//g;
	}
      }
            
      #First separate min/max from the list of the functions (without brackets)
      my @separator = ($string =~ /^(max|min)\((.+)\)$/i);
      if(scalar(@separator) == 2) {
	
	my $minmax = $separator[0];
	#Remove any brackets from the function list
	$separator[1] =~ s/[\(\)]+//g;
	my @functionlist = split(/,/,$separator[1]);
	
	#Determine wheter function uses min or max
	if($minmax =~ /^min$/i) {
	  $this->USES_MIN = TRUE;
	}
	else {
	  $this->USES_MIN = FALSE;
	}
	
	# These maps are used to store the coefficients of the functions. The i-th element corresponds to the i-th function.
	# It is a reference to a hash mapping variable names to coefficients
	my @lincoeff = ();
	
	#In this array we store the constant coefficient of each function.
	my @constants = ();
	
	#Now parse every single function by splitting at "+"
	for my $index (0 .. scalar(@functionlist)-1) {
	  # Initialize coefficient (maps) 
	  my %functionCoeffMap = ();
	  
	  $constants[$index] = 0;
	  
	  my @termlist = split(/[\+\-]+/,$functionlist[$index]); #We split along any consecutive sequence of + and -
	  #Now extract the signs of the terms
	  my @signlist = ($functionlist[$index] =~ /[\+\-]+/g);
	  
	  
	  #If the first terms empty that means there are signs before the actual first term
	  if($termlist[0] eq "") {
	    shift(@termlist);
	  }
	  #If not then we don't have a sign for the first term and add it
	  else {
	    @signlist = ("+",@signlist);
	  }
	  #If the last term is empty that means there is an empty term at the end. Hence we also forget the corr. signs
	  if($termlist[scalar(@termlist)-1] eq "") {
	    pop(@termlist);
	    pop(@signlist);
	  }
	  #Now every element in signlist corresponds to a term. We count the number of -'s to determine the actual
	  # sign of the term
	  for my $index (0 .. scalar(@termlist)) {
	    my $minussigns = scalar(($signlist[$index] =~ tr/\-//));
	    if ($minussigns % 2) { #If the number of -'s is odd, set sign to -
	      $termlist[$index] = "-" . $termlist[$index];
	    }
	  }
	  
	  #Parse every single term
	  for my $term (@termlist) {
	      my @termsep = ($term =~ /^(\-?[^a-zA-Z\*]*)?\*?([a-zA-Z]+.*)?$/);
	      if(scalar(@termsep) != 2) {
		die "Invalid term: ", $term, " divided into ", join(",",@termsep),"\n";
	      }
	      
	      #If both parts are empty, go to the next term
	      if($termsep[0] eq "" && $termsep[1] eq "") {
		next;
	      }
	      
	      #Parse the coefficient (if there is no coefficient, set it to 1)
	      my $coefficient = new Rational($termsep[0] eq ""? 1 : 
					    ($termsep[0] eq "-"? -1: $termsep[0]));
	      
	      #If there is no variable, add up the constant coefficient, otherwise add up the corr. linear coefficient
	      if($termsep[1] eq "") {
		$constants[$index] += $coefficient;
	      }
	      else {
		#Add the variable, if there are no [[INPUT_VARS]] (at this point we don't care about doubles)
		if(!defined($vars)) {
		  @vararray = (@vararray,$termsep[1]);
		}
		#If there is no coefficient value for the variable yet, set it to coefficient, otherwise add the coefficient
		if(!defined($functionCoeffMap{$termsep[1]})) {
		  $functionCoeffMap{$termsep[1]} = $coefficient;
		}
		else {
		  $functionCoeffMap{$termsep[1]} += $coefficient;
		}
	      }
	      
	  }#end parse all terms
	  
	  $lincoeff[$index] = \%functionCoeffMap;
	}#end parse all functions
	
	#Copy constant coefficients
	$this->CONSTANT_COEFFICIENTS = new Vector<Rational>(\@constants);
	
	#If [[INPUT_VARS]] is not given, remove double variables and sort them alphabetically
	if(!defined($vars)) {
	  if(scalar(@vararray) > 1) {@vararray = sort(@{new Set<String>(@vararray)});} #Breaks if there is only one variable
	  if(scalar(@vararray) == 0) {
	    die "Error: Domain dimension must be at least 1";
	  }
	}
	
	#Now copy the linear coefficients
	my $m = new Matrix<Rational>(0, scalar(@vararray));
	#Go through all functions
	for my $index (0 .. scalar(@functionlist)-1) {
	    my $hashref = $lincoeff[$index];
	    my %h = %$hashref;
	    my @row = ();
	    #Go through all variables
	    for my $v (@vararray) {
	      @row = (@row,(defined($h{$v})? $h{$v} : 0));
	    }
	    $m = $m / new Vector<Rational>(\@row);
	}
	$this->LINEAR_COEFFICIENTS = $m;
	
      } #endif check basic form
      else {
	die "Invalid syntax for piecewise linear function.";
      }
  }#End rule LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS, USES_MIN
  weight 0.1;
  
  rule CONSTANT_COEFFICIENTS, LINEAR_COEFFICIENTS : FUNCTION_MATRIX {
    $this->CONSTANT_COEFFICIENTS = $this->FUNCTION_MATRIX->col($this->FUNCTION_MATRIX->cols()-1);
    $this->LINEAR_COEFFICIENTS = $this->FUNCTION_MATRIX->minor(All, ~scalar2set($this->FUNCTION_MATRIX->cols()-1));
  }
  weight 0.2;
  
  rule DOMAIN : LINEAR_COEFFICIENTS {
    $this->DOMAIN = $this->LINEAR_COEFFICIENTS->cols();
  }
  
  rule FUNCTION_MATRIX : LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS {
    $this->FUNCTION_MATRIX = $this->LINEAR_COEFFICIENTS | $this->CONSTANT_COEFFICIENTS;
  }
  
  rule STANDARD_FORM : LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS, USES_MIN {
      #Create a comma-separated list of all functions
      my $functionList = "";
      for my $row (0 .. $this->LINEAR_COEFFICIENTS->rows() -1) {
	#Start with ", ", if this is not the first element
	if($row != 0) {
	  $functionList .= ", ";
	}
	#Now create the function
	my $function = "";
	my $firsttermfound = 0;
	for my $term (1 .. $this->LINEAR_COEFFICIENTS->cols()+1) {
	  my $coeff = ($term > $this->LINEAR_COEFFICIENTS->cols() ? 
		      $this->CONSTANT_COEFFICIENTS->[$row] :
		      $this->LINEAR_COEFFICIENTS->($row,$term-1));
	  if($coeff == 0) {
	    next;
	  }
	  else {
	    #First insert appropriate sign, then coefficient (without sign), then *variable
	    $function .= ($firsttermfound? ($coeff > 0? " +" : " -") : ($coeff > 0? "" : " -"));
	    $function .= abs($coeff);
	    $function .= ($term > $this->LINEAR_COEFFICIENTS->cols() ? "" : "*x_$term");
	    $firsttermfound = 1;
	  }
	}
	#If all coefficients are 0, insert "0"
	if($firsttermfound == 0) {
	  $function = "0";
	}
	#Append function
	$functionList .= $function
      }
      
      #Now put all this in min(..) or max(...)
      $this->STANDARD_FORM = $this->USES_MIN? "min($functionList)" : "max($functionList)";
  }
  
  rule LINEARITY_DOMAINS : LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS, USES_MIN {
    #The constant coefficients correspond to the homogenizing coordinate in a tropical variety, so we place it at the front
    my $pointmatrix = $this->CONSTANT_COEFFICIENTS | $this->LINEAR_COEFFICIENTS;
    if(!($this->USES_MIN)) {
      $pointmatrix = - $pointmatrix;
    }
    
    #For representing the polytope properly, we have to homogenize the coordinates again by adding a 1 at the front
    my @ones = ();
    for my $c (0 .. $pointmatrix->rows() -1) { @ones = (@ones,1);}
    $pointmatrix = (new Vector<Rational>(\@ones)) | $pointmatrix;
    
    my $newt = new polytope::Polytope<Rational>(POINTS=>$pointmatrix);
    $this->LINEARITY_DOMAINS = fan::normal_fan($newt);
  }
  
  ## METHODS #################################################################################################
  
#---- We don't need this to compute the domain of linearity ----
#   # @category Tropical geometry
#   # This computes another MinMaxFunction from this one in the following way:  
#   # * If the function uses min, the new function uses max and the coefficients are multiplied by -1
#   # * It multiplies all coefficients with the same minimal natural number n, such that all coefficients become integer
#   # * For each negative coefficient, it adds 1 to each entry in the corresponding column until all entries are nonnegative
#   # This function then has only natural numbers as coefficients and the same domain of linearity as the original function.
#   user_method positiveForm {
#     my $this = shift;  
#     #Copy coefficients into a single matrix
#     my $m = $this->FUNCTION_MATRIX;
#     
#     #Convert from min to max, if necessary
#     if($this->USES_MIN) {
#       $m = -$m;
#     }
#     
#     #Determine lcm of denominators
#     my $lc = 1;
#     for my $row (0 .. $m->rows() -1) {
#       for my $col (0 .. $m->cols() -1) {
# 	if($m->($row,$col) != 0) {
# 	  $lc *= denominator($m->($row,$col));
# 	}
#       }
#     }
#     #Now make the matrix integer
#     $m = $m * abs($lc);
#     
#     #Now make each column nonnegative and copy the result into the final matrix
#     my $finalmatrix = new Matrix<Rational>($m->rows(),0);
#     for my $col (0 .. $m->cols() -1) {
#       my @colarray = @{$m->col($col)};
#       my $cmin = (sort {$a <=> $b} @colarray)[0];
#       if($cmin < 0) {
# 	for my $entry (@colarray) { $entry += -$cmin;}
#       }
#       $finalmatrix = $finalmatrix | new Vector<Rational>(\@colarray);
#     }
#     
#     #Return result
#     return new MinMaxFunction(LINEAR_COEFFICIENTS=>$finalmatrix->minor(All,[0 .. $finalmatrix->cols()-2]),								CONSTANT_COEFFICIENTS=>$finalmatrix->col($finalmatrix->cols()-1),USES_MIN=>FALSE);
#   }
  
  # @category Tropical geometry
  # This computes the (homogenized version of the) domains of linearity of the function. More precisely, it computes the 
  # normal fan of the polytope defined by this function in the following way:
  # If the positive form reads max(a_i*x + c_i,i=1,..,k) with a_i in Q^n and c_i in Q, then the polytope is
  # conv( (c_i,a_i) ) in Q^{n+1} (in homog. coordinates its actually in n+2 coordinates).
  # If you want to refine a tropical variety along these domains, you have to do the following: If the variety is already
  # in homogeneous coordinates, simply call intersect_complete_fan(variety, linearityDomains). Otherwise you have to 
  # homogenize the variety (call method homogenize on the variety) and intersect then.
  # If the function uses min, the coefficients are multiplied by -1 before computing the polytope. Note that, since
  # min(f_i) = - max (-f_i), this doesn't change the domain of linearity.
  user_method linearityDomains {
    my $this = shift;
    
    #The constant coefficients correspond to the homogenizing coordinate in a tropical variety, so we place it at the front
    my $pointmatrix = $this->CONSTANT_COEFFICIENTS | $this->LINEAR_COEFFICIENTS;
    if(!($this->USES_MIN)) {
      $pointmatrix = - $pointmatrix;
    }
    
    #For representing the polytope properly, we have to homogenize the coordinates again by adding a 1 at the front
    my @ones = ();
    for my $c (0 .. $pointmatrix->rows() -1) { @ones = (@ones,1);}
    $pointmatrix = (new Vector<Rational>(\@ones)) | $pointmatrix;
    
    my $newt = new polytope::Polytope<Rational>(POINTS=>$pointmatrix);
    return fan::normal_fan($newt);
  }
  
  # @category Tropical geometry
  # Computes the value of this function at a given point. If the point has dimension DOMAIN, it simply computes the value. 
  # If it has dimension DOMAIN +1, it assumes the point is given in homogeneous coordinates (i.e. the first coordinate should be one or zero, 
  # this is not checked, however) and computes the function value of the last DOMAIN coordinates.
  # @return Rational The function value at the given point.
  user_method valueAt  {
    my $this = shift;
    my $p = shift;
    #If it seems to be in homog. coordinates, slice the first coordinate away
    if($p->dim() == $this->DOMAIN+1) {
      $p = $p->slice([1 .. $p->dim()-1]);
    }
    #Add a 1 at the end of $p for the constant coefficient
    $p = $p | 1;
    #In any case $p should now have dimension [[DOMAIN]]+1
    if($p->dim() != $this->DOMAIN+1) {
      die "Error computing function value: Dimension mismatch.";
    }
    
    #Compute the function value
    my $m = $this->FUNCTION_MATRIX;
    my $v = $m * $p;
    return new Rational($this->USES_MIN? (sort { $a <=> $b} @{$v})[0] : 
					 (sort { $b <=> $a} @{$v})[0]);
    
  }  
}

## FUNCTIONS ###################################################################################################
  
  # @category Tropical geometry
  # Produces the rational functions that cut out the diagonal of the vector space R^n.
  # @param Int n Them dimension of the vector space (and the number of functions)
  # @return MinMaxFunction A list of the functions (max(x_n,y_n),...,max(x_1,y_1)), where x_i is the coordinate function in the first part of the cartesian product R^n x R^n and y_i is the coordinate function of the second half.
  user_function diagonal_functions {
    my $n = shift;
    my @result = ();
    for(my $i = 0; $i < $n; $i++) {
      my $fmatrix = new Matrix<Rational>(0,(2*$n) + 1);
	$fmatrix = $fmatrix / new Vector<Rational>(unit_vector<Rational>(2*$n+1,$i));
	$fmatrix = $fmatrix / new Vector<Rational>(unit_vector<Rational>(2*$n+1,$i+$n));
      @result = (new MinMaxFunction(FUNCTION_MATRIX=>$fmatrix,USES_MIN=>FALSE),@result);
    }
    return @result;
  }