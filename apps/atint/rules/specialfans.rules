########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file provides convenience methods for creation of special tropical varieties
########################################################################

# @category Tropical geometry
# Creates a tropical variety consisting of a single linear space defined by a matrix and assigns it a given weight.
# @param Matrix<Rational> rowspace A matrix whose rows span the lineality space of the fan (hence the whole fan).
# If you already know that your rows are a basis, call linear_space_by_basis instead.
# @param int weight The weight of the linear space (1, if none is given)
# @return WeightedComplex The resulting fan object in non-homog. coordinates
user_function linear_space_by_matrix {
  my ($matrix,$weight) = @_;
  
  $matrix = $matrix->minor(basis_rows($matrix),All);
  
  if(!defined($weight)) {
      $weight = 1;
  }
  my @weightarray = ($weight);
  
  return new WeightedComplex(LINEALITY_SPACE=>$matrix,TROPICAL_WEIGHTS=>\@weightarray);
  
}

# @category Tropical geometry
# Creates a tropical variety consisting of a single linear space defined by a matrix and assigns it a given weight.
# @param Matrix<Rational> rowspace A matrix whose rows span the lineality space of the fan (hence the whole fan) and
# which are assumed to be linearly independent. If you are not sure of this, call linear_space_by_matrix instead.
# @param int weight The weight of the linear space (1, if none is given)
# @return WeightedComplex The resulting fan object in non-homog. coordinates
user_function linear_space_by_basis {
  my ($matrix,$weight) = @_;
  
  if(!defined($weight)) {
      $weight = 1;
  }
  my @weightarray = ($weight);
  
  return new WeightedComplex(LINEALITY_SPACE=>$matrix,TROPICAL_WEIGHTS=>\@weightarray);
}

# @category Tropical geometry
# Creates the tropical variety R^n as a single lineality space with a given weight 
# @param int n The dimension of the linear space
# @param int weight The weight of the linear space (1, if none is given)
# @return WeightedComplex The resulting fan object in non-homog. coordinates
user_function linear_nspace {
  my ($n,$weight) = @_;
  
  if(!defined($weight)) {
      $weight = 1;
  }
  my @weightarray = ($weight);
  
  my $m = new Matrix<Rational>(unit_matrix($n));
  
  return new WeightedComplex(
    LINEALITY_SPACE=> $m,
    TROPICAL_WEIGHTS=>\@weightarray,IS_UNIMODULAR=>TRUE); 
}


# @category Tropical geometry
# Creates the moduli space of rational n-marked abstract tropical curves M_{0,n} as the bergman
# fan of the complete graph on n-1 nodes modulo lineality space.
# @param Int n The number of marks on the curves
# @param Bool preserveLineality By default set to false. If true, the function returns Mn with an additional lineality space <(1,...,1)>
# user_function tropical_mn {
#   my ($n,$preserve) = @_;
#   
#   $preserve = 0 unless defined($preserve);
#   
#   #Create the matroid of the complete graph on n-1 nodes 
#   my @bases = graph::spanning_complete($n-1);
#   my $edges = ($n-1) * ($n-2) / 2;
#   my $matroid = new matroid::Matroid(N_ELEMENTS=>$edges,BASES=>\@bases);
#   return bergman_fan($matroid,!$preserve);
# }

# @category Tropical geometry
# Creates the bergman fan of a given matroid fan.
# @param matroid::Matroid m A matroid
# @param Bool modOutLineality Optional argument. If set to TRUE, the lineality space is divided out before returning the 
# fan. The next parameter specifies the exact modalities of the division. By default, this parameter is set to FALSE
# @param int projectionCoordinate Optional argument. An integer in {0,..,n-1}, where n is the number of elements of the matroid. If modOutLineality is set to TRUE, the standard basis vector with index projectionCoordinate is mapped to minus the sum of the remaining standard basis vectors to mod out the lineality space. By default, this is the last coordinate n-1.
# @return The bergman fan of the given matroid in non-homog. coordinates
user_function bergman_fan {
  my ($matroid, $modOutLineality, $projectionCoordinate) = @_;
  
  #Set default values if necessary
  $modOutLineality = FALSE unless defined($modOutLineality);
  $projectionCoordinate = $matroid->N_ELEMENTS -1 unless defined($projectionCoordinate);
  
  #Get matroid polytope and make it a fan to compute the n-rank-skeleton
  my $poly = $matroid->POLYTOPE;
    my $ambient_dim = $poly->AMBIENT_DIM;
    my $raymatrix = $poly->VERTICES;
    my @cones = (sequence(0,$raymatrix->rows()));
  my $polyfan = new WeightedComplex(RAYS=>$raymatrix,MAXIMAL_CONES=>\@cones,USES_HOMOGENEOUS_C=>TRUE);
  my $skeleton = skeleton_complex( $polyfan, $ambient_dim - $matroid->RANK,TRUE);
  
  return computeBergmanFan($skeleton, $poly,$modOutLineality eq TRUE? 1 : 0, $projectionCoordinate);
}

# @category Tropical geometry
# Creates a divisor of a random MinMaxFunction (in n-space) with integer coefficients.
# By default this uses maximum for the function. It returns an array containing the function created and its
# divisor in n-space.
# @param int ambient_dim The ambient dimension of the divisor
# @param int equations The number of equations to use
# @param int upperCoeffBound The upper bound  of the coefficients (All coefficients are positive)
# @param Bool onlyFunction If true, only the random function is returned and the divisor is not computed. FALSE by default.
# @return MinMaxFunction if onlyFunction is TRUE, otherwise an array containing first the function, then the divisor
user_function random_minmaxdivisor {
  my ($ambient_dim, $equations, $upperCoeffBound, $onlyFunction) = @_;
  $upperCoeffBound = new Integer($upperCoeffBound);
  
  $onlyFunction = 0 unless defined($onlyFunction);
  
  # Create function matrix
  my $m = new Matrix<Rational>(0,$ambient_dim+1);
  for(my $i = 0; $i < $equations; $i++) {
    my @r = randomInteger($upperCoeffBound,$ambient_dim+1);
    $m = new Matrix<Rational>($m / new Vector<Rational>(@r));
  }
  
  if($onlyFunction eq TRUE) {
    $onlyFunction = 1;
  }
  else {
    $onlyFunction = 0;
  }
  
  my $f = new MinMaxFunction(FUNCTION_MATRIX=>$m,USES_MIN=>0);
  if(!$onlyFunction) {
    my $div = divisor_minmax(linear_nspace($ambient_dim),$f);
    return ($f,$div);
  }
  else {
    return $f;
  }
}

# @category Tropical geometry
# Returns the zero cycle, i.e. a weighted complex with no rays and cones
user_function zero_cycle {
  my $w = new WeightedComplex(RAYS=>[],MAXIMAL_CONES=>[],TROPICAL_WEIGHTS=>[]);
  $w->description = "zero cycle";
  return $w;
}

# @category Tropical geometry
# Checks whether a cycle is the 0 cycle
# @param WeightedComplex c
# @return Bool
user_function is_zerocycle {
  my $wc = shift;
  if($wc->CMPLX_AMBIENT_DIM == 0) {
    return new Bool(TRUE);
  }
  if($wc->MAXIMAL_CONES->rows() > 0) {
    return new Bool(FALSE);
  }
  return new Bool(TRUE);
}

# #EXPERIMENTAL
# user_function analyse_flats {
#   my ($m,$r) = @_;
#   for(my $i = 0; $i < $r->rows(); $i++) {
#     my $s = new Set<Int>();
#     for(my $c = 0; $c < $r->cols(); $c++) {
#       if($r->row($i)->[$c] == 1) {
# 	$s = $s + $c;
#       }
#     }
#     print rank($m->minor(All,$s)),"\n";
#   }
# }
# 
# #EXPERIMENTAL
# user_function vamos_matroid {
#   #Create all 4-subsets of 0..7
#   my @foursets = all_subsets_of_k(4,0..7);
#   my @bases = ();
#   #Exclue 1,2,3,4 / 1,2,5,6 / 1,2,7,8 / 3,4,5,6 / 3,4,7,8
#   my $s1 = new Set<Int>(0,1,2,3);
#   my $s2 = new Set<Int>(0,1,4,5);
#   my $s3 = new Set<Int>(0,1,6,7);
#   my $s4 = new Set<Int>(2,3,4,5);
#   my $s5 = new Set<Int>(2,3,6,7);
#   for my $f (@foursets) {
#     my $s = new Set<Int>($f);
#     if(!($s == $s1 || $s == $s2 || $s == $s3 || $s == $s4 || $s == $s5)) {
#       @bases = (@bases,$s);
#     }
#   }
#   
#   my $mat = new matroid::Matroid(N_ELEMENTS=>8,BASES=>\@bases);
#   return $mat;
#   
# }
# 
# #EXPERIMENTAL
# user_function excluding_sets {
#   my ($k,$n,$I) = @_;
#   my @bases = ();
#   my @ksets = all_subsets_of_k($k,0..($n-1));
#   for my $S (@ksets) {
#     my $isbad = 0;
#     my $Sset = new Set<Int>($S);
#     for(my $r = 0; $r < $I->rows; $r++) {
#       if($I->row($r) == $Sset) {
# 	$isbad = 1; last;
#       }
#     }
#     if($isbad == 0) {
#       @bases = (@bases,$Sset);
#     }
#   }
#   return @bases;
# }
# 
# #EXPERIMENTAL
# user_function random_matrix {
#   my ($m,$n) = @_;
#   my $r = randomInteger(21,$m * $n);
#   my $matrix = new Matrix<Rational>(0,$n);
#   my @v = ();
#   for(my $s = 0; $s < $m; $s++) {
#     @v = ();
#     for(my $t = 0; $t < $n; $t++) {
#       @v = (@v, $r->[$s * $n + $t]-10);
#     }
#     $matrix =  $matrix / (new Vector<Rational>(\@v));
#   }
#   return $matrix;
# }
# 
# #EXPERIMENTAL
# user_function test_matroid_fans {
#   my ($m,$n,$t) = @_;
#   my $count = 0;
#   for(my $x = 0; $x < $t; $x++) {
#     my $matrix = random_matrix($m,$n);
#     my $f = bergman_fan_linear($matrix);
#     if($f->MAXIMAL_CONES->rows() - coarsen($f)->MAXIMAL_CONES->rows != 0) {
#       print $matrix,"\n\n";
#       $count ++;
#     }
#   }
#   print "Properly coarsend matrices: $count\n";
# }
