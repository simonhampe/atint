########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains a method to visualize a surface in R^3 containing a 
# set of (possibly non-pure) polyhedral complexes
########################################################################

user_function visualize_in_surface {
  my ($X,@p) = @_;
  
  my @vis = ();
  @vis = (@vis, $X->BB_VISUAL(WeightLabels=>"hidden",VertexStyle=>"hidden"));
  
  for my $p (@p) {
    my $vertno = $p->VERTICES->size();
    my $color = ($vertno == 1? "red" : ($vertno == 2? "blue" : "orange"));
    
    #Subdivide p into pure parts
    my $points = new Set<Int>();
    my $edges = new Set<Int>();
    my $cells = new Set<Int>();
    for my $mc (0 .. $p->MAXIMAL_CONES->rows()-1) {
      if($p->MAXIMAL_CONES->row($mc)->size() == 1) { $points = $points + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() == 2) { $edges = $edges + $mc;}
      if($p->MAXIMAL_CONES->row($mc)->size() > 2) { $cells = $cells + $mc;}
      
    }#END iterate cells of p
    my $ppoints = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($points,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pedges = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($edges,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    my $pcells  = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES->minor($cells,All),USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
    if($points->size() > 0) {
      @vis = (@vis, $ppoints->BB_VISUAL(VertexThickness=>2,VertexColor=>$color));
    }
    if($edges->size() > 0) {
      @vis = (@vis,$pedges->BB_VISUAL(EdgeThickness=>2,EdgeColor=>$color,VertexStyle=>"hidden"));
    }
    if($cells->size() > 0) {
      @vis = (@vis,$pcells->BB_VISUAL(EdgeColor=>$color,EdgeThickness=>2,FacetColor=>$color));
    }
  }#END iterate p's
  
  compose(@vis);
  
}

