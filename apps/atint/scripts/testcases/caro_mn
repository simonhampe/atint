use application "common";
use application "atint";
use Benchmark qw(:all);

print "Preparing...\n";

my $delta = new Matrix<Rational>([[1,-1,-1],[0,-1,-1],[-3,-2,1],[1,3,2],[2,1,1],[2,0,-1],[-3,1,-1],[2,1,1],[1,-3,-5],[-2,0,3],[-1,1,1]]);
my $f1 = atint::evaluation_map(2,3,$delta,1);
my $f2 = atint::evaluation_map(2,3,$delta,2);
my $g = new atint::Morphism(MATRIX=>$f1->MATRIX - $f2->MATRIX);
# 
# my $r1 = new RationalCurve(N_LEAVES=>13,SETS=>[[1,12],[2,3],[2,3,4],[1,2,3,4,12],[11,13],[9,10],[8,9,10],[8,9,10,11,13],[1,2,3,4,5,7,12]],COEFFS=>[1,1,1,1,1,1,1,1,1]);
# my $r2 = new RationalCurve(N_LEAVES=>13,SETS=>[[1,12],[2,3],[2,3,4],[1,2,3,4,12],[11,13],[9,10],[8,9,10],[8,9,10,11,13],[1,2,3,4,6,12]],COEFFS=>[1,1,1,1,1,1,1,1,1]);
my $rc = new RationalCurve(N_LEAVES=>13, INPUT_STRING=>"(2,3) + (2,3,4) + (1,12) + (1,2,3,4,12) + (9,10) + (8,9,10) + (11,13) + (8,9,10,11,13)");
# my $m = local_m0n($r1,$r2);
my $m = local_m0n($rc);
$m = product_complex($m,linear_nspace(3));

my $phi1 = new atint::MinMaxFunction(INPUT_STRING=>"max(x,0)",INPUT_VARS=>["x","y","z"]);
my $psi1 = pull_back($g,$phi1);
my $phi2 = new atint::MinMaxFunction(INPUT_STRING=>"max(y,0)",INPUT_VARS=>["x","y","z"]);
my $psi2 = pull_back($g,$phi2);
my $phi3 = new atint::MinMaxFunction(INPUT_STRING=>"max(z,0)",INPUT_VARS=>["x","y","z"]);
my $psi3 = pull_back($g,$phi3);
my @psi = ($psi1,$psi2,$psi3);

print "Computing divisor\n";
my ($t0,$t1);
$t0 = Benchmark->new;
my $div = divisor_list($m,@psi);
$t1 = Benchmark->new;
print "Time taken: ", timestr(timediff($t1,$t0)), "\n";
save($div,"caro_damn_example3.atint");
return $div;

# my $f1 = atint::evaluation_map(2,3,(new Matrix<Rational>([[1,-1,-1],[-2,0,2],[-1,1,-1],[2,1,0],[1,-2,-1],[-1,1,1]])),1);
# my $f2 = atint::evaluation_map(2,3,(new Matrix<Rational>([[1,-1,-1],[-2,0,2],[-1,1,-1],[2,1,0],[1,-2,-1],[-1,1,1]])),2);
# my $g = new atint::Morphism(MATRIX=>$f1->MATRIX - $f2->MATRIX);
# 
# #my $mn = atint::tropical_m0n(8);
# #my $p = atint::product_complex($mn,linear_nspace(3));
# my $r = new RationalCurve(N_LEAVES=>8,INPUT_STRING=>"(1,7) + (1,2,7) + (1,2,3,4,7) + (1,2,3,4,5,7)");
# my $m = local_m0n($r);
# $m = product_complex($m,linear_nspace(3));
# 
# #$p = local_codim_1($p,11188);
# my $phi1 = new atint::MinMaxFunction(INPUT_STRING=>"max(x,0)",INPUT_VARS=>["x","y","z"]);
# my $psi1 = pull_back($g,$phi1);
# my $phi2 = new atint::MinMaxFunction(INPUT_STRING=>"max(y,0)",INPUT_VARS=>["x","y","z"]);
# my $psi2 = pull_back($g,$phi2);
# my $phi3 = new atint::MinMaxFunction(INPUT_STRING=>"max(z,0)",INPUT_VARS=>["x","y","z"]);
# my $psi3 = pull_back($g,$phi3);
# my @psi = ($psi1,$psi2,$psi3);
# 
# print "done.\n";
# 
# my ($t0,$t1);
# #First we do the computation on the local complex
# print "Computing locally...\n";
# $t0 = Benchmark->new;
# my $localdiv = divisor_list($m,@psi);
# $t1 = Benchmark->new;
# print "Done after ", timestr(timediff($t1,$t0)),"\n";
# return $localdiv;
# 
# #Then we compute on the truncated complex
# # my $ptrunc = new WeightedComplex(RAYS=>$p->RAYS,MAXIMAL_CONES=>$p->MAXIMAL_CONES,TROPICAL_WEIGHTS=>$p->TROPICAL_WEIGHTS, USES_HOMOGENEOUS_C=>$p->USES_HOMOGENEOUS_C);
# # print "Computing on the truncated complex...\n";
# # $t0 = Benchmark->new;
# # my $truncdiv = divisor_list($ptrunc,@psi);
# # $t1 = Benchmark->new;
# # print "Done after ", timestr(timediff($t1,$t0)),"\n";
# 
# save($localdiv,"caro__really_local_div.atint");
#save($truncdiv,"caro_trunc_div.atint");

# for(my $i = 1; $i <= 3; $i++) {
#   my $t0 = Benchmark->new;
#   print "Computing divisor $i\n";
#   $p = divisor($p,$psi[$i-1]);
#   my $t1 = Benchmark->new;
#   print "Done after ", timestr(timediff($t1,$t0)),"\n";
# }
# save($p,"caro_result_codim.atint");
# 
