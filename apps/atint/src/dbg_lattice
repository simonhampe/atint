/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 * 
 * ---
 * Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
 * 
 * 
 */

#include "polymake/client.h"
#include "polymake/Rational.h"
#include "polymake/Matrix.h"
#include "polymake/Vector.h"
#include "polymake/linalg.h"
#include "polymake/IncidenceMatrix.h"
#include "polymake/atint/LoggingPrinter.h"
#include "polymake/atint/normalvector.h"

namespace polymake { namespace atint { 
  
  using namespace atintlog::donotlog;
  //using namespace atintlog::dolog;
  //using namespace atintlog::dotrace;
  
  ///////////////////////////////////////////////////////////////////////////////////////
  
  void computeLatticeNormals(perl::Object fan) {
    
    
    
    //dbgtrace << "Extracting properties" << endl;
    
    //Extract basic properties of fan
    int ambient_dim = fan.give("FAN_AMBIENT_DIM");
    bool uses_homog = fan.give("USES_HOMOGENEOUS_C");
    IncidenceMatrix<> codimInc = fan.give("CODIM_1_IN_MAXIMAL_CONES");
    IncidenceMatrix<> maximalCones = fan.give("MAXIMAL_CONES");
    IncidenceMatrix<> codimOneCones = fan.give("CODIM_1_FACES");
    Matrix<Rational> rays = fan.give("RAYS");
    Matrix<Rational> linspace = fan.give("LINEALITY_SPACE");
    
    //This will contain the result
    Map<int, Map<int, Vector<Integer> > > latticeNormals;
    if(codimOneCones.rows() == 0) {
//       fan.take("LATTICE_NORMALS") << latticeNormals;
      return;
    }
       
    //This equation is added to all cone linear span matrices (and stands for intersecting
    // with (x0 = 1), if we use homogeneous coordinates, to ensure that the lattice normal
    // is of the form (0,...)
    Vector<Rational> intereq(unit_vector<Rational>(ambient_dim,0));
    
    //dbgtrace << "Computing linear spans" << endl;
    
    //Compute all the linear spans of the cones before, so we don't do it several times
    Vector<Matrix<Rational> > codimone;
    Vector<Matrix<Rational> > maximal;
    for(int facet = 0; facet < codimOneCones.rows(); facet++) {
      codimone |= null_space(rays.minor(codimOneCones.row(facet),All) / linspace);
    }
    for(int mcone = 0; mcone < maximalCones.rows(); mcone++) {
      maximal |=  null_space(rays.minor(maximalCones.row(mcone),All) / linspace);
    }
    
    //dbgtrace << "Computing lattice normals" << endl;
    
    //Go through all codim one faces
    for(int facet = 0; facet < codimone.dim(); facet++) {
      //Create map for this facet
      latticeNormals[facet] = Map<int, Vector<Integer> >();
      
      //Construct the dual of the linear span of the cone:
      //= kernel of generators
      Matrix<Rational> facetmatrix = codimone[facet];
      if(uses_homog) {
	facetmatrix = facetmatrix / intereq;
      }
      Set<int> adjacentCones = codimInc.row(facet);
      //Go through all adjacent cones
      for(Entire<Set<int> >::iterator e=entire(adjacentCones); !e.at_end(); ++e) {
	Matrix<Rational> maxmatrix = maximal[*e];
	if(uses_homog) {
	  maxmatrix = maxmatrix / intereq;
	}
	//Extract the additional ray by taking any index in the maximal cone
	// and not in the codim 1 cone
	int additionalRayIndex = *(maximalCones.row(*e) - codimOneCones.row(facet)).begin();
	Vector<Rational> additionalRay(rays.row(additionalRayIndex));
	
	//Compute normalvector
	(latticeNormals[facet])[*e] = latticeNormal(facetmatrix,maxmatrix,additionalRay);
      }
    }
    
//     fan.take("LATTICE_NORMALS") << latticeNormals;
  }
  
  ///////////////////////////////////////////////////////////////////////////////////////
  
  void computeProjectionLattice(perl::Object fan) {
    
    //dbgtrace << "Extracting properties" << endl;
    
    //Extract basic properties of fan
    IncidenceMatrix<> codimInc = fan.give("CODIM_1_IN_MAXIMAL_CONES");
      IncidenceMatrix<> codimInMaximal = T(codimInc);
    IncidenceMatrix<> maximalCones = fan.give("MAXIMAL_CONES");
    IncidenceMatrix<> codimOneCones = fan.give("CODIM_1_FACES");
    Matrix<Rational> rays = fan.give("RAYS");
    Matrix<Rational> linspace = fan.give("LINEALITY_SPACE");
    Matrix<Integer> lattice_generators = fan.give("LATTICE_GENERATORS");;
    IncidenceMatrix<> lattice_bases = fan.give("LATTICE_BASES");
    bool uses_homog = fan.give("USES_HOMOGENEOUS_C");
    
    //This will contain the result
    Map<int, Map<int, Vector<Integer> > > latticeNormals;
    if(codimOneCones.rows() == 0) {
//       fan.take("LATTICE_NORMALS") << latticeNormals;
      return;
    }
    
    //Create maps for facets
    for(int co = 0; co < codimOneCones.rows(); co++) {
      latticeNormals[co] = Map<int,Vector<Integer> >();
    }
    
    //Compute normal vectors
    for(int mc = 0; mc < maximalCones.rows(); mc++) {
      //Compute the projection
      //dbgtrace << "Computing projection matrix for cone " << mc << endl;
      Matrix<Integer> lb = lattice_generators.minor(lattice_bases.row(mc),All) ;
      //This matrix is used to compute the preimage of the projection normal
      Matrix<Integer> inverse = T(lb);
	if(uses_homog) inverse = zero_vector<Integer>() | inverse;
      Set<int> I = basis_cols(lb);
      Matrix<Rational> S = inv(T(lb.minor(All,I)));
      Matrix<Rational> P(S.rows(),lattice_generators.cols());
      P.minor(All,I) = S;
      
      //dbgtrace << "Projection matrix reads: " << P << endl;
      //dbgtrace << "lb: " << lb << endl;
      
      //Project maximal cone rays and lineality and compute span
      Matrix<Rational> mc_rays(rays.minor(maximalCones.row(mc),All));
	//Identify vertices
	Set<int> vertices;
	if(uses_homog) {
	  for(int r = 0; r < mc_rays.rows(); r++) {
	    if(mc_rays(r,0) == 1) vertices += r;
	  }
	}
	//Project rays
	mc_rays = mc_rays * T(P);
	//Add homog. "1" where necessary
	if(uses_homog) {
	  mc_rays = zero_vector<Rational>() | mc_rays;
	  mc_rays.col(0).slice(vertices) = ones_vector<Rational>(vertices.size());
	}
	
      Matrix<Rational> proj_lineality = linspace * T(P);
      if(uses_homog && proj_lineality.rows() > 0) {
	proj_lineality = zero_vector<Rational>() | proj_lineality;
      }
      
      Matrix<Rational> mc_span = null_space(mc_rays / proj_lineality);
      
      if(uses_homog) {
	//Intersect with x0 = 0 in homog. coordinates
	mc_span /= unit_vector<Rational>(lb.rows()+1,0);
      }      
      
      //Now iterate the facets
      Set<int> facets = codimInMaximal.row(mc);
      for(Entire<Set<int> >::iterator co = entire(facets); !co.at_end(); co++) {
	//dbgtrace << "Computing for facet " << *co << endl;
	//Project facet
	Matrix<Rational> co_rays = rays.minor(codimOneCones.row(*co),All);
	  //Identify vertices
	  Set<int> co_vertices;
	  if(uses_homog) {
	    for(int r = 0; r < co_rays.rows(); r++) {
	      if(co_rays(r,0) == 1) co_vertices += r;
	    }
	  }
	  //Project rays
	  co_rays = co_rays * T(P);
	  //Add homog. "1" where necessary
	  if(uses_homog) {
	    co_rays = zero_vector<Rational>() | co_rays;
	    co_rays.col(0).slice(co_vertices) = ones_vector<Rational>(co_vertices.size());
	  }
	  
	Matrix<Rational> co_span = null_space(co_rays / proj_lineality);
	if(uses_homog) {
	  //Intersect with x0 = 0 in homog. coordinates
	  co_span /= unit_vector<Rational>(co_span.cols(),0);
	}
	
	//Extract the additional ray by taking any index in the maximal cone
	// and not in the codim 1 cone
	int additionalRayIndex = *(maximalCones.row(mc) - codimOneCones.row(*co)).begin();
	Vector<Rational> additionalRay(rays.row(additionalRayIndex) * T(P));
	if(uses_homog) {
	  Rational add = rays(additionalRayIndex,0) == 1? 1 : 0;
	  additionalRay = add | additionalRay;
	}
	
	//dbgtrace << "Mc: " << mc_rays << endl;
	//dbgtrace << "Mc-span" << mc_span << endl;
	//dbgtrace << "Co: " << co_rays << endl;
	//dbgtrace << "co-span: " << co_span << endl;
	//dbgtrace << "ar: " << additionalRay << endl;
	
	//Compute facet normal in projection
	Vector<Integer> normal = latticeNormal(co_span, mc_span,additionalRay);
	
	//dbgtrace << "ln: " << normal << endl;
	
	//Compute preimage
	(latticeNormals[*co])[mc] = inverse * normal;
	//dbgtrace << "result: " << (latticeNormals[*co])[mc] << endl;
	
      }//END iterate facets
    }//END iterate maximal cones
    
//     fan.take("LATTICE_NORMALS") << latticeNormals; 
    
    /*int dim = sigma.give("CONE_DIM");
    Set<int> I = basis_cols(latticeBasis);
    Matrix<Rational> S = inv(T(latticeBasis.minor(All,I)));
    Matrix<Rational> P(dim,latticeBasis.cols());
    P.minor(All,I) = S;
    
    pm::cout << "Trafo " << P << endl;
    
    Matrix<Rational> taurays = tau.give("RAYS");
      taurays = T(P * T(taurays));
    Matrix<Rational> sigmarays = sigma.give("RAYS");
      sigmarays = T(P * T(sigmarays));
      
    pm::cout << "Tau: " << taurays << endl;
    pm::cout << "sigma: " << sigmarays << endl;
      
    perl::Object trtau("polytope::Cone");
      trtau.take("RAYS") << taurays;
    perl::Object trsigma("polytope::Cone");
      trsigma.take("RAYS") << sigmarays;
      
    Vector<Integer> ln = latticeNormalByCone(trtau,trsigma);
    pm::cout << "ln: " << ln << endl;
    
    return T(latticeBasis)*ln;*/
    
    
  }
  // ------------------------- PERL WRAPPERS ---------------------------------------------------
  
//   Function4perl(&computeLatticeNormals,"cln(WeightedComplex)");
//   Function4perl(&computeProjectionLattice,"cpl(WeightedComplex)");
  
}}