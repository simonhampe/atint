/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 * 
 * ---
 * Copyright (C) 2012, Simon Hampe <hampe@mathematik.uni-kl.de>
 * 
 * This file computes the stable intersection of two tropical varieties
 * using the Minkowski weight formula
 */

#include "polymake/client.h"
#include "polymake/Matrix.h"
#include "polymake/Rational.h"
#include "polymake/Vector.h"
#include "polymake/PowerSet.h"
#include "polymake/Array.h"
#include "polymake/atint/normalvector.h"
#include "polymake/atint/LoggingPrinter.h"

namespace polymake { namespace atint { 
  
  using namespace atintlog::donotlog;
  //using namespace atintlog::dolog;
  //using namespace atintlog::dotrace;
  
  ///////////////////////////////////////////////////////////////////////////////////////
  
  /**
   @brief Takes a list of rays who span a full-dimensional cone and computes the index of the lattice generated by the primitive versions of the rays
   @param Matrix<Rational> rays The rays of the cone. Needn't be irredundant in any form
   @return int The index of the lattice generated by the primitive versions of the rays (in Z^n)
   */
  Integer lattice_index(const Matrix<Rational> &lattice_rays) {
    if(lattice_rays.rows() < lattice_rays.cols()) {
      throw std::runtime_error("Cannot compute lattice index - not a full-dimensional lattice!");
    }
    Matrix<Integer> m = makeInteger(lattice_rays);
    //Go through all col-element subsets of {1,..,rows}
    Array<Set<int> > minors = all_subsets_of_k(sequence(0,lattice_rays.rows()),lattice_rays.cols());
    Integer g = 0;
    for(int s = 0; s < minors.size(); s++) {
      g = gcd(g,abs(det(m.minor(minors[s],All))));
    }
    
    return g;
    
  }
  
  ///////////////////////////////////////////////////////////////////////////////////////
  
//   perl::Object minkowski_intersection(perl::Object X, perl::Object Y) {
//     //Extract values
//     int Xcodim = X.give("CMPLX_CODIMENSION");
//     int Ycodim = Y.give("CMPLX_CODIMENSION");
//     int Xambi  = X.give("CMPLX_AMBIENT_DIM");
//     
//     //dbgtrace << "Checking codimension" << endl;
//     
//     //If the codimensions of the varieties add up to something larger then CMPLX_AMBIENT_DIM, return the 0-cycle 
//     if(Xcodim + Ycodim > Xambi) {
//       return CallPolymakeFunction("zero_cycle");
//     }
//     
//     //dbgtrace << "Homogenizing where necessary" << endl;
//     
//     //Make sure,both are homogeneous
//     bool x_uses_homog = X.give("USES_HOMOGENEOUS_C");
//     bool y_uses_homog = Y.give("USES_HOMOGENEOUS_C");
//     
//     if(!x_uses_homog) X = X.CallPolymakeMethod("homogenize");
//     if(!y_uses_homog) Y = Y.CallPolymakeMethod("homogenize");
//     
//     //dbgtrace << "Computing diagonal" << endl;
//     
//     //The lineality space of the intersection product is the intersection of the lineality spaces
//     //Compute the intersection of the two spaces
//     Matrix<Rational> x_lineality = X.give("LINEALITY_SPACE");
//     Matrix<Rational> y_lineality = Y.give("LINEALITY_SPACE");
//     Matrix<Rational> r_lineality(0,Xambi + 1);      
//     if(x_lineality.rows() != 0 && y_lineality.rows() != 0){
//       //We compute the kernel of (x_lineality | -y_lineality)
//       Matrix<Rational> i_lineality = T(x_lineality  / (-y_lineality));
//       Matrix<Rational> dependence =  null_space(i_lineality);
//       r_lineality = dependence.minor(All,sequence(0,x_lineality.rows())) * x_lineality;
//       //r_lineality = zero_vector<Rational>() | r_lineality;
//     }
//     int r_lineality_dim = rank(r_lineality);
//     
//     //Compute the expected dimension of the intersection product (in the homogeneous coordinates)
//     // Substract the lineality dimension, since we compute without it
//     int expectedDimension = Xambi - (Xcodim + Ycodim) - r_lineality_dim;
//     
//     //Now compute the set-theoretic intersection skeleton, i.e the expectedDimension-skeleton of 
//     //the set-theoretic intersection
//     Matrix<Rational> xRays = X.give("RAYS");
//     IncidenceMatrix<> xMaximal = X.give("MAXIMAL_CONES");
//     Matrix<Rational> yRays = Y.give("RAYS");
//     IncidenceMatrix<> yMaximal = Y.give("MAXIMAL_CONES");
//     
//     Vector<Set<int> > interCones;
//     Matrix<Rational> interRays(0,Xambi+1);
//     for(int xcone = 0; xcone < xMaximal.rows(); xcone++) {
//       
//     }
//   }
  
  // ------------------------- PERL WRAPPERS ---------------------------------------------------
  
  Function4perl(&lattice_index,"li(Matrix<Rational>)");
  
}}