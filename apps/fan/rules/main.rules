#######################################################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file extends the polyhedral fan of polymake to a tropical variety by assigning weights to the maximal cones
# and by allowing the fan to be interpreted as a polyhedral complex by intersecting it at x0 = 1
########################################################################################################

USE tropical 

object PolyhedralFan {

	## PROPERTIES ###########################################################
  
	# @category Tropical properties
	# Vector of (integer) weights for maximal cones. Indices refer to (the rows of) [[MAXIMAL_CONES]]
	# If, however, the fan only consists of a lineality space, specifying the weight of this single maximal
	# cone is only necessary, if you want to compute refinements of this fan later on (e.g. for computing
	# divisors of rational functions)
	property TROPICAL_WEIGHTS : Vector<Scalar>;

	# @category Tropical properties
	# Indicates whether the fan is balanced with the given [[TROPICAL_WEIGHTS]].
	property IS_BALANCED : Bool;	

	# @category Basic properties
	# An incidence matrix of all codimension one faces. Each row is a face and column indices refer to [[RAYS]].
	# If the fan uses homogeneous coordinates, only those faces that intersect {x0 = 1} are listed here.
	property CODIM_1_FACES : IncidenceMatrix;
	
	# @category Basic properties
	# An incidence matrix indicating which codim 1 faces are contained in which maximal cone. Rows refer
	# to (rows of) [[CODIM_1_FACES]], columns to (rows of) [[MAXIMAL_CONES]]
	property CODIM_1_IN_MAXIMAL_CONES : IncidenceMatrix;
	
	# @category Tropical properties
	# A list of lattice normal vectors. They are associated to the faces and maximal cones in the following 
	# way: For face i and adjacent maximal cone j, the element [[LATTICE_NORMALS]]->{i}->{j} is the corresp.
	# lattice normal vector. There is a convenience method lattice_normal(i,j)
	property LATTICE_NORMALS : Map<Int,Map<Int,Vector<Integer>>>; 
	
	# @category Tropical geometry
	# For each lattice normal vector, this gives a vector of length (number of rays) + (lineality dim.), such that
	# if a rational function is given by values on the rays and lin space generators, the value of the corresponding
	# normal [[LATTICE_NORMALS]]->{i}->{j} can be computed by multiplying the function value vector with 
	# the vector [[LATTICE_NORMAL_FCT_VECTOR]]->{i}->{j}. This is done in the following way:  If this fan does not 
	# use homogeneous coordinates, it computes a representation of the lattice normal in the generating system 
	# consisting of the rays of [[MAXIMAL_CONES]]->row(j) and the generators 
	# of the lineality space. It then inserts the coefficients of the representation at the right position. 
	# If the fan uses homog. coordinates, however, we use a different generating system (and indices refer to CMPLX_RAYS)
	# <r_0, (r_i-r_0)_i>0, s_j, l_k>, where r_0 is the ray of the maximal cone 
	# with the lowest index in [[CMPLX_RAYS]], such that it fulfills x0 = 1, r_i are the remaining rays with x0 = 1, ordered
	# according to their index in [[CMPLX_RAYS]], s_j are the rays of the cone with x0 = 0 and l_k are the lineality space 
	# generators. We will then store the coefficients a_i of (r_i - r_0) at the index of r_i, then - sum(a_i) at 
	# the index of r_0 and the remaining coefficients at the appropriate places.
	property LATTICE_NORMAL_FCT_VECTOR : Map<Int,Map<Int,Vector<Rational>>>;
	
	# @category Tropical geometry
	# Rows of this matrix correspond to [[CODIM_1_FACES]], and each row contains the weighted sum:
	# sum_{cone > codim-1-face}( weight(cone) * [[LATTICE_NORMALS]]->{codim-1-face}->{cone})
	property LATTICE_NORMAL_SUM : Matrix<Scalar>;
	
	# @category Tropical geometry
	# Rows of this matrix correspond to [[CODIM_1_FACES]] (or [[CMPLX_CODIM_1_FACES]] in the homog. case), and each row 
	# contains a function vector for the corresponding row of [[LATTICE_NORMAL_SUM]]. This function vector is computed 
	# in the same way as described under [[LATTICE_NORMAL_FCT_VECTOR]].
	property LATTICE_NORMAL_SUM_FCT_VECTOR : Matrix<Scalar>;
	
	# @category Polyhedral complex
	# A matrix of the rays of the fan. This should be used *instead of* [[INPUT_RAYS]], if the coordinates of the
	# fan should be interpreted as homogeneous coordinates and the fan as the complex at x0 = 1.
	# The input rays are normalized to x0 = 1 and the fan is then initialized with the normalized rays as
	# [[INPUT_RAYS]].
	# [[INPUT_CONES]] can be combined with this as usual. If your rays are already homogenized and you are sure they
	# are also your rays, you can directly put this into RAYS and manually set USES_HOMOGENEOUS_C=>TRUE
	property INPUT_HOM_RAYS: Matrix<Scalar>;
	
	# @category Polyhedral complex
	# A matrix of generators of the lineality space, but in homogeneous coordinates (i.e. x0 should be 0, otherwise 
	# this throws an error). This should be used *instead of* [[INPUT_LINEALITY]] / [[LINEALITY_SPACE]]
	property INPUT_HOM_LINEALITY : Matrix<Scalar>;
	
	# @category Polyhedral complex
	# Indicates whethere this fan's coordinates should be interpreted as affine coordinates or as homogeneous coordinates.
	# In the latter case the fan would actually represent the polyhedral complex that comes from intersecting the fan
	# (in affine coordinates) with the affine hyperplane x0 = 1. This property should not be set manually. It will be set
	# as true, if [[INPUT_HOM_RAYS]] or [[INPUT_HOM_LINEALITY]] are used and to false, if [[INPUT_RAYS]] or [[INPUT_LINEALITY]]
	# are used.
	property USES_HOMOGENEOUS_C : Bool;
	
	# @category Polyhedral complex
	# If the fan does not use homogeneous coordinates, this is just a copy of RAYS and actually needn't be requested. Otherwise this computes
	# a matrix of rays of the complex obtained by intersecting the fan with {x0 = 1}. More precisely, each ray r from [[RAYS]] occurs in 
	# as a row in this matrix...
	# - once, if r_0 = 1
	# - k times, if r_0 = 0 and k is the number of equivalence classes of maximal cones containing r with respect to the following relation:
	# To maximal cones m, m' containing r are equivalent, if they are equal or there exists a sequence of maximal cones
	# m = m_1,...m_r = m', such that r is contained in each m_i and each intersection m_i cap m_i+1 contains at least one ray s with s_0 = 1.
	# The reason for this is that, when specifying a piecewise affine linear function on a polyhedral complex, the same directional ray with 
	# x0 = 0 might be assigned two different values, if it is contained in two "non-connected" maximal cones (where connectedness is to be 
	# understood as described above).
	property CMPLX_RAYS : Matrix<Scalar>;
	
	# @category Polyhedral complex
	# An incidence matrix describing which maximal cone in the complex at x0 = 1 is generated by which rays. 
	# Each row corresponds to a maximal cone (More precisely, the i-th element represents the
	# same maximal cone as the i-th element of [[MAXIMAL_CONES]]). The indices in a row refer to rows of [[CMPLX_RAYS]], i.e. the maximal
	# cone described by the i-th element is generated by the rays corresponding to these row indices.
	# If the fan does not use homogeneous coordinates, it is just a copy of [[MAXIMAL_CONES]]
	property CMPLX_MAXIMAL_CONES : IncidenceMatrix;
	
	# @category Polyhedral complex
	# An incidence matrix describing which codim 1 cone in the complex at x0 = 1 is generated by which rays. 
	# Each row corresponds to a codimension one cone (More precisely, the i-th element represents the
	# same codim 1 cone as the i-th element of [[CODIM_1_FACES]]). The indices in a row refer to rows of [[CMPLX_RAYS]], i.e. the cone
	# cone described by the i-th element is generated by the rays corresponding to these row indices.
	# If the fan does not use homogeneous coordinates, it is just a copy of [[CODIM_1_FACES]].
	property CMPLX_CODIM_1_FACES : IncidenceMatrix;
		
	
	## RULES ################################################################
	
	# The different weights for the following two rules make sure that existence of INPUT_HOM_* is checked first (since INPUT_* will always be set by INPUT_HOM_*
	
	rule USES_HOMOGENEOUS_C : INPUT_RAYS | INPUT_LINEALITY {
	    $this->USES_HOMOGENEOUS_C = FALSE;
	}
	weight 0.4;
	
	rule USES_HOMOGENEOUS_C : INPUT_HOM_RAYS | INPUT_HOM_LINEALITY {
	    $this->USES_HOMOGENEOUS_C = TRUE;
	}
	weight 0.1;
	
	
	rule INPUT_RAYS : INPUT_HOM_RAYS {
	    #Normalize rays first
	    my $m = new Matrix<Rational>($this->INPUT_HOM_RAYS->rows(), $this->INPUT_HOM_RAYS->cols());
	    for(my $r = 0; $r < $this->INPUT_HOM_RAYS->rows(); $r++) {
		if($this->INPUT_HOM_RAYS->row($r)->[0] == 0) {
		    $m->row($r) = $this->INPUT_HOM_RAYS->row($r);
		}
		else {
		    $m->row($r) = ($this->INPUT_HOM_RAYS->row($r)) * (1 / $this->INPUT_HOM_RAYS->row($r)->[0]);
		}
	    }
	    $this->INPUT_RAYS = $m;
	}
	
	## !!!!!!!!!!!!! FIXME: This should probably be INPUT_LINEALITY, but as long as polymake doesn't actually use that property, it makes no sense to do that
	rule LINEALITY_SPACE : INPUT_HOM_LINEALITY {
	    #Just check if all the first entries are 0
	    for(my $r = 0; $r < $this->INPUT_HOM_LINEALITY->rows(); $r++) {
		if($this->INPUT_HOM_LINEALITY->row($r)->[0] != 0) {
		    die "Invalid coordinates for lineality space, x0 should be 0";
		}
	    }
	    $this->LINEALITY_SPACE = $this->INPUT_HOM_LINEALITY;
	}
	
	rule CODIM_1_FACES, CODIM_1_IN_MAXIMAL_CONES : MAXIMAL_CONES_INCIDENCES, USES_HOMOGENEOUS_C {
	  
	  #First we construct the set of all facets
	  my @mInc = @{$this->MAXIMAL_CONES_INCIDENCES};
	  #my $s = new Set<Set<Int>>(); #We use a set to check for doubles
	  my @facetArray;		#but we actually plug in the array to fix the order
				      #so that we have compatibility with the in-max-cones matrix
	  my @fIncones;
	   								
	  for(my $maxCone = 0; $maxCone < scalar(@mInc); $maxCone++) {
	      my $fcts = $mInc[$maxCone];
	      for(my $facet = 0; $facet < $fcts->rows(); $facet++) {
		  my $facetToCheck = $fcts->row($facet);
		  # If we use homog. coords: Check if this facet intersects x0 = 1, otherwise go to the next one 
		  # More precisely: Check if at least one of its rays has x0-coord != 0
		  if($this->USES_HOMOGENEOUS_C) {
		      my $raysfirstcol = ($this->RAYS->minor($facetToCheck,All))->col(0);
		      if($raysfirstcol == zero_vector<Rational>($raysfirstcol->dim)) {
			next;
		      }		    
		  }
		  my $fcIndex = -1;
		  #Check if we already have this facet and remember its index
		  for(my $existing = 0; $existing < scalar(@facetArray); $existing++) {
		    if($facetArray[$existing] == $facetToCheck) {
			$fcIndex = $existing;
			last;
		    }
		  }
		  #Add the facet if necessary and add its max-cone incidence
		  if($fcIndex == -1) {
		      @facetArray = (@facetArray, $facetToCheck);
		      $fIncones[scalar(@facetArray)-1] = new Set<Int>($maxCone);
		  }
		  else {
		      $fIncones[$fcIndex] = $fIncones[$fcIndex] + new Set<Int>($maxCone);
		  }
	      }
	  }	  
	  
	  #Now each row of element of @facetArray is a facet. We transform this into an incidence matrix
	  $this->CODIM_1_FACES = new IncidenceMatrix(@facetArray);
	  #Similarly for the max-cones incidence
	  $this->CODIM_1_IN_MAXIMAL_CONES = new IncidenceMatrix(@fIncones);
	}
	
	#------------------------------------------------------------------------#
	  
	rule LATTICE_NORMALS : CODIM_1_FACES, MAXIMAL_CONES,  CODIM_1_IN_MAXIMAL_CONES{
	  #Create all the cones
	  my @facetCones;
	  my @maximalCones;
	  
	  my $latticemap = new Map<Int,Map<Int,Vector<Integer>>>();
	  
	  for(my $i = 0; $i < $this->CODIM_1_FACES->rows(); $i++) {
	      my $facetRays = $this->RAYS->minor($this->CODIM_1_FACES->row($i),All);
	      #If facet is just the origin, we have to insert a zero vector of appropriate dimension,
	      #otherwise it will be interpreted as a cone in 0-dim. space.
	      @facetCones = (@facetCones, 
			     $facetRays->rows() > 0 ? new polytope::Cone<Rational>(RAYS=>$facetRays)
						  : new polytope::Cone<Rational>(INPUT_RAYS=>zero_vector($this->AMBIENT_DIM)));
	      $latticemap->{$i} = new Map<Int,Vector<Integer>>();
	  }
	  for(my $i = 0; $i < $this->MAXIMAL_CONES->rows(); $i++) {
	      @maximalCones = (@maximalCones, new polytope::Cone<Rational>(
				RAYS=>($this->RAYS->minor($this->MAXIMAL_CONES->row($i),All))));
	  }
	  
	  #Now compute lattice normals
	  for( my $facet = 0; $facet < scalar(@facetCones); $facet++) {
	      my $facetmatrix =  $facetCones[$facet]->LINEAR_SPAN;
	      for( my $maxcone = 0; $maxcone < $this->CODIM_1_IN_MAXIMAL_CONES->cols(); $maxcone++)  {
		  if($this->CODIM_1_IN_MAXIMAL_CONES->($facet,$maxcone)) {
		      my $maxmatrix = $maximalCones[$maxcone]->LINEAR_SPAN;
		      my $additionalRay = @{$this->MAXIMAL_CONES->row($maxcone) - $this->CODIM_1_FACES->row($facet)}[0];
		      $additionalRay = new Vector<Rational>($this->RAYS->row($additionalRay));
		      $latticemap->{$facet}->{$maxcone} = 
			    tropical::latticeNormal($facetmatrix,$maxmatrix,$additionalRay);
		  }
	      }
	  }
	  $this->LATTICE_NORMALS = $latticemap;
	}
	
	#------------------------------------------------------------------------#
	
	rule IS_BALANCED : CODIM_1_FACES, MAXIMAL_CONES,  CODIM_1_IN_MAXIMAL_CONES, TROPICAL_WEIGHTS, LATTICE_NORMALS {
	    #Iterate over all facets
	    my $isb = 1;
	    my %lattice_map = %{$this->LATTICE_NORMALS};
	    #The set of lattice normals relative to fct
	    
	    
	    
	    for(my $facet = 0; $facet < $this->CODIM_1_FACES->rows(); $facet++) {
		my %fct_map = %{$lattice_map{$facet}};
		#The set of maximal cones adjacent to fct
		my @adjacent_cones = keys(%fct_map);
		my $result = new Vector<Integer>($this->AMBIENT_DIM);
		for( my $mc = 0; $mc < scalar(@adjacent_cones); $mc++)  {
		  my $maxcone = $adjacent_cones[$mc];
		  if($this->CODIM_1_IN_MAXIMAL_CONES->($facet,$maxcone)) {
		      $result += ($this->TROPICAL_WEIGHTS->[$maxcone]) * $this->lattice_normal($facet,$maxcone);
		  }
		}
		my $vtau = new Matrix<Rational>($this->RAYS->minor($this->CODIM_1_FACES->row($facet),All));
		$result = new Matrix<Rational>($result);
		my $r = rank($vtau);
		if (rank( $vtau / $result) > $r) {
		  $isb = 0;
		  last;
		}
	    }
	    
	    $this->IS_BALANCED = $isb;
	}
	
	#------------------------------------------------------------------------#
	
	rule LATTICE_NORMAL_FCT_VECTOR, LATTICE_NORMAL_SUM_FCT_VECTOR : LATTICE_NORMAL_SUM, LATTICE_NORMALS, TROPICAL_WEIGHTS, N_RAYS, LINEALITY_DIM, CMPLX_RAYS, CMPLX_CODIM_1_FACES, CMPLX_MAXIMAL_CONES {
	  
	  my $n_gens = ($this->USES_HOMOGENEOUS_C? $this->N_RAYS : $this->CMPLX_RAYS->rows()) + $this->LINEALITY_DIM;
	  my $summatrix = new Matrix<Rational>(0,$n_gens);
	  my $summap = new Map<Int,Map<Int,Vector<Rational>>>();
	  my %lattice_map = %{$this->LATTICE_NORMALS};
	  
	  #Iterate over all codim 1 faces
	  
	  for(my $fct = 0; $fct < $this->CODIM_1_FACES->rows(); $fct++) {
	      my $maxmap = new Map<Int,Vector<Rational>>();
	      
	      #Iterate over adjacent maximal cones
	      
	      #The set of lattice normals relative to fct
	      my %fct_map = %{$lattice_map{$fct}};
	      #The set of maximal cones adjacent to fct
	      my @adjacent_cones = keys(%fct_map);
	      
	      
	      
	      #Compute representation of normal vector
	      for(my $mc = 0; $mc < scalar(@adjacent_cones); $mc ++) {
		my $normalvector = $this->LATTICE_NORMALS->{$fct}->{$adjacent_cones[$mc]};
		#print "For facet ", $fct, " and maxcone ", $adjacent_cones[$mc], "\n";
		my $rep = $this->functionRepresentationVector(
		($this->USES_HOMOGENEOUS_C? $this->CMPLX_MAXIMAL_CONES : $this->MAXIMAL_CONES)->[$adjacent_cones[$mc]],$normalvector);
		$maxmap->{$adjacent_cones[$mc]} = $rep;
	      }
	      
	      $summap->{$fct} = $maxmap;
	      
	      #Now compute the represetation of the sum of the normals
	      my $normalsum = $this->LATTICE_NORMAL_SUM->row($fct);
	      my $rep = $this->functionRepresentationVector(
			($this->USES_HOMOGENEOUS_C? $this->CMPLX_CODIM_1_FACES : $this->CODIM_1_FACES)->[$fct],
			$normalsum);
	      $summatrix = $summatrix / $rep;
	      
	  }
	  
	  #Set fan properties
	  $this->LATTICE_NORMAL_FCT_VECTOR = $summap;
	  $this->LATTICE_NORMAL_SUM_FCT_VECTOR = $summatrix;
	  
	}
	
	#------------------------------------------------------------------------#
	
	rule LATTICE_NORMAL_SUM : LATTICE_NORMALS, TROPICAL_WEIGHTS {
	    my $m = new Matrix<Integer>(0,$this->AMBIENT_DIM);
	    my %lattice_map = %{$this->LATTICE_NORMALS};
	    
	    for(my $fct = 0; $fct < $this->CODIM_1_FACES->rows(); $fct++) {
		#The set of lattice normals relative to fct
		my %fct_map = %{$lattice_map{$fct}};
		#The set of maximal cones adjacent to fct
		my @adjacent_cones = keys(%fct_map);
		my $normalsum = zero_vector<Integer>($this->AMBIENT_DIM);
		for(my $mc = 0; $mc < scalar(@adjacent_cones); $mc ++) {
		    $normalsum = $normalsum + ($this->LATTICE_NORMALS->{$fct}->{$adjacent_cones[$mc]} * $this->TROPICAL_WEIGHTS->[$adjacent_cones[$mc]]);
		}
 		$m = $m / new Vector<Integer>($normalsum);
	    }
	    
	    $this->LATTICE_NORMAL_SUM = $m;
	}
	
	#------------------------------------------------------------------------#
	
	rule CMPLX_RAYS, CMPLX_MAXIMAL_CONES, CMPLX_CODIM_1_FACES : RAYS, MAXIMAL_CONES, CODIM_1_FACES, CODIM_1_IN_MAXIMAL_CONES {
	  if(!($this->USES_HOMOGENEOUS_C)) {
	    $this->CMPLX_RAYS = $this->RAYS;
	    $this->CMPLX_MAXIMAL_CONES = $this->MAXIMAL_CONES;
	    $this->CMPLX_CODIM_1_FACES = $this->CODIM_1_FACES;
	  }
	  else {
	    #Prepare variables
	    my $cmplxrays = new Matrix<Rational>(0,$this->AMBIENT_DIM);
	    my @codimone = ();
	    my @maxcones = ();
	    
	    #First we divide the set of rays into those with x0 != 0 and those with x0 = 0
	    my $affineRays = new Set<Int>();
	    my $directionalRays = new Set<Int>();
	    for(my $r = 0; $r < $this->RAYS->rows(); $r++) {
	      if($this->RAYS->row($r)->[0] == 0) {
		$directionalRays += $r;
	      }
	      else {
		$affineRays += $r;
	      }
	    }
	    
	    #Now we prepare the new maximal cones and codimension one cones by simply copying all the rows with x0 = 1
	   
	    $cmplxrays = $cmplxrays / $this->RAYS->minor($affineRays,All);
	   
	    for(my $co = 0; $co < $this->CODIM_1_FACES->rows(); $co++) {
	      $codimone[$co] = $this->CODIM_1_FACES->row($co) * $affineRays; #Intersect rays of cone with directional rays
	    }
	    for(my $mc = 0; $mc < $this->MAXIMAL_CONES->rows(); $mc++) {
	      $maxcones[$mc] = $this->MAXIMAL_CONES->row($mc) * $affineRays;
	    }
	    
	    #Now we go through the directional rays and compute the corresponding connected components for each one
	    for my $r (@{$directionalRays}) {
	      
	      my @connectedComponents = (); #Array of set of indices of maximal cones
	      my @conesInComponents = (); #Array of indices of connected components, element i = component of maximal cone i
		
	      #Compute the set of maximal cones containing $r
	      my @rcones = (); #Array of indices of maximal cones
	      for my $mc ( 0 .. ($this->MAXIMAL_CONES->rows()-1) ) {
		if($this->MAXIMAL_CONES->row($mc)->contains($r)) {
		  @rcones = (@rcones,$mc);
		}
	      }
	      
	      for my $cic (@rcones) { $conesInComponents[$cic] = -1;}
	      
	      #For each maximal cone compute its component (it it hasn't been computed yet) 
	      for my $mc ( @rcones ) {
		if($conesInComponents[$mc] == -1) { #If the cones is not yet in a connected component, compute it
		  #Create new component
		  my $newindex = scalar(@connectedComponents);
		  $connectedComponents[$newindex] = new Set<Int>($mc);
		  $conesInComponents[$mc] = $newindex;
		  #Breadth-first search for all other elements in the component
		  my @queue = ($mc); #Semantics: Elements in that queue have been added but their neighbours might not
		  while(scalar(@queue) != 0) {
		    #print "Queue is now ", join(",",@queue),"\n";
		    my $node = shift(@queue); #Take the first element and find its neighbours
		    for my $othercone (@rcones) {
			if($conesInComponents[$othercone] == -1) { #We only want homeless cones ;)
			    #This checks whether both cones share a ray with x0 = 1
			    if( ($this->MAXIMAL_CONES->row($node) * $this->MAXIMAL_CONES->row($othercone) * $affineRays)->size() > 0) {
			      $connectedComponents[$newindex] += $othercone;
			      $conesInComponents[$othercone] = $newindex;
			      @queue = (@queue,$othercone);
			      
			    }
			}
		    }
		  }
		}
	      }
	      
	      # Now add $r once for each connected component to the appropriate cones
	      for my $cc (@connectedComponents) {
		$cmplxrays = $cmplxrays / $this->RAYS->row($r);
		my $rowindex = $cmplxrays->rows()-1;
		for my $mc (@{$cc}) {
		  $maxcones[$mc] = $maxcones[$mc] + $rowindex;
		  #For each facet of $mc that contains $r, add $rowindex
		  for my $fct (@{transpose($this->CODIM_1_IN_MAXIMAL_CONES)->row($mc)}) {
		    if($this->CODIM_1_FACES->row($fct)->contains($r)) {
		      $codimone[$fct] = $codimone[$fct] + $rowindex;
		    }
		  }
		}
	      }
	      
	    }
	    
	    #Insert values
	    $this->CMPLX_RAYS = $cmplxrays;
	    $this->CMPLX_MAXIMAL_CONES = new IncidenceMatrix(@maxcones);
	    $this->CMPLX_CODIM_1_FACES = new IncidenceMatrix(@codimone);
	  
	  }
	}
	
	## METHODS #################################################################
	
	# @category Basic properties
	# This computes the dimension of the fan in the following way: If the fan has rays, it simply
	# calls DIM, otherwise it returns LINEALITY_DIM.
	# FIXME: This is a fix for the problem that a fan only defined with lineality space will have 'dimension 0'
	# (Actually, if we didn't give any ray, not even [0,..0], it will break and start filling up the RAM)
	# So we should delete this function when this is fixed.
	user_method dim_fix {
	  my $this = shift;
	  my $ir = $this->lookup("INPUT_RAYS");
	  if(defined($this->lookup("RAYS"))) {
	    if($this->RAYS->rows() > 0) {
	      return $this->DIM;
	    }
	  }
	  return $this->LINEALITY_DIM;
	}
	
	# @category Basic properties
	# This computes the ambient dimension in the following way: If the fan has rays, it simply
	# calls AMBIENT_DIM, otherwise it returns LINEALITY_SPACE->cols().
	# FIXME: This is a fix for the problem that a fan only defined with lineality space will have 'ambient dimension 0'
	# (if I give INPUT_RAYS=>[])
	# So we should delete this function when this is fixed.
	user_method ambient_dim_fix {
	  my $this = shift;
	  my $ir = $this->lookup("INPUT_RAYS");
	  if(defined($ir)) {
	    if($ir->cols() == 0) {
	      return $this->LINEALITY_SPACE->cols();
	    }
	  }
	  return $this->AMBIENT_DIM;
	}
	
	# @category Tropical methods
	# Convenience method, returns LATTICE_NORMALS->[i]->[j]
	# @param Int i The index of the facet
	# @param Int j The index of the maximal cone
	# @return The lattice normal vector of cone j wrt. facet i
	user_method lattice_normal {
	    my $this = shift;
	    my $i = shift;
	    my $j = shift;
	    
	    return $this->LATTICE_NORMALS->{$i}->{$j};
	}
	
	# @category Linear algebra
	# This method takes a set of row indices for [[RAYS]] (or [[CMPLX_RAYS]] in the homogeneous case) and a vector that is supposed to be 
	# in the span of these row vectors and the lineality space (or their affine space, see description of [[LATTICE_NORMAL_FCT_VECTOR]]). 
	# It then computes the corresponding represenation in these vectors
	# @param Set s A set of row indices of [[RAYS]]
	# @param Vector v A vector supposed to lie in the span (or affine span) of RAYS + LINEALITY_SPACE
	# @return A vector of length N_RAYS + LINEALITY_DIM (or [[CMPLX_RAYS->rows()]] + LINEALITY_DIM in the homog. case) 
	# with linear coefficients of a representation in the generators chosen via s (The last elements always refer to the lineality space).
	user_method functionRepresentationVector {
	  my ($this,$r,$v) = @_;
	  my @rowIndices = @{$r};
	  $v = new Vector<Rational>($v);
	  #Matrix of generators 
	  my $m = new Matrix<Rational>(0,$this->AMBIENT_DIM);
	  #First ray with x0 = 1 (not used if we use nonhomog. coords)
	  #The index refers to thw row index in $m
	  my $basepoint = -1;
	  
	  #Compute matrix of generators
	  for(my $ray = 0; $ray < scalar(@rowIndices); $ray++) {
	    my $rayVector = $this->USES_HOMOGENEOUS_C ?   $this->CMPLX_RAYS->row($rowIndices[$ray]) :
							  $this->RAYS->row($rowIndices[$ray]);
	    #Ensure that $rayVector has the right dimension if it is just the empty vector
	    #(it might come from the zero point)
	    if($rayVector->dim() == 0) {
	      $rayVector = new Vector<Rational>(zero_vector<Rational>($this->AMBIENT_DIM));
	    }
	    if($rayVector->[0] == 0) { #Add all x0 = 0-vectors as is
	      $m = $m / $rayVector;
	    }
	    else {		#Otherwise use relative differences if we are in the homog. case
	      if(!($this->USES_HOMOGENEOUS_C)) { 
		$m = $m / $rayVector;
	      }
	      else {
		if($basepoint == -1) { 
		    $basepoint = $ray;
		    $m = $m / $rayVector;
		} 
		else {
		  $m = $m / ( $rayVector - $m->row($basepoint));
		}
	      }
	    }
	  }
	  $m = $m / $this->LINEALITY_SPACE;
	  #If there were no row indices, i.e. m = 0-space, just enter a zero row
	  if(scalar(@rowIndices) == 0) {
	      $m = new Matrix<Rational>(zero_vector<Rational>($this->AMBIENT_DIM));
	  }
	  
	  #print "v = ", $v, "\nm = \n", $m,"\n";
	  
	  #Now compute the representation
	  my $repv = tropical::linearRepresentation($v,$m);
	  
	  #print "r = ", $repv, "\n";
	  
	  my @rep = @{$repv};
	  if(scalar(@rep) == 0) {
	    die "Error: vector not in linear span of generators";
	  }
	  
	  #Insert coefficients at correct place
	  my $size = $this->LINEALITY_DIM + ($this->USES_HOMOGENEOUS_C? $this->CMPLX_RAYS->rows() : $this->N_RAYS);
	  my @repVector;
	    for(my $index = 0; $index < $size; $index++) {
	      $repVector[$index] = 0;
	    }
	  my $minussum = 0;
	  for( my $ray = 0; $ray < scalar(@rowIndices); $ray++) { #Insert all values for non-basepoint x0=1-rays and all x0=0-rays
	    if($ray != $basepoint) {
	      my $rayVector = $this->USES_HOMOGENEOUS_C ?   $this->CMPLX_RAYS->row($rowIndices[$ray]) :
							  $this->RAYS->row($rowIndices[$ray]);
	      $repVector[$rowIndices[$ray]] = $rep[$ray];
	      if($rayVector->[0] != 0) {
		$minussum -= $rep[$ray];
	      }
	    }
	  }
	  
	  if($basepoint != -1) {
	    $repVector[$rowIndices[$basepoint]] = $minussum; #In the homogeneous case store the negative sum of all x0=1-coeffs at basepoint
	  }
	  for( my $lingen = 0; $lingen < $this->LINEALITY_DIM; $lingen++) { #Insert lin space coeffs at the end
	    $repVector[$this->N_RAYS + $lingen] = $rep[scalar(@rowIndices) + $lingen];
	  }
	  
	  #Note that the correct dimension of this vector is assured by the fact that we put the lineality
	  #space coefficients at the end.
	  return new Vector<Rational>(@repVector); 
	  
	}
}