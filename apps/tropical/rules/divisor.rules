#######################################################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file defines the functionality necessary to define divisors on tropical varieties
########################################################################################################


USE fan polytope

# @category Tropical geometry
# Takes as input a tropical fan / tropical variety and an array of rational values. The array length should coincide 
# with the number of [[CMPLX_RAYS]] of the fan plus the dimension of the lineality space and will be interpreted as a rational
# function, where each value has been assigned to the rays given by $fan->CMPLX_RAYS and to the generators given by $fan->LINEALITY_SPACE  
# (in that order). Missing values will be filled up by 0's, superfluous ones will be ignored. 
# The function will then compute the corresponding Weil divisor and return it as a 
# tropical variety given as a fan. The fan uses homogeneous coordinates, if and only the input fan does.
# @param fan::PolyhedralFan A tropical variety on which the divisor is computed. 
# @param values An array of rational values that define an integer affine map on the fan. 
# @return The divisor of the function defined by values on the given fan, as a tropical variety.
user_function divisorByValue {
  my ($fan,@values) = @_;
  return divisorByValueVector($fan,new Vector<Rational>(@values));
}

# @category Tropical geometry
# Computes the divisor of a PLFunction on a given tropical variety. The result will be in homogeneous coordinates, whether 
# the tropical variety uses them or not. The function should be given on the affine coordinates of the variety, NOT the 
# homogeneous ones.
# @param fan::PolyhedralFan fan A tropical variety, on which the divisor is computed
# @param PLFunction A function whose DOMAIN should be equal to the affine coordinate space of the variety, i.e. AMBIENT_DIM-1, if the
# variety uses homogeneous coordinates, AMBIENT_DIM otherwise.
# @return The corresponding divisor as a tropical variety in homogeneous coordinates.
# user_function divisorByPLF {
#   my ($fan,$function) = @_;
#   
#   #First, refine the (homogenized) fan along the linearity domains of the function
#   $fan = $fan->homogenize;
#   $fan = intersect_complete_fan($fan,$function->linearityDomains);
#   
#   #Now compute the function values
#   my $crays = $fan->CMPLX_RAYS;
#   my @mcones = @{$fan->CMPLX_MAXIMAL_CONES};
#   my @values = ();
#   #First we divide the set of rays into those with x0 != 0 and those with x0 = 0
#   my $affineRays = new Set<Int>();
#   my $directionalRays = new Set<Int>();
#   for(my $r = 0; $r < $crays->rows(); $r++) {
#     if($crays->row($r)->[0] == 0) {
#       $directionalRays += $r;
#     }
#     else {
#       $affineRays += $r;
#     }
#   }
#   
#   for my $index (0 .. $crays->rows()-1) {
#     #If it is an affine ray, simple compute the function value at that point
#     if($crays->row($index)->[0] == 1) {
#       @values = (@values,$function->valueAt($crays->row($index)));
#     }
#     # Otherwise find an affine ray that shares a maximal cone with this ray (if there is none, set the value to 0, it
#     # doesn't matter anyway)
#     else {
#       my $rayvalue = new Rational(0);
#       for my $mc (@mcones) {
# 	if($mc->contains($index)) {
# 	  my $sharedRays = $mc * $affineRays;
# 	  if($sharedRays->size() > 0) {
# 	    #If we have found such an affine ray, compute the value of affine + direction and substract the value of the affine ray
# 	    # and stop searching
# 	    my $sray = $sharedRays->[0];
# 	    $rayvalue = $function->valueAt($crays->row($sray) + $crays->row($index)) - $function->valueAt($crays->row($sray));
# 	    last;
# 	  }
# 	}
#       }
#       @values = (@values,$rayvalue);
#     }
#   }
#   
#   #Finally we add the values of the lineality space
#   for my $index (0 .. $fan->LINEALITY_SPACE->rows()-1) {
#     @values = (@values, $function->valueAt($fan->LINEALITY_SPACE->row($index)));
#   }
#   
#   return divisorByValue($fan,@values);
# }