########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file contains functionality to compute intersection products
########################################################################

# @category Tropical geometry
# Computes the intersection product of two tropical cycles in a common ambient vector space V.
# @param fan::PolyhedralFan X The first tropical variety
# @param fan::PolyhedralFan Y The second tropical variety. Should have the same actual ambient dimension (homogeneous coordinates don't count) as X.
# @return fan::PolyhedralFan Z The intersection product X*Y in V = R^n, where n is the ambient dimension of X and Y. The result has homogeneous coordinates, if and only if X or Y has homog. coordinates.
user_function cycle_intersection {
  my ($X,$Y) = @_;
  
  #Compute the cross product
  my $Z = fan::product_complex( $X,$Y);
  
  #Compute the diagonal divisor on the cross product
  my $ad = $X->CMPLX_AMBIENT_DIM;
  my @psi = diagonal_functions($ad);
  for my $f (@psi) {
    $Z = divisorByPLF($Z,$f);
  }
  
  #Then project
  my $raymatrix = $Z->RAYS->minor(All,sequence(0,$Z->USES_HOMOGENEOUS_C? $ad+1 : $ad));
  my @cones = @{$Z->MAXIMAL_CONES};
  my @weights = @{$Z->TROPICAL_WEIGHTS};
  my $uses_homog = $Z->USES_HOMOGENEOUS_C;
  return new fan::PolyhedralFan( RAYS=>$raymatrix,MAXIMAL_CONES=>\@cones,TROPICAL_WEIGHTS=>\@weights,USES_HOMOGENEOUS_C=>$uses_homog);
  
  
}