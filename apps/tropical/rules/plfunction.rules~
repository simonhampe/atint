#######################################################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011, Simon Hampe <hampe@mathematik.uni-kl.de>
#
# This file creates a data type for piecewise linear functions on R^n. They are created simply by providing 
# the property STRING. The function is then parsed from this string. Every such function is supposed to be 
# of the form max(f_1,..,f_k) or min(f_1,...,f_k), where each f_i is an affine linear function from R^n to R.
# Such a function can be created in the following ways:
# 1) Specifying [[INPUT_STRING]] and (optionally) [[INPUT_VARS]]. [[INPUT_STRING]] is a string representing the
# function (the syntax is specified in the documentation of this property). [[INPUT_VARS]] is an array of strings representing
# the variables. If this is not given, the variables (and hence the domain of the function) are automatically detected.
#
# 2) Directly specifying the linear coefficient matrix [[LINEAR_COEFFICIENTS]] and the [[CONSTANT_COEFFICIENTS]], together
# with [[USES_MIN]] (This is optional, if you don't specify it, FALSE is the default value)
########################################################################################################

object PLFunction {
  
  ## PROPERTIES ###################################################################################################
  
  # @category Basic properties
  # The syntax for STRING in pseudo-regex is the following (after deleting any whitespace): 
  # "(min|max)\((SUM)+(,SUM)*\)"
  # where SUM = "(TERM)+([\+\-](TERM))*"
  # where TERM = (RAT)|(RAT[:alpha:][^\+,\)]*)
  # where RAT is any string that can be parsed to a polymake Rational and does not contain any letters.
  # To make this more comprehensible: STRING takes anything of the form min(...) or max(...), 
  # where ... is a comma-separated list of strings of the form a + bx + cy + ... , where a,b,c are rational 
  # numbers and x,y are variables. Any string that starts with a letter and does not contain "+" or "," can be 
  # a variable. Such a sum can contain several such terms for the same variable and they need not be in any order.
  # A term can be of the form "3x", "3*x", but "x3" will be interpreted as 1 * "x3". Coefficients should not contain letters,
  # i.e. 3E10*x would be interpreted as 3 * "E10*x". Empty terms are allowed.
  # If no INPUT_VARS are given, PLFunction will recognize the dimension of the domain from the number of variables and will
  # assign the variables to the standard basis vectors by sorting them alphabetically. 
  # E.g. INPUT_STRING=>"min(x+2z,3+z)",INPUT_VARS=>["x","y","z"] is a different function than INPUT_STRING=>"min(x+2z,3+z)",
  # since the second is the function f:R² -> R, (a,b) -> min(a+2b,3+b) and the first is f: R³->R, (a,b,c)->min(a+2c,3+c)
  # If however, [[INPUT_VARS]] is given, the parse will *ignore* any terms containing variables that are not 
  # defined in [[INPUT_VARS]]. The variables will be assigned to the standard basis vectors in order of their
  # appearance in [[INPUT_VARS]].
  # E.g. INPUT_STRING=>"min(x+2c,3+x)",INPUT_VARS=>["x","y"] will give the function f:R²->R, (a,b) -> min(a,3+a)
  # Note that ANY whitespace in [[INPUT_STRING]] is ignored.
  property INPUT_STRING : String;
  
  # @category Basic properties
  # A list of strings that are variables. Any string that starts with a letter (i.e. [a-zA-Z]) and does not contain
  # '+' or ',' can be a variable. Illegal variable names will not cause an error, but the parser will not detect them
  # in [[INPUT_STRING]], so their coefficients will be 0. If you assign a value to this, only terms with variables in 
  # this array will be parsed. Note that ANY whitespace in a variable name will be ignored. The i-th element of this array
  # will be assigned to the i-th standard basis vector.
  property INPUT_VARS : Array<String>;
  
  # This will give a nice string representation of the function, where all variables are of the form 'x_i',
  # i = 1,..,[[DOMAIN]]. There are no redundancies and terms are sorted in ascending alphabetic order of their variable,
  # with the constant term at the end
  property STANDARD_FORM : String;
  
  # Indicates whether this function uses min (TRUE) or max (FALSE). The default (if you directly give a coefficient matrix,
  # but not this value) is FALSE
  property USES_MIN : Bool;
  
  # The dimension n of the domain R^n of the function. Is equal to the columns of [[LINEAR_COEFFICIENTS]]
  property DOMAIN : Int;
  
  # A matrix of the linear coefficients of the functions. Each row corresponds to a linear function within
  # the min or max and the entry in column j is the coefficient of variable x_j
  property LINEAR_COEFFICIENTS : Matrix<Scalar>;
  
  # A vector of the constant coefficients of the function. The i-th entry is the constant term of the function 
  # represented by the i-th row of [[LINEAR_COEFFICIENTS]].
  property CONSTANT_COEFFICIENTS : Vector<Scalar>;
  
  ## RULES ###################################################################################################
  
  rule USES_MIN, LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS : INPUT_STRING {
      #Make a copy of [[INPUT_STRING]] for parsing
      my $string = $this->INPUT_STRING;
      $string =~ s/\s+//g; #Remove any whitespace before parsing
      
      #If [[INPUT_VARIABLES]] exists, make a copy and remove whitespace
      my $vars = $this->lookup("INPUT_VARS");
      my @vararray;
      if(defined($vars)) {
	@vararray = @{$vars};
	if(scalar(@vararray) == 0) {
	  die "Error: Domain dimension must be at least 1";
	}
	for my $v (@vararray) {
	  $v =~ s/\s+//g;
	}
	print "Variables are ",join(",",@vararray),"\n";
      }
            
      #First separate min/max from the list of the functions (without brackets)
      my @separator = ($string =~ /^(max|min)\((.+)\)$/i);
      if(scalar(@separator) == 2) {
	
	my $minmax = $separator[0];
	my @functionlist = split(/,/,$separator[1]);
	
	print "Function list is ", join(",",@functionlist),"\n";
	
	#Determine wheter function uses min or max
	if($minmax =~ /^min$/i) {
	  $this->USES_MIN = TRUE;
	}
	else {
	  $this->USES_MIN = FALSE;
	}
	
	# These maps are used to store the coefficients of the functions. The i-th element corresponds to the i-th function.
	# It is a reference to a hash mapping variable names to coefficients
	my @lincoeff = ();
	
	#In this array we store the constant coefficient of each function.
	my @constants = ();
	
	#Now parse every single function by splitting at "+"
	for my $index (0 .. scalar(@functionlist)-1) {
	  # Initialize coefficient (maps) 
	  my %functionCoeffMap = ();
	  
	  $constants[$index] = 0;
	  
	  my @termlist = split(/[\+\-]/,$functionlist[$index]);
	  #Also read off signs - the following array has by definition exactly 
	  
	  print "Terms of function ", $functionlist[$index], " are ", join(",",@termlist),"\n";
	  
	  #Parse every single term
	  for my $term (@termlist) {
	      my @termsep = ($term =~ /^([^a-zA-Z\*])?\*?([a-zA-Z]+.*)?$/);
	      if(scalar(@termsep) != 2) {
		die "Invalid term: ", $term;
	      }
	      
	      #If both parts are empty, go to the next term
	      if($termsep[0] eq "" && $termsep[1] eq "") {
		next;
	      }
	      
	      #Parse the coefficient (if there is no coefficient, set it to 1)
	      my $coefficient = new Rational($termsep[0] eq ""? 1 : $termsep[0]);
	      
	      #If there is no variable, add up the constant coefficient, otherwise add up the corr. linear coefficient
	      if($termsep[1] eq "") {
		$constants[$index] += $coefficient;
	      }
	      else {
		#Add the variable, if there are no [[INPUT_VARS]] (at this point we don't care about doubles)
		if(!defined($vars)) {
		  @vararray = (@vararray,$termsep[1]);
		}
		#If there is no coefficient value for the variable yet, set it to coefficient, otherwise add the coefficient
		if(!defined($functionCoeffMap{$termsep[1]})) {
		  $functionCoeffMap{$termsep[1]} = $coefficient;
		}
		else {
		  $functionCoeffMap{$termsep[1]} += $coefficient;
		}
	      }
	      
	  }#end parse all terms
	  
	  $lincoeff[$index] = \%functionCoeffMap;
	}#end parse all functions
	
	#Copy constant coefficients
	$this->CONSTANT_COEFFICIENTS = new Vector<Rational>(@constants);
	
	print "Constant coefficients are ", $this->CONSTANT_COEFFICIENTS,"\n";
	
	#If [[INPUT_VARS]] is not given, remove double variables and sort them alphabetically
	if(!defined($vars)) {
	  @vararray = sort(@{new Set<String>(@vararray)});
	  if(scalar(@vararray) == 0) {
	    die "Error: Domain dimension must be at least 1";
	  }
	}
	
	print "Variables are ", join(",",@vararray),"\n";
	
	#Now copy the linear coefficients
	my $m = new Matrix<Rational>(0, scalar(@vararray));
	#Go through all functions
	for my $index (0 .. scalar(@functionlist)-1) {
	    my $hashref = $lincoeff[$index];
	    my %h = %$hashref;
	    my @row = ();
	    #Go through all variables
	    for my $v (@vararray) {
	      @row = (@row,(defined($h{$v})? $h{$v} : 0));
	    }
	    print "Coefficient row is ", join(",",@row),"\n";
	    $m = $m / new Vector<Rational>(@row);
	}
	$this->LINEAR_COEFFICIENTS = $m;
	
      } #endif check basic form
      else {
	die "Invalid syntax for piecewise linear function.";
      }
  }#End rule LINEAR_COEFFICIENTS, CONSTANT_COEFFICIENTS, USES_MIN
  

      
  
  
  ## METHODS #################################################################################################
  
  ## FUNCTIONS ###################################################################################################
  
}