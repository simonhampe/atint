########################################################################
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA  02110-1301, USA.
#  
#  ---
#  Copyright (C) 2011-2015, Simon Hampe <simon.hampe@googlemail.com>
#
#
#  Defines properties and rules for RationalFunction 
########################################################################


object RationalFunction {
	
	use overload('*' => 'mult','""' => 'to_string', 'bool' => 'bool','^' => 'power_operator', '+' => 'sum','-' => 'minus','neg'=>'neg');

	# @category Defining morphisms and functions
	# This property describes the affine linearity domains of the function. I.e. the function is
	# affine integral linear on each maximal polytope of [[DOMAIN]]. 
	property DOMAIN : Cycle<Addition>; 

	# @category Defining morphisms and functions
	# The value at index i describes the function value at [[DOMAIN]]->SEPARATED_VERTICES->row(i). 
	# More precisely, if the corresponding vertex is not a far ray, it describes its function value. 
	# If it is a directional ray, it describes the slope on that ray.
	property VERTEX_VALUES : Vector<Rational>;

	# @category Defining morphisms and functions 
	# The value at index i describes the function value of [[DOMAIN]]->LINEALITY_SPACE->row(i)
	property LINEALITY_VALUES : Vector<Rational>; 

	# @category Defining morphisms and functions
	# When representing the function as a quotient of tropical polynomials, this
	# is the numerator. Should be a homogeneous polynomial of the same degree as [[DENOMINATOR]].
	property NUMERATOR : Polynomial<TropicalNumber<Addition> >;

	# @category Defining morphisms and functions
	# When representing the function as a quotient of tropical polynomials, this
	# is the denominator. Should be a homogeneous polynomial of the same degree as [[NUMERATOR]]. 
	property DENOMINATOR : Polynomial<TropicalNumber<Addition> >;


	# @category Defining morphisms and functions
	# This is an internally used property that should not actually be set by the user. When creating a
	# rational function with the ^-operator, this property is set to the exponent. 
	# The semantics is that when computing a divisor, this function should be applied so many times
	# The usual application of this is a call to divisor($X, $f^4) or something similar.
	# Warning: This property is not stored if the RationalFunction object is saved. Nor should be assumed
	# to be preserved during any kind of arithmetic or restricting operation.
	property POWER : Int : non_storable;

	## RULES ###################

	rule POWER : {
		$this->POWER = 1;
	}

	rule DOMAIN : NUMERATOR, DENOMINATOR {
		computeDomain($this);
	}

	rule VERTEX_VALUES, LINEALITY_VALUES : DOMAIN, NUMERATOR, DENOMINATOR {
		computeGeometricFunctionData($this);
	}
	precondition : NUMERATOR, DENOMINATOR {
		$this->NUMERATOR != (new Polynomial<TropicalNumber<Addition> >($this->NUMERATOR->get_ring)) 
			or die "Numerator cannot be the zero polynomial.";
		polynomial_degree($this->NUMERATOR) == polynomial_degree($this->DENOMINATOR) 
			or die "Both numerator and denominator must have the same degree";
		is_homogeneous($this->NUMERATOR) or die "Numerator must be homogeneous";
		is_homogeneous($this->DENOMINATOR)  or die "Denominator must be homogeneous";
	}

	# Changes the power of the function
	method to_the_power_of {
		my ($this,$k) = @_;
		if($k < 0) {
			die "Illegal function power. Must be >= 0.";
		}
		if(defined($this->lookup("NUMERATOR"))) {
			if(defined($this->lookup("DOMAIN"))) {
				return new RationalFunction<Addition>(NUMERATOR=>$this->NUMERATOR, DENOMINATOR=>$this->DENOMINATOR,
						DOMAIN=>$this->DOMAIN, POWER=>$k);
			}
			else {
				return new RationalFunction<Addition>(NUMERATOR=>$this->NUMERATOR, DENOMINATOR=>$this->DENOMINATOR,
						POWER=>$k);
			}
		}
		return new RationalFunction<Addition>(DOMAIN=>$this->DOMAIN, VERTEX_VALUES=>$this->VERTEX_VALUES,
							LINEALITY_VALUES=>$this->LINEALITY_VALUES,POWER=>$k);
	}

	## OPERATORS ########
	
	sub power_operator {
		my ($f,$k) = @_;
		return $f->to_the_power_of($k);
	}

	sub bool {
		my $this = shift;
		return !undef($this);
	}

	sub to_string {
		my $this = shift;
		if(defined($this->lookup("NUMERATOR"))) {
			return "(".$this->NUMERATOR.") / (".$this->DENOMINATOR.")";
		}
		else {
			return "Rational function on ".$this->DOMAIN->description();
		}
	}

	sub sum {
		my ($f,$g) = @_;
		if(!is_compatible($f,$g)) {
			die "Rational functions use different tropical additions.";
		}
		if(defined($f->lookup("NUMERATOR")) && defined($g->lookup("NUMERATOR"))) {
			return new RationalFunction<Addition>(NUMERATOR=>($f->NUMERATOR * $g->NUMERATOR),
				DENOMINATOR=>($f->DENOMINATOR * $g->DENOMINATOR));
		}
		else {
			return add_rational_functions($f,$g);
		}
	}

	sub minus {
		my ($f,$g) = @_;
		return sum($f, (-1)*$g);
	}

	#FIXME: Still need tropical sum?

	#Multiply by an integer
	sub mult {
		my ($this,$r) = @_;
		if($r == 0) {
			my $zero;
			my $ring;
			if(defined($this->lookup("NUMERATOR"))) {
				$ring = $this->NUMERATOR->get_ring();
			}
			else {
				$ambient_dim = $this->DOMAIN->FAN_AMBIENT_DIM;
				my $ring = new Ring<TropicalNumber<Addition> >($ambient_dim);
			}
			$zero = new Polynomial<TropicalNumber<Addition> >( 
				(new TropicalNumber<Addition>(0)),$ring);
			return new RationalFunction<Addition>(NUMERATOR=>$zero,DENOMINATOR=>$zero);
		}
		if(defined($this->lookup("NUMERATOR"))) {
			my $num = new Polynomial<TropicalNumber<Addition> >($this->NUMERATOR);
			my $den = new Polynomial<TropicalNumber<Addition> >($this->DENOMINATOR);
			my $power = $r < 0? -$r : $r;
			for my $i (1 .. $power-1) {
				$num *= $num;
				$den *= $den;
			}
			return new RationalFunction<Addition>(NUMERATOR=>($r > 0? $num : $den), DENOMINATOR=>($r > 0? $den : $num));
		}
		else {
			return new RationalFunction<Addition>(DOMAIN=>$this->DOMAIN,VERTEX_VALUES=>$r*($this->VERTEX_VALUES),
							LINEALITY_VALUES=>$r*($this->LINEALITY_VALUES));
		}
	}

	sub neg {
		my $f = shift;
		return mult($f,-1);
	}


}

# @category Affine and projective coordinates
# This takes a tropical polynomial defined on tropical affine coordinates and turns it into 
# a rational function on tropical homogeneous coordinates
# @param Polynomial<TropicalNumber<Addition> > p A polynomial on affine coordinates.
# @param Int chart The index of the homogenizing coordinate. 0 by default.
# @tparam Addition Min or Max
# @return RationalFunction A rational function, which on the given chart is described by p.
user_function rational_fct_from_affine_numerator<Addition>(Polynomial<TropicalNumber<Addition> >; $=0) {
	my ($p,$chart) = @_;
	return homogenize_quotient($p,
		(new Polynomial<TropicalNumber<Addition> >( (new TropicalNumber<Addition>(0)),$p->get_ring())),
		$chart);	
}

# @category Affine and projective coordinates
# Same as [[rational_fct_from_affine_numerator]](Polynomial), except that it takes
# a string which it converts to a tropical polynomial using [[toTropicalPolynomial]].
# @param String p A string that will be converted to a tropical polynomial
# @param Int chart The index of the homogenizing coordinate. 0 by default.
# @tparam Addition Min or Max
# @return RationalFunction 
user_function rational_fct_from_affine_numerator(String; $=0) {
	my ($s,$chart) = @_;
	return rational_fct_from_affine_numerator(toTropicalPolynomial($s),$chart);
}

# @category Affine and projective coordinates
# This takes a tropical polynomial p defined on tropical affine coordinates and turns it into 
# the rational function (1/p) on tropical homogeneous coordinates
# @param Polynomial<TropicalNumber<Addition> > p A polynomial on affine coordinates.
# @param Int chart The index of the homogenizing coordinate. 0 by default.
# @tparam Addition Min or Max
# @return RationalFunction A rational function, which on the given chart is described by (1/p).
user_function rational_fct_from_affine_denominator<Addition>(Polynomial<TropicalNumber<Addition> >; $=0) {
	my ($p,$chart) = @_;
	return homogenize_quotient(
		(new Polynomial<TropicalNumber<Addition> >( (new TropicalNumber<Addition>(0)),$p->get_ring())),
		$p,
		$chart);	
}

# @category Affine and projective coordinates
# Same as [[rational_fct_from_affine_denominator]](Polynomial), except that it takes
# a string which it converts to a tropical polynomial using [[toTropicalPolynomial]].
# @param String p A string that will be converted to a tropical polynomial
# @param Int chart The index of the homogenizing coordinate. 0 by default.
# @tparam Addition Min or Max
# @return RationalFunction 
user_function rational_fct_from_affine_denominator(String; $=0) {
	my ($s,$chart) = @_;
	return rational_fct_from_affine_denominator(toTropicalPolynomial($s),$chart);
}
