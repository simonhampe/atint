<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:pm="http://www.polymake.org/ns/docs#3" xml:lang="en" lang="en">
  <head>
    <title>polymake documentation</title>
    <link rel="stylesheet" href="docstyle.css" />
    <script type="text/javascript" src="functions.js"></script>
    <link rel="stylesheet" href="style.css" type="text/css" media="all" />
    <link rel="shortcut icon" href="favicon.png" />
    <meta http-equiv="content-script-type" content="text/javascript" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body onload="start()">
    <div id="header_top">
      <div class="biglogo">
        <img src="images/pmlogobig.png" alt="polymake" />
      </div>
      <a href="index.html">
        <img src="images/doclogo.png" alt="polymake wiki" class="toplogo" />
      </a>
    </div>
    <div id="container">
      <div id="page">
        <div class="sidebar">
          <div class="sidebox">
            <h1>Navigation</h1>
            <ul>
              <li>
                <a href="index.html#apps">applications</a>
              </li>
              <li>
                <a href="core.html">core functionality</a>
              </li>
              <li>
                <a href="doc_index.html">index</a>
              </li>
              <li>
                <a href="extensions.html">extensions</a>
              </li>
            </ul>
          </div>
        </div>
        <div xmlns="" id="content"><h1>application: tropical</h1><div class="descr"><p> This application concentrates on <a href="#Hypersurface" onclick="unfold('span:Hypersurface');">tropical hypersurfaces</a> and <a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">tropical polytopes</a>.
 It provides the functionality for the computation of basic properties. Visualization and various constructions are possible.</p></div><b>imports from: </b><a href="common.html">common</a>, <a href="graph.html">graph</a><br /><b>uses: </b><a href="fan.html">fan</a>, <a href="group.html">group</a>, <a href="ideal.html">ideal</a>, <a href="matroid.html">matroid</a>, <a href="polytope.html">polytope</a>, <a href="topaz.html">topaz</a><br /><div class="level2"><h2><b>Objects</b></h2><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Cycle" onclick="swap_content('span:Cycle'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="Cycle" onclick="swap_content('span:Cycle'); return false;"><span class="object">Cycle</span></a></h3></div><div style="display: inline" id="span:Cycle" class="foldit"><div class="descr"><p> A tropical cycle is a weighted, balanced, pure polyhedral complex.
 It is given as a polyhedral complex in tropical projective coordinates.
 To be precise: Each row of <a href="#" onclick="unfold('span:');">VERTICES</a> and <a href="#" onclick="unfold('span:');">LINEALITY_SPACE</a> 
 has a leading 1 or 0, depending on whether it is a vertex or a ray. 
 The remaining n coordinates are interpreted as an element of
 R<sup>n</sup> modulo (1,..,1). 
 Note that there is a convenience method <a href="#thomog" onclick="unfold('span:thomog');">thomog</a>, which converts affine coordinates 
 into projective coordinates.
 Its template parameter is the tropical addition.
 Warning: There is NO default for this, you have to choose either Max or Min.</p></div><b>derived from: </b>fan::PolyhedralComplex&lt;Rational&gt;<br /><div class="level3"></div><h4>Properties of Cycle</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Cycle__properties__Affine_and_projective_coordinates" onclick="swap_content('span:Cycle__properties__Affine_and_projective_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Affine_and_projective_coordinates" onclick="swap_content('span:Cycle__properties__Affine_and_projective_coordinates'); return false;"><span class="category">Affine and projective coordinates</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Affine_and_projective_coordinates" class="foldit"><div class="descr"><p> These properties deal with affine and projective coordinates, conversion between those 
 and properties like dimension that change in projective space.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__PROJECTIVE_AMBIENT_DIM" onclick="swap_content('span:Cycle__PROJECTIVE_AMBIENT_DIM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__PROJECTIVE_AMBIENT_DIM" onclick="swap_content('span:Cycle__PROJECTIVE_AMBIENT_DIM'); return false;"><b>PROJECTIVE_AMBIENT_DIM</b>:
		</a>common::Int<br /><div style="display: inline" id="span:Cycle__PROJECTIVE_AMBIENT_DIM" class="foldit"><div class="descr"><p> This is the ambient projective dimension, i.e. it is
 <a href="#" onclick="unfold('span:');">FAN_AMBIENT_DIM</a>-2.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__PROJECTIVE_CODIMENSION" onclick="swap_content('span:Cycle__PROJECTIVE_CODIMENSION'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__PROJECTIVE_CODIMENSION" onclick="swap_content('span:Cycle__PROJECTIVE_CODIMENSION'); return false;"><b>PROJECTIVE_CODIMENSION</b>:
		</a>common::Int<br /><div style="display: inline" id="span:Cycle__PROJECTIVE_CODIMENSION" class="foldit"><div class="descr"><p> Codimension of the cycle. Same as <a href="#Cycle__PROJECTIVE_AMBIENT_DIM" onclick="unfold('span:Cycle__PROJECTIVE_AMBIENT_DIM');">PROJECTIVE_AMBIENT_DIM</a> - <a href="#Cycle__PROJECTIVE_DIM" onclick="unfold('span:Cycle__PROJECTIVE_DIM');">PROJECTIVE_DIM</a></p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__PROJECTIVE_DIM" onclick="swap_content('span:Cycle__PROJECTIVE_DIM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__PROJECTIVE_DIM" onclick="swap_content('span:Cycle__PROJECTIVE_DIM'); return false;"><b>PROJECTIVE_DIM</b>:
		</a>common::Int<br /><div style="display: inline" id="span:Cycle__PROJECTIVE_DIM" class="foldit"><div class="descr"><p> This is the projective dimension of the cycle.
 Alias for <a href="#" onclick="unfold('span:');" class="ambiguous">DIM</a>.</p></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__properties__Combinatorics" onclick="swap_content('span:Cycle__properties__Combinatorics'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Combinatorics" onclick="swap_content('span:Cycle__properties__Combinatorics'); return false;"><span class="category">Combinatorics</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Combinatorics" class="foldit"><div class="descr"><p> These properties capture combinatorial information of the object. 
 Combinatorial properties only depend on combinatorial data of the object like, e.g., the face lattice.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__CODIMENSION_ONE_POLYTOPES" onclick="swap_content('span:Cycle__CODIMENSION_ONE_POLYTOPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__CODIMENSION_ONE_POLYTOPES" onclick="swap_content('span:Cycle__CODIMENSION_ONE_POLYTOPES'); return false;"><b>CODIMENSION_ONE_POLYTOPES</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__CODIMENSION_ONE_POLYTOPES" class="foldit"><div class="descr"><p> Non-redundant list of all codimension one faces. Indices refer to
 <a href="#" onclick="unfold('span:');">VERTICES</a>. Does not include any far faces.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__FACET_NORMALS_BY_PAIRS" onclick="swap_content('span:Cycle__FACET_NORMALS_BY_PAIRS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__FACET_NORMALS_BY_PAIRS" onclick="swap_content('span:Cycle__FACET_NORMALS_BY_PAIRS'); return false;"><b>FACET_NORMALS_BY_PAIRS</b>:
		</a>common::Map&lt;Pair&lt;Int, Int&gt;, Int&gt;<br /><div style="display: inline" id="span:Cycle__FACET_NORMALS_BY_PAIRS" class="foldit"><div class="descr"><p> This maps an index pair (i,j), where i corresponds to the i-th row of <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a> and
 j to the j-th row of <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>, to the matching row number in <a href="#" onclick="unfold('span:');">FACET_NORMALS</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__MAXIMAL_AT_CODIM_ONE" onclick="swap_content('span:Cycle__MAXIMAL_AT_CODIM_ONE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__MAXIMAL_AT_CODIM_ONE" onclick="swap_content('span:Cycle__MAXIMAL_AT_CODIM_ONE'); return false;"><b>MAXIMAL_AT_CODIM_ONE</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__MAXIMAL_AT_CODIM_ONE" class="foldit"><div class="descr"><p> Incidence matrix of codimension one polytopes and maximal polytopes.
 Rows refer to <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>, columns to 
 <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>.</p></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__properties__Defining_morphisms_and_functions" onclick="swap_content('span:Cycle__properties__Defining_morphisms_and_functions'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Defining_morphisms_and_functions" onclick="swap_content('span:Cycle__properties__Defining_morphisms_and_functions'); return false;"><span class="category">Defining morphisms and functions</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Defining_morphisms_and_functions" class="foldit"><div class="descr"><p> These properties are used to define morphisms or rational functions on a Cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES" onclick="swap_content('span:Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES" onclick="swap_content('span:Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES'); return false;"><b>SEPARATED_CODIMENSION_ONE_POLYTOPES</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES" class="foldit"><div class="descr"><p> An incidence matrix describing which codimension one polytope in the complex is generated by which vertices. 
 Each row corresponds to a codimension one polytope (More precisely, the i-th element represents the
 same codim 1 polytope as the i-th element of <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>). The indices in a row refer 
 to rows of <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__SEPARATED_CONVERSION_VECTOR" onclick="swap_content('span:Cycle__SEPARATED_CONVERSION_VECTOR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__SEPARATED_CONVERSION_VECTOR" onclick="swap_content('span:Cycle__SEPARATED_CONVERSION_VECTOR'); return false;"><b>SEPARATED_CONVERSION_VECTOR</b>:
		</a>common::Vector&lt;Int&gt;<br /><div style="display: inline" id="span:Cycle__SEPARATED_CONVERSION_VECTOR" class="foldit"><div class="descr"><p> A vector with an entry for each row in <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>. 
 More precisely, the i-th entry gives the row index of the ray in <a href="#" onclick="unfold('span:');">VERTICES</a> 
 that is equal to the i-th row of <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__SEPARATED_MAXIMAL_POLYTOPES" onclick="swap_content('span:Cycle__SEPARATED_MAXIMAL_POLYTOPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__SEPARATED_MAXIMAL_POLYTOPES" onclick="swap_content('span:Cycle__SEPARATED_MAXIMAL_POLYTOPES'); return false;"><b>SEPARATED_MAXIMAL_POLYTOPES</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__SEPARATED_MAXIMAL_POLYTOPES" class="foldit"><div class="descr"><p> An incidence matrix describing which maximal polytope in the complex us generated by which rays. 
 Each row corresponds to a maximal polytope (More precisely, the i-th element represents the
 same maximal polytope as the i-th element of <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>). The indices in a row refer to rows 
 of <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>, i.e. the maximal polytope described by the i-th element is generated by 
 the vertices corresponding to these row indices.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__SEPARATED_VERTICES" onclick="swap_content('span:Cycle__SEPARATED_VERTICES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__SEPARATED_VERTICES" onclick="swap_content('span:Cycle__SEPARATED_VERTICES'); return false;"><b>SEPARATED_VERTICES</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__SEPARATED_VERTICES" class="foldit"><div class="descr"><p> This is a matrix of vertices of the complex. More precisely, each ray r from <a href="#" onclick="unfold('span:');">VERTICES</a> occurs  
 as a row in this matrix...
 - once, if r_0 = 1
 - k times, if r_0 = 0 and k is the number of equivalence classes of maximal cones 
 containing r with respect to the following relation:
 Two maximal cones m, m' containing r are equivalent, if they are equal or there exists a sequence 
 of maximal cones m = m_1,...m_r = m', such that r is contained in each m_i and each intersection 
 m_i cap m_i+1 contains at least one ray s with s_0 = 1.
 The reason for this is that, when for example specifying a piecewise affine linear function on a 
 polyhedral complex, the same far ray with x0 = 0 might be assigned two different values, if it is 
 contained in two "non-connected" maximal cones (where connectedness is to be understood as described above).
 If there is a <a href="#Cycle__LOCAL_RESTRICTION" onclick="unfold('span:Cycle__LOCAL_RESTRICTION');">LOCAL_RESTRICTION</a> the above equivalence relation is changed in such a 
 way that the affine ray s with s_0 = 1 that must be contained in the intersection of
 two subsequent cones must be a compatible ray</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__properties__Intersection_theory" onclick="swap_content('span:Cycle__properties__Intersection_theory'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Intersection_theory" onclick="swap_content('span:Cycle__properties__Intersection_theory'); return false;"><span class="category">Intersection theory</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Intersection_theory" class="foldit"><div class="descr"><p> These are general properties related to intersection theory.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__DEGREE" onclick="swap_content('span:Cycle__DEGREE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__DEGREE" onclick="swap_content('span:Cycle__DEGREE'); return false;"><b>DEGREE</b>:
		</a>common::Integer<br /><div style="display: inline" id="span:Cycle__DEGREE" class="foldit"><div class="descr"><p> The degree of the tropical variety, i.e. the weight of the intersection product with a
 uniform tropical linear space of complementary dimension.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__properties__Local_computations" onclick="swap_content('span:Cycle__properties__Local_computations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Local_computations" onclick="swap_content('span:Cycle__properties__Local_computations'); return false;"><span class="category">Local computations</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Local_computations" class="foldit"><div class="descr"><p> These properties are used for doing computations locally around a specified part of a Cycle.
-----
 These +++ deal with the creation and modification of cycles with nontrivial
 <a href="#Cycle__LOCAL_RESTRICTION" onclick="unfold('span:Cycle__LOCAL_RESTRICTION');">LOCAL_RESTRICTION</a>.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__LOCAL_RESTRICTION" onclick="swap_content('span:Cycle__LOCAL_RESTRICTION'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LOCAL_RESTRICTION" onclick="swap_content('span:Cycle__LOCAL_RESTRICTION'); return false;"><b>LOCAL_RESTRICTION</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__LOCAL_RESTRICTION" class="foldit"><div class="descr"><p> This contains a list of sets of ray indices (referring to <a href="#" onclick="unfold('span:');">VERTICES</a>). All of these sets should 
 describe polyhedra of the polyhedral complex (though not necessarily maximal ones).
 A polyhedron is now called compatible with this property, if it contains one of these polyhedra
 If this list is not empty, all computations will be done only on (or around) compatible cones. 
 The documentation of each property will explain in what way this restriction is enforced. 
 If this list is empty or not defined, there is no restriction.
 Careful: The implementation assumes that ALL maximal cones are compatible. If in doubt,
 you can create a complex with a local restriction from a given complex by using one of
 the "local_..." creation methods
 This list is assumed to be irredundant, i.e. there are no doubles (though this should not
 break anything, it is simply less efficient). It is, however, possible that one element
 is a subset of another.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__properties__Weights_and_lattices" onclick="swap_content('span:Cycle__properties__Weights_and_lattices'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__properties__Weights_and_lattices" onclick="swap_content('span:Cycle__properties__Weights_and_lattices'); return false;"><span class="category">Weights and lattices</span></a></h3></div><div style="display: inline" id="span:Cycle__properties__Weights_and_lattices" class="foldit"><div class="descr"><p> These properties relate to the weights of a tropical cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__BALANCED_FACES" onclick="swap_content('span:Cycle__BALANCED_FACES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__BALANCED_FACES" onclick="swap_content('span:Cycle__BALANCED_FACES'); return false;"><b>BALANCED_FACES</b>:
		</a>common::Vector&lt;Bool&gt;<br /><div style="display: inline" id="span:Cycle__BALANCED_FACES" class="foldit"><div class="descr"><p> A vector whose entries correspond to the rows of CODIMENSION_ONE_POLYTOPES. 
 The i-th entry is true, if and only if the complex is balanced at that face</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__IS_BALANCED" onclick="swap_content('span:Cycle__IS_BALANCED'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__IS_BALANCED" onclick="swap_content('span:Cycle__IS_BALANCED'); return false;"><b>IS_BALANCED</b>:
		</a>common::Bool<br /><div style="display: inline" id="span:Cycle__IS_BALANCED" class="foldit"><div class="descr"><p> Whether the cycle is balanced. As many functions in a-tint can 
 deal with non-balanced complexes, we include this as a property.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__IS_IRREDUCIBLE" onclick="swap_content('span:Cycle__IS_IRREDUCIBLE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__IS_IRREDUCIBLE" onclick="swap_content('span:Cycle__IS_IRREDUCIBLE'); return false;"><b>IS_IRREDUCIBLE</b>:
		</a>common::Bool<br /><div style="display: inline" id="span:Cycle__IS_IRREDUCIBLE" class="foldit"><div class="descr"><p> Whether this complex is irreducible.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_BASES" onclick="swap_content('span:Cycle__LATTICE_BASES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_BASES" onclick="swap_content('span:Cycle__LATTICE_BASES'); return false;"><b>LATTICE_BASES</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_BASES" class="foldit"><div class="descr"><p> This incidence matrix gives a lattice basis for each maximal polytope. More precisely it 
 gives a lattice basis whose span contains the lattice of the maximal polytope. Row i 
 corresponds to cone i and gives lattice generator indices referring to <a href="#Cycle__LATTICE_GENERATORS" onclick="unfold('span:Cycle__LATTICE_GENERATORS');">LATTICE_GENERATORS</a>.
 If this property is computed via rules, it does indeed give a lattice basis for the
 cone lattice, but when it is computed during an operation like refinement or divisor
 it will in general be larger.
 If this property exists, lattice normals might be computed faster.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_GENERATORS" onclick="swap_content('span:Cycle__LATTICE_GENERATORS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_GENERATORS" onclick="swap_content('span:Cycle__LATTICE_GENERATORS'); return false;"><b>LATTICE_GENERATORS</b>:
		</a>common::Matrix&lt;Integer, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_GENERATORS" class="foldit"><div class="descr"><p> This is an irredundant list of all lattice generators of all maximal polyhedra.
 If this property exists, lattice normals might be computed faster</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_NORMALS" onclick="swap_content('span:Cycle__LATTICE_NORMALS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_NORMALS" onclick="swap_content('span:Cycle__LATTICE_NORMALS'); return false;"><b>LATTICE_NORMALS</b>:
		</a>common::Map&lt;Pair&lt;Int, Int&gt;, Vector&lt;Integer&gt;&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_NORMALS" class="foldit"><div class="descr"><p> The lattice normals of codimension one faces with respect to adjacent
 maximal cells. It maps a pair of indices (i,j) to the lattice normal
 of the codimension one face given by row i in <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a> 
 in the maximal cell given by row j in <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>.
 The lattice normal is a representative of a generator of the quotient of 
 the saturated lattice of the maximal cell by the saturated lattice of the
 codimension one face. It is chosen such that it "points into the maximal cell"
 and is only unique modulo the lattice spanned by the codimension one cell.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_NORMAL_FCT_VECTOR" onclick="swap_content('span:Cycle__LATTICE_NORMAL_FCT_VECTOR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_NORMAL_FCT_VECTOR" onclick="swap_content('span:Cycle__LATTICE_NORMAL_FCT_VECTOR'); return false;"><b>LATTICE_NORMAL_FCT_VECTOR</b>:
		</a>common::Map&lt;Pair&lt;Int, Int&gt;, Vector&lt;Rational&gt;&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_NORMAL_FCT_VECTOR" class="foldit"><div class="descr"><p> For each lattice normal vector, this gives a vector of length (number of rays) + (lineality dim.), such that
 if a rational function is given by values on the rays and lin space generators, 
 the value of the corresponding normal <a href="#Cycle__LATTICE_NORMALS" onclick="unfold('span:Cycle__LATTICE_NORMALS');">LATTICE_NORMALS</a>-&gt;{i}-&gt;{j} can be computed by 
 multiplying the function value vector with the vector <a href="#Cycle__LATTICE_NORMAL_FCT_VECTOR" onclick="unfold('span:Cycle__LATTICE_NORMAL_FCT_VECTOR');">LATTICE_NORMAL_FCT_VECTOR</a>-&gt;{i}-&gt;{j}. 
 This is done in the following way:  
 We use the generating system (and indices refer to SEPARATED_VERTICES) &lt;(r_i-r_0)_i&gt;0, s_j, l_k&gt;, 
 where r_0 is the ray of the maximal cone with the lowest index in <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>,
 such that it fulfills x0 = 1, r_i are the remaining rays with x0 = 1, ordered according to their index 
 in <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>, s_j are the rays of the cone with x0 = 0 and l_k are the lineality space 
 generators. We will then store the coefficients a_i of (r_i - r_0) at the index of r_i, then - sum(a_i) at 
 the index of r_0 and the remaining coefficients at the appropriate places.
 In particular, the value of a lattice normal under a rational function can be computed
 simply by taking the scalar product of RAY_VALUES | LIN_VALUES with this FCT_VECTOR</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_NORMAL_SUM" onclick="swap_content('span:Cycle__LATTICE_NORMAL_SUM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_NORMAL_SUM" onclick="swap_content('span:Cycle__LATTICE_NORMAL_SUM'); return false;"><b>LATTICE_NORMAL_SUM</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_NORMAL_SUM" class="foldit"><div class="descr"><p> Rows of this matrix correspond to <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>, and each row contains the weighted sum:
 sum_{cone &gt; codim-1-face}( weight(cone) * <a href="#Cycle__LATTICE_NORMALS" onclick="unfold('span:Cycle__LATTICE_NORMALS');">LATTICE_NORMALS</a>-&gt;{codim-1-face}-&gt;{cone})</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__LATTICE_NORMAL_SUM_FCT_VECTOR" onclick="swap_content('span:Cycle__LATTICE_NORMAL_SUM_FCT_VECTOR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__LATTICE_NORMAL_SUM_FCT_VECTOR" onclick="swap_content('span:Cycle__LATTICE_NORMAL_SUM_FCT_VECTOR'); return false;"><b>LATTICE_NORMAL_SUM_FCT_VECTOR</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__LATTICE_NORMAL_SUM_FCT_VECTOR" class="foldit"><div class="descr"><p> Rows of this matrix correspond to <a href="#Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__SEPARATED_CODIMENSION_ONE_POLYTOPES');">SEPARATED_CODIMENSION_ONE_POLYTOPES</a> and each row contains a function vector 
 for the corresponding row of <a href="#Cycle__LATTICE_NORMAL_SUM" onclick="unfold('span:Cycle__LATTICE_NORMAL_SUM');">LATTICE_NORMAL_SUM</a>. This function vector is computed 
 in the same way as described under <a href="#Cycle__LATTICE_NORMAL_FCT_VECTOR" onclick="unfold('span:Cycle__LATTICE_NORMAL_FCT_VECTOR');">LATTICE_NORMAL_FCT_VECTOR</a>.
 Note that for any codim-1-faces at which the complex is not balanced, the corresponding row is a zero row.
 If a face is balanced can be checked under <a href="#Cycle__BALANCED_FACES" onclick="unfold('span:Cycle__BALANCED_FACES');">BALANCED_FACES</a>.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__WEIGHTS" onclick="swap_content('span:Cycle__WEIGHTS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__WEIGHTS" onclick="swap_content('span:Cycle__WEIGHTS'); return false;"><b>WEIGHTS</b>:
		</a>common::Vector&lt;Integer&gt;<br /><div style="display: inline" id="span:Cycle__WEIGHTS" class="foldit"><div class="descr"><p> These are the integer weights associated to the maximal cells of the complex.
 Entries correspond to (rows of) <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__WEIGHT_CONE" onclick="swap_content('span:Cycle__WEIGHT_CONE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__WEIGHT_CONE" onclick="swap_content('span:Cycle__WEIGHT_CONE'); return false;"><b>WEIGHT_CONE</b>:
		</a>polytope::Cone&lt;Rational&gt;<br /><div style="display: inline" id="span:Cycle__WEIGHT_CONE" class="foldit"><div class="descr"><p> The intersection of <a href="#Cycle__WEIGHT_SPACE" onclick="unfold('span:Cycle__WEIGHT_SPACE');">WEIGHT_SPACE</a> with the positive orthant.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__WEIGHT_SPACE" onclick="swap_content('span:Cycle__WEIGHT_SPACE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__WEIGHT_SPACE" onclick="swap_content('span:Cycle__WEIGHT_SPACE'); return false;"><b>WEIGHT_SPACE</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__WEIGHT_SPACE" class="foldit"><div class="descr"><p> A Z-basis (as rows) for the space of weight distributions on this 
 tropical cycle making it balanced (i.e. this cycle is irreducible, if and only if 
 <a href="#Cycle__WEIGHT_SPACE" onclick="unfold('span:Cycle__WEIGHT_SPACE');">WEIGHT_SPACE</a> has only one row and the gcd of <a href="#Cycle__WEIGHTS" onclick="unfold('span:Cycle__WEIGHTS');">WEIGHTS</a> is 1.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__WEIGHT_SYSTEM" onclick="swap_content('span:Cycle__WEIGHT_SYSTEM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__WEIGHT_SYSTEM" onclick="swap_content('span:Cycle__WEIGHT_SYSTEM'); return false;"><b>WEIGHT_SYSTEM</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Cycle__WEIGHT_SYSTEM" class="foldit"><div class="descr"><p> The dual of <a href="#Cycle__WEIGHT_SPACE" onclick="unfold('span:Cycle__WEIGHT_SPACE');">WEIGHT_SPACE</a>.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div></div></div></div></li></ul></div></div></div></li></ul><h4>User Methods of Cycle</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Cycle__methods__Affine_and_projective_coordinates" onclick="swap_content('span:Cycle__methods__Affine_and_projective_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Affine_and_projective_coordinates" onclick="swap_content('span:Cycle__methods__Affine_and_projective_coordinates'); return false;"><span class="category">Affine and projective coordinates</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Affine_and_projective_coordinates" class="foldit"><div class="descr"><p> These methods deal with affine and projective coordinates, conversion between those 
 and properties like dimension that change in projective space.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__affine_chart" onclick="swap_content('span:Cycle__affine_chart'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__affine_chart" onclick="swap_content('span:Cycle__affine_chart'); return false;"><b>affine_chart</b></a>
			(chart)  

			
				→ fan::PolyhedralComplex&lt;Rational&gt;<div style="display: inline" id="span:Cycle__affine_chart" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This produces a version of the cycle in the coordinates of a standard
 tropical chart, i.e. one coordinate is set to 0. 
 It is returned as an ordinary polyhedral complex (which can, for example,
 be used for visualization).</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>The coordinate which should be set to 0. Indexed from 
 0 to <a href="#" onclick="unfold('span:');">AMBIENT_DIM</a>-1 and 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex&lt;Rational&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__methods__Basic_polyhedral_operations" onclick="swap_content('span:Cycle__methods__Basic_polyhedral_operations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Basic_polyhedral_operations" onclick="swap_content('span:Cycle__methods__Basic_polyhedral_operations'); return false;"><span class="category">Basic polyhedral operations</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Basic_polyhedral_operations" class="foldit"><div class="descr"><p> These methods provide basic functionality related to polyhedral geometry, but not
 necessarily to tropical geometry</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__is_fan" onclick="swap_content('span:Cycle__is_fan'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__is_fan" onclick="swap_content('span:Cycle__is_fan'); return false;"><b>is_fan</b></a>
			(allow_translations)  

			
				→ Bool<div style="display: inline" id="span:Cycle__is_fan" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Checks whether this polyhedral structure is a fan, i.e. has only a single vertex at the origin.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">allow_translations</td><td><div class="descr"><div>. Optional and false by default. If true, a shifted fan is also accepted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td><div class="descr"><div>. </div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__methods__Combinatorics" onclick="swap_content('span:Cycle__methods__Combinatorics'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Combinatorics" onclick="swap_content('span:Cycle__methods__Combinatorics'); return false;"><span class="category">Combinatorics</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Combinatorics" class="foldit"><div class="descr"><p> These methods capture combinatorial information of the object. 
 Combinatorial properties only depend on combinatorial data of the object like, e.g., the face lattice.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__facet_normal" onclick="swap_content('span:Cycle__facet_normal'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__facet_normal" onclick="swap_content('span:Cycle__facet_normal'); return false;"><b>facet_normal</b></a>
			(i, j)  

			
				→ Int<div style="display: inline" id="span:Cycle__facet_normal" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Convenience function to ask for <a href="#Cycle__FACET_NORMALS_BY_PAIRS" onclick="unfold('span:Cycle__FACET_NORMALS_BY_PAIRS');">FACET_NORMALS_BY_PAIRS</a>-&gt;{new Pair&lt;Int,Int&gt;(i,i)}</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">i</td><td><div class="descr"><div>Row index in <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">j</td><td><div class="descr"><div>Row index in <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td><div class="descr"><div>Row index in <a href="#" onclick="unfold('span:');">FACET_NORMALS</a>.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__methods__Local_computations" onclick="swap_content('span:Cycle__methods__Local_computations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Local_computations" onclick="swap_content('span:Cycle__methods__Local_computations'); return false;"><span class="category">Local computations</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Local_computations" class="foldit"><div class="descr"><p> These methods are used for doing computations locally around a specified part of a Cycle.
-----
 These +++ deal with the creation and modification of cycles with nontrivial
 <a href="#Cycle__LOCAL_RESTRICTION" onclick="unfold('span:Cycle__LOCAL_RESTRICTION');">LOCAL_RESTRICTION</a>.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__delocalize" onclick="swap_content('span:Cycle__delocalize'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__delocalize" onclick="swap_content('span:Cycle__delocalize'); return false;"><b>delocalize</b></a>
			()  

			
				→ Cycle<div style="display: inline" id="span:Cycle__delocalize" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Returns the cycle without its <a href="#Cycle__LOCAL_RESTRICTION" onclick="unfold('span:Cycle__LOCAL_RESTRICTION');">LOCAL_RESTRICTION</a>
 (Note that only the defining properties are kept. All derived information is lost).</p></div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__methods__Visualization" onclick="swap_content('span:Cycle__methods__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Visualization" onclick="swap_content('span:Cycle__methods__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Visualization" class="foldit"><div class="descr"><p> These methods are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__BB_VISUAL" onclick="swap_content('span:Cycle__BB_VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__BB_VISUAL" onclick="swap_content('span:Cycle__BB_VISUAL'); return false;"><b>BB_VISUAL</b></a>
			()  

			<div style="display: inline" id="span:Cycle__BB_VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Displays a (possibly weighted) polyhedral complex by intersecting it with a bounding box. This bounding box
 is either defined by the vertices of the complex and the option "BoundingDistance" or explicitly given by
 "BoundingBox" and by setting "BoundingMode" to "absolute"
 @options</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">Chart</td><td><div class="descr"><div>Which affine chart to visualize, i.e. which coordinate to shift to 0. This is 0 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">WeightLabels</td><td><div class="descr"><div>If "hidden", no weight labels are displayed. Not hidden by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">CoordLabels</td><td><div class="descr"><div>If "show", coordinate labels are displayed at vertices. Hidden by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">BoundingMode</td><td><div class="descr"><div>Can be "relative" (intersects with the bounding box returned by the method  boundingBox(BoundingDistance)) or "absolute" (intersects with the given BoundingBox). "relative" by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Rational</a></td><td class="param">BoundingDistance</td><td><div class="descr"><div>The distance parameter for relative bounding mode</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">BoundingBox</td><td><div class="descr"><div>The bounding parameter for absolute bounding mode</div></div></td></tr><tr><td>option list:</td><td>Visual::Cycle::BoundingDecorations</td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__bounding_box" onclick="swap_content('span:Cycle__bounding_box'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__bounding_box" onclick="swap_content('span:Cycle__bounding_box'); return false;"><b>bounding_box</b></a>
			(dist, chart)  

			<div style="display: inline" id="span:Cycle__bounding_box" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a chart and a positive Rational as input and computes the relative bounding box of the cycle, i.e.
 it takes the coordinate-wise minimum and maximum over the coordinates of the nonfar vertices and 
 adds/subtracts the given number. This is returned as a 2xdim matrix.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Rational</a></td><td class="param">dist</td><td><div class="descr"><div>. Optional, 1 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>. The chart to be used fot he computation.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__VISUAL" onclick="swap_content('span:Cycle__VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__VISUAL" onclick="swap_content('span:Cycle__VISUAL'); return false;"><b>VISUAL</b></a>
			()  

			
				→ Visual::PolyhedralComplex<div style="display: inline" id="span:Cycle__VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualizes the tropical cycle. The options are more or less the same as for PolyhedralComplex's <a href="#Cycle__VISUAL" onclick="unfold('span:Cycle__VISUAL');">VISUAL</a>,
 except that there is one option for choosing a chart.
 @options</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">Chart</td><td><div class="descr"><div>. Which affine chart of the cycle to visualize, i.e. which coordinate should be shifted to 0. This is 0 by default.</div></div></td></tr><tr><td>option list:</td><td>Visual::Cycle::decorations</td></tr></table><h5>Returns</h5><table class="args"><tr><td>Visual::PolyhedralComplex</td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Cycle__methods__Weights_and_lattices" onclick="swap_content('span:Cycle__methods__Weights_and_lattices'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Cycle__methods__Weights_and_lattices" onclick="swap_content('span:Cycle__methods__Weights_and_lattices'); return false;"><span class="category">Weights and lattices</span></a></h3></div><div style="display: inline" id="span:Cycle__methods__Weights_and_lattices" class="foldit"><div class="descr"><p> These methods relate to the weights of a tropical cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:Cycle__lattice_normal" onclick="swap_content('span:Cycle__lattice_normal'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__lattice_normal" onclick="swap_content('span:Cycle__lattice_normal'); return false;"><b>lattice_normal</b></a>
			(i, j)  

			
				→ Vector&lt;Integer&gt;<div style="display: inline" id="span:Cycle__lattice_normal" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Convenience function to ask for <a href="#Cycle__LATTICE_NORMALS" onclick="unfold('span:Cycle__LATTICE_NORMALS');">LATTICE_NORMALS</a>-&gt;{new Pair&lt;Int,Int&gt;(i,i)}</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">i</td><td><div class="descr"><div>Row index in <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">j</td><td><div class="descr"><div>Row index in <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Integer&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul><h4>Permutations of Cycle</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Cycle__CodimPerm" onclick="swap_content('span:Cycle__CodimPerm'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__CodimPerm" onclick="swap_content('span:Cycle__CodimPerm'); return false;"><b>CodimPerm</b></a><div style="display: inline" id="span:Cycle__CodimPerm" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div><h4>Properties of CodimPerm</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Cycle__CodimPerm__PERMUTATION" onclick="swap_content('span:Cycle__CodimPerm__PERMUTATION'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Cycle__CodimPerm__PERMUTATION" onclick="swap_content('span:Cycle__CodimPerm__PERMUTATION'); return false;"><b>PERMUTATION</b>:
		</a>common::Array&lt;Int&gt;<br /><div style="display: inline" id="span:Cycle__CodimPerm__PERMUTATION" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface" onclick="swap_content('span:Hypersurface'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="Hypersurface" onclick="swap_content('span:Hypersurface'); return false;"><span class="object">Hypersurface</span></a></h3></div><div style="display: inline" id="span:Hypersurface" class="foldit"><div class="descr"><p> FIXME #775: Include typecheck?</p></div><b>derived from: </b><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div class="level3"></div><h4>Properties of Hypersurface</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Hypersurface__COEFFICIENTS" onclick="swap_content('span:Hypersurface__COEFFICIENTS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__COEFFICIENTS" onclick="swap_content('span:Hypersurface__COEFFICIENTS'); return false;"><b>COEFFICIENTS</b>:
		</a>common::Vector<br /><div style="display: inline" id="span:Hypersurface__COEFFICIENTS" class="foldit"><div class="descr"><p> Each row corresponds to one of the monomials in <a href="#Hypersurface__POLYNOMIAL" onclick="unfold('span:Hypersurface__POLYNOMIAL');">POLYNOMIAL</a>, each column to a variable.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__DIM" onclick="swap_content('span:Hypersurface__DIM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__DIM" onclick="swap_content('span:Hypersurface__DIM'); return false;"><b>DIM</b>:
		</a>common::Int<br /><div style="display: inline" id="span:Hypersurface__DIM" class="foldit"><div class="descr"><p> Dimension of the hypersurface.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__DOME" onclick="swap_content('span:Hypersurface__DOME'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__DOME" onclick="swap_content('span:Hypersurface__DOME'); return false;"><b>DOME</b>:
		</a>polytope::Polytope&lt;Rational&gt;<br /><div style="display: inline" id="span:Hypersurface__DOME" class="foldit"><div class="descr"><p> The <em class="u">dome</em> of a tropical polynomial \(F:\mathbb R^d\to\mathbb R\) (and the corresponding tropical hypersurface) is the set 
 \[D(F)=\left\{(p,s)\in\mathbb R^{d+1}\mid p\in\mathbb R^d, s\in\mathbb R, s \oplus F(p) = s\right\}.\]
 It is an unbounded convex polyhedron, c.f.</p><blockquote><div>Michael Joswig, <a href="http://page.math.tu-berlin.de/~joswig/etc/ETC-130412.pdf" onclick="unfold('span:');">Essentials of Tropical Combinatorics</a>, Chapter 1.</div></blockquote></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__MONOMIALS" onclick="swap_content('span:Hypersurface__MONOMIALS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__MONOMIALS" onclick="swap_content('span:Hypersurface__MONOMIALS'); return false;"><b>MONOMIALS</b>:
		</a>common::Matrix&lt;Int, NonSymmetric&gt;<br /><div style="display: inline" id="span:Hypersurface__MONOMIALS" class="foldit"><div class="descr"><p> Each row corresponds to one of the monomials in <a href="#Hypersurface__POLYNOMIAL" onclick="unfold('span:Hypersurface__POLYNOMIAL');">POLYNOMIAL</a>, each column to a variable.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__POLYNOMIAL" onclick="swap_content('span:Hypersurface__POLYNOMIAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__POLYNOMIAL" onclick="swap_content('span:Hypersurface__POLYNOMIAL'); return false;"><b>POLYNOMIAL</b>:
		</a>common::Polynomial<br /><div style="display: inline" id="span:Hypersurface__POLYNOMIAL" class="foldit"><div class="descr"><p> Homogeneous tropical polynomial defining the hypersurface.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__REDUNDANT_MONOMIALS" onclick="swap_content('span:Hypersurface__REDUNDANT_MONOMIALS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__REDUNDANT_MONOMIALS" onclick="swap_content('span:Hypersurface__REDUNDANT_MONOMIALS'); return false;"><b>REDUNDANT_MONOMIALS</b>:
		</a>common::Set&lt;Int&gt;<br /><div style="display: inline" id="span:Hypersurface__REDUNDANT_MONOMIALS" class="foldit"><div class="descr"><p> Indices of <a href="#Hypersurface__MONOMIALS" onclick="unfold('span:Hypersurface__MONOMIALS');">MONOMIALS</a> which do not define facets of the <a href="#Hypersurface__DOME" onclick="unfold('span:Hypersurface__DOME');">DOME</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__REGIONS" onclick="swap_content('span:Hypersurface__REGIONS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__REGIONS" onclick="swap_content('span:Hypersurface__REGIONS'); return false;"><b>REGIONS</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:Hypersurface__REGIONS" class="foldit"><div class="descr"><p> Connected components of the complement.
 Rows correspond to facets of the <a href="#Hypersurface__DOME" onclick="unfold('span:Hypersurface__DOME');">DOME</a>, i.e. non-redundant <a href="#Hypersurface__MONOMIALS" onclick="unfold('span:Hypersurface__MONOMIALS');">MONOMIALS</a> , columns correspond to <a href="#" onclick="unfold('span:');">VERTICES</a>.</p></div></div></div></div></li></ul><h4>User Methods of Hypersurface</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Hypersurface__opt_attained" onclick="swap_content('span:Hypersurface__opt_attained'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__opt_attained" onclick="swap_content('span:Hypersurface__opt_attained'); return false;"><b>opt_attained</b></a>
			(x)  

			
				→ Pair&lt;Rational,Set&gt;<div style="display: inline" id="span:Hypersurface__opt_attained" class="foldit"><br /><div class="descr_func"><div class="descr"><p> List the optimum value and the indices of the <a href="#Hypersurface__MONOMIALS" onclick="unfold('span:Hypersurface__MONOMIALS');">MONOMIALS</a> for which the optimum at a given point is attained.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector</a></td><td class="param">x</td><td><div class="descr"><div>given point</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Pair&lt;Rational,Set&gt;</a></td><td><div class="descr"><div>FIXME #775: (tropical) polynomials should have an evaluation function</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Hypersurface__privileged_subdivision" onclick="swap_content('span:Hypersurface__privileged_subdivision'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Hypersurface__privileged_subdivision" onclick="swap_content('span:Hypersurface__privileged_subdivision'); return false;"><b>privileged_subdivision</b></a>
			()  

			
				→ fan::PolyhedralComplex&lt;Rational&gt;<div style="display: inline" id="span:Hypersurface__privileged_subdivision" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Privileged subdivision dual to the tropical hypersurface.
 The vertices of this PolyhedralComplex are the non-redundant <a href="#Hypersurface__MONOMIALS" onclick="unfold('span:Hypersurface__MONOMIALS');">MONOMIALS</a>.</p></div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex&lt;Rational&gt;</a></td><td><div class="descr"><div>FIXME #775: rule needs "RAYS"</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic" onclick="swap_content('span:LinesInCubic'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="LinesInCubic" onclick="swap_content('span:LinesInCubic'); return false;"><span class="object">LinesInCubic</span></a></h3></div><div style="display: inline" id="span:LinesInCubic" class="foldit"><div class="descr"><p> This represents the result of the method <a href="#lines_in_cubic" onclick="unfold('span:lines_in_cubic');">lines_in_cubic</a>. It contains:
 The tropical polynomial representing the surface, the surface itself as a Cycle and 
 lists of lines and families of different types, each starting with LIST_... </p><p> The object also has methods, starting with array_... that return the corresponding LIST_... as a perl array.
 The different (lists of) lines can be visualized nicely with <a href="#visualize_in_surface" onclick="unfold('span:visualize_in_surface');">visualize_in_surface</a>.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div><div class="level3"></div><h4>Properties of LinesInCubic</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:LinesInCubic__properties__Counts_of_lines" onclick="swap_content('span:LinesInCubic__properties__Counts_of_lines'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="LinesInCubic__properties__Counts_of_lines" onclick="swap_content('span:LinesInCubic__properties__Counts_of_lines'); return false;"><span class="category">Counts of lines</span></a></h3></div><div style="display: inline" id="span:LinesInCubic__properties__Counts_of_lines" class="foldit"><div class="descr"><p> These count lines or families of lines in the cubic.# @category Defining properties</p></div><ul><li><div class="li"><div class="icon" id="icon:LinesInCubic__N_FAMILIES" onclick="swap_content('span:LinesInCubic__N_FAMILIES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__N_FAMILIES" onclick="swap_content('span:LinesInCubic__N_FAMILIES'); return false;"><b>N_FAMILIES</b>:
		</a>common::Int<br /><div style="display: inline" id="span:LinesInCubic__N_FAMILIES" class="foldit"><div class="descr"><p> The total number of families in <a href="#LinesInCubic__LIST_FAMILY_FIXED_EDGE" onclick="unfold('span:LinesInCubic__LIST_FAMILY_FIXED_EDGE');">LIST_FAMILY_FIXED_EDGE</a>, <a href="#LinesInCubic__LIST_FAMILY_FIXED_VERTEX" onclick="unfold('span:LinesInCubic__LIST_FAMILY_FIXED_VERTEX');">LIST_FAMILY_FIXED_VERTEX</a>, 
 <a href="#LinesInCubic__LIST_FAMILY_MOVING_EDGE" onclick="unfold('span:LinesInCubic__LIST_FAMILY_MOVING_EDGE');">LIST_FAMILY_MOVING_EDGE</a> and <a href="#LinesInCubic__LIST_FAMILY_MOVING_VERTEX" onclick="unfold('span:LinesInCubic__LIST_FAMILY_MOVING_VERTEX');">LIST_FAMILY_MOVING_VERTEX</a></p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__N_ISOLATED" onclick="swap_content('span:LinesInCubic__N_ISOLATED'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__N_ISOLATED" onclick="swap_content('span:LinesInCubic__N_ISOLATED'); return false;"><b>N_ISOLATED</b>:
		</a>common::Int<br /><div style="display: inline" id="span:LinesInCubic__N_ISOLATED" class="foldit"><div class="descr"><p> The total number of elements in <a href="#LinesInCubic__LIST_ISOLATED_EDGE" onclick="unfold('span:LinesInCubic__LIST_ISOLATED_EDGE');">LIST_ISOLATED_EDGE</a> and <a href="#LinesInCubic__LIST_ISOLATED_NO_EDGE" onclick="unfold('span:LinesInCubic__LIST_ISOLATED_NO_EDGE');">LIST_ISOLATED_NO_EDGE</a></p></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__properties__Defining_properties" onclick="swap_content('span:LinesInCubic__properties__Defining_properties'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="LinesInCubic__properties__Defining_properties" onclick="swap_content('span:LinesInCubic__properties__Defining_properties'); return false;"><span class="category">Defining properties</span></a></h3></div><div style="display: inline" id="span:LinesInCubic__properties__Defining_properties" class="foldit"><div class="descr"><p> The polynomial and the corresponding cubic.</p></div><ul><li><div class="li"><div class="icon" id="icon:LinesInCubic__CUBIC" onclick="swap_content('span:LinesInCubic__CUBIC'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__CUBIC" onclick="swap_content('span:LinesInCubic__CUBIC'); return false;"><b>CUBIC</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__CUBIC" class="foldit"><div class="descr"><p> The surface containing the lines</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__POLYNOMIAL" onclick="swap_content('span:LinesInCubic__POLYNOMIAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__POLYNOMIAL" onclick="swap_content('span:LinesInCubic__POLYNOMIAL'); return false;"><b>POLYNOMIAL</b>:
		</a>common::Polynomial<br /><div style="display: inline" id="span:LinesInCubic__POLYNOMIAL" class="foldit"><div class="descr"><p> The homogeneous tropical polynomial defining the surface</p></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__properties__Lists_of_lines" onclick="swap_content('span:LinesInCubic__properties__Lists_of_lines'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="LinesInCubic__properties__Lists_of_lines" onclick="swap_content('span:LinesInCubic__properties__Lists_of_lines'); return false;"><span class="category">Lists of lines</span></a></h3></div><div style="display: inline" id="span:LinesInCubic__properties__Lists_of_lines" class="foldit"><div class="descr"><p> These contain lists of certain (families of) lines.</p></div><ul><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_FAMILY_FIXED_EDGE" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_FIXED_EDGE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_FAMILY_FIXED_EDGE" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_FIXED_EDGE'); return false;"><b>LIST_FAMILY_FIXED_EDGE</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_FAMILY_FIXED_EDGE" class="foldit"><div class="descr"><p> A list of all families of lines with (part of) the bounded edge fixed</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_FAMILY_FIXED_VERTEX" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_FIXED_VERTEX'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_FAMILY_FIXED_VERTEX" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_FIXED_VERTEX'); return false;"><b>LIST_FAMILY_FIXED_VERTEX</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_FAMILY_FIXED_VERTEX" class="foldit"><div class="descr"><p> A list of all families of lines without a bounded edge at a fixed vertex</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_FAMILY_MOVING_EDGE" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_MOVING_EDGE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_FAMILY_MOVING_EDGE" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_MOVING_EDGE'); return false;"><b>LIST_FAMILY_MOVING_EDGE</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_FAMILY_MOVING_EDGE" class="foldit"><div class="descr"><p> A list of all families of lines with the bounded edge moving in transversal direction</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_FAMILY_MOVING_VERTEX" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_MOVING_VERTEX'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_FAMILY_MOVING_VERTEX" onclick="swap_content('span:LinesInCubic__LIST_FAMILY_MOVING_VERTEX'); return false;"><b>LIST_FAMILY_MOVING_VERTEX</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_FAMILY_MOVING_VERTEX" class="foldit"><div class="descr"><p> A list of all families of lines without a bounded  edge and a moving vertex.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_ISOLATED_EDGE" onclick="swap_content('span:LinesInCubic__LIST_ISOLATED_EDGE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_ISOLATED_EDGE" onclick="swap_content('span:LinesInCubic__LIST_ISOLATED_EDGE'); return false;"><b>LIST_ISOLATED_EDGE</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_ISOLATED_EDGE" class="foldit"><div class="descr"><p> A list of all isolated lines with bounded edge</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__LIST_ISOLATED_NO_EDGE" onclick="swap_content('span:LinesInCubic__LIST_ISOLATED_NO_EDGE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__LIST_ISOLATED_NO_EDGE" onclick="swap_content('span:LinesInCubic__LIST_ISOLATED_NO_EDGE'); return false;"><b>LIST_ISOLATED_NO_EDGE</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:LinesInCubic__LIST_ISOLATED_NO_EDGE" class="foldit"><div class="descr"><p> A list of all isolated lines without a bounded edge</p></div></div></div></div></li></ul></div></div></div></li></ul><h4>User Methods of LinesInCubic</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:LinesInCubic__methods__Lists_of_lines" onclick="swap_content('span:LinesInCubic__methods__Lists_of_lines'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="LinesInCubic__methods__Lists_of_lines" onclick="swap_content('span:LinesInCubic__methods__Lists_of_lines'); return false;"><span class="category">Lists of lines</span></a></h3></div><div style="display: inline" id="span:LinesInCubic__methods__Lists_of_lines" class="foldit"><div class="descr"><p> These contain lists of certain (families of) lines.</p></div><ul><li><div class="li"><div class="icon" id="icon:LinesInCubic__all_families" onclick="swap_content('span:LinesInCubic__all_families'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__all_families" onclick="swap_content('span:LinesInCubic__all_families'); return false;"><b>all_families</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__all_families" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array containing all families</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__all_isolated" onclick="swap_content('span:LinesInCubic__all_isolated'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__all_isolated" onclick="swap_content('span:LinesInCubic__all_isolated'); return false;"><b>all_isolated</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__all_isolated" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array containing all isolated solutions</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_family_fixed_edge" onclick="swap_content('span:LinesInCubic__array_family_fixed_edge'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_family_fixed_edge" onclick="swap_content('span:LinesInCubic__array_family_fixed_edge'); return false;"><b>array_family_fixed_edge</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_family_fixed_edge" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_FAMILY_FIXED_EDGE" onclick="unfold('span:LinesInCubic__LIST_FAMILY_FIXED_EDGE');">LIST_FAMILY_FIXED_EDGE</a></div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_family_fixed_vertex" onclick="swap_content('span:LinesInCubic__array_family_fixed_vertex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_family_fixed_vertex" onclick="swap_content('span:LinesInCubic__array_family_fixed_vertex'); return false;"><b>array_family_fixed_vertex</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_family_fixed_vertex" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_FAMILY_FIXED_VERTEX" onclick="unfold('span:LinesInCubic__LIST_FAMILY_FIXED_VERTEX');">LIST_FAMILY_FIXED_VERTEX</a></div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_family_moving_edge" onclick="swap_content('span:LinesInCubic__array_family_moving_edge'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_family_moving_edge" onclick="swap_content('span:LinesInCubic__array_family_moving_edge'); return false;"><b>array_family_moving_edge</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_family_moving_edge" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_FAMILY_MOVING_EDGE" onclick="unfold('span:LinesInCubic__LIST_FAMILY_MOVING_EDGE');">LIST_FAMILY_MOVING_EDGE</a></div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_family_moving_vertex" onclick="swap_content('span:LinesInCubic__array_family_moving_vertex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_family_moving_vertex" onclick="swap_content('span:LinesInCubic__array_family_moving_vertex'); return false;"><b>array_family_moving_vertex</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_family_moving_vertex" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_FAMILY_MOVING_VERTEX" onclick="unfold('span:LinesInCubic__LIST_FAMILY_MOVING_VERTEX');">LIST_FAMILY_MOVING_VERTEX</a></div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_isolated_edge" onclick="swap_content('span:LinesInCubic__array_isolated_edge'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_isolated_edge" onclick="swap_content('span:LinesInCubic__array_isolated_edge'); return false;"><b>array_isolated_edge</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_isolated_edge" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_ISOLATED_EDGE" onclick="unfold('span:LinesInCubic__LIST_ISOLATED_EDGE');">LIST_ISOLATED_EDGE</a></div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:LinesInCubic__array_isolated_no_edge" onclick="swap_content('span:LinesInCubic__array_isolated_no_edge'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="LinesInCubic__array_isolated_no_edge" onclick="swap_content('span:LinesInCubic__array_isolated_no_edge'); return false;"><b>array_isolated_no_edge</b></a>
			()  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:LinesInCubic__array_isolated_no_edge" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A perl array version of <a href="#LinesInCubic__LIST_ISOLATED_NO_EDGE" onclick="unfold('span:LinesInCubic__LIST_ISOLATED_NO_EDGE');">LIST_ISOLATED_NO_EDGE</a></div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism" onclick="swap_content('span:Morphism'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="Morphism" onclick="swap_content('span:Morphism'); return false;"><span class="object">Morphism</span></a></h3></div><div style="display: inline" id="span:Morphism" class="foldit"><div class="descr"><p> A morphism is a function between cycles which is locally affine linear and respects the lattices.
 It is defined by a <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>, which is a cycle, and values on this domain, <a href="#Morphism__VERTEX_VALUES" onclick="unfold('span:Morphism__VERTEX_VALUES');">VERTEX_VALUES</a> and
 <a href="#Morphism__LINEALITY_VALUES" onclick="unfold('span:Morphism__LINEALITY_VALUES');">LINEALITY_VALUES</a>, much like <a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a>.
 Alternatively, it can be defined as a global affine linear function by giving a matrix and a 
 translation vector.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div><div class="level3"></div><h4>Properties of Morphism</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Morphism__properties__Defining_morphisms_and_functions" onclick="swap_content('span:Morphism__properties__Defining_morphisms_and_functions'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Morphism__properties__Defining_morphisms_and_functions" onclick="swap_content('span:Morphism__properties__Defining_morphisms_and_functions'); return false;"><span class="category">Defining morphisms and functions</span></a></h3></div><div style="display: inline" id="span:Morphism__properties__Defining_morphisms_and_functions" class="foldit"><div class="descr"><p> These properties are used to define morphisms or rational functions on a Cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:Morphism__DOMAIN" onclick="swap_content('span:Morphism__DOMAIN'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__DOMAIN" onclick="swap_content('span:Morphism__DOMAIN'); return false;"><b>DOMAIN</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:Morphism__DOMAIN" class="foldit"><div class="descr"><p> This property describes the domain of the morphism. I.e. the morphism is
 defined on this complex and is locally affine integral linear. </p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__IS_GLOBALLY_AFFINE_LINEAR" onclick="swap_content('span:Morphism__IS_GLOBALLY_AFFINE_LINEAR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__IS_GLOBALLY_AFFINE_LINEAR" onclick="swap_content('span:Morphism__IS_GLOBALLY_AFFINE_LINEAR'); return false;"><b>IS_GLOBALLY_AFFINE_LINEAR</b>:
		</a>common::Bool<br /><div style="display: inline" id="span:Morphism__IS_GLOBALLY_AFFINE_LINEAR" class="foldit"><div class="descr"><p> This is TRUE, if the morphism is defined on the full projective torus by a <a href="#Morphism__MATRIX" onclick="unfold('span:Morphism__MATRIX');">MATRIX</a> and a <a href="#Morphism__TRANSLATE" onclick="unfold('span:Morphism__TRANSLATE');">TRANSLATE</a>
 The rules do not actually check for completeness of the <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>. 
 This property will be set to TRUE, if the morphism is only defined by <a href="#Morphism__MATRIX" onclick="unfold('span:Morphism__MATRIX');">MATRIX</a> and <a href="#Morphism__TRANSLATE" onclick="unfold('span:Morphism__TRANSLATE');">TRANSLATE</a>, 
 otherwise it is false (or you can set it upon creation).</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__LINEALITY_VALUES" onclick="swap_content('span:Morphism__LINEALITY_VALUES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__LINEALITY_VALUES" onclick="swap_content('span:Morphism__LINEALITY_VALUES'); return false;"><b>LINEALITY_VALUES</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Morphism__LINEALITY_VALUES" class="foldit"><div class="descr"><p> The vector in row i describes the function value (slope) of <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>-&gt;LINEALITY_SPACE-&gt;row(i)</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__MATRIX" onclick="swap_content('span:Morphism__MATRIX'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__MATRIX" onclick="swap_content('span:Morphism__MATRIX'); return false;"><b>MATRIX</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Morphism__MATRIX" class="foldit"><div class="descr"><p> If the morphism is a global affine linear map x |-&gt; Ax+v, then this contains the matrix A.
 Note that this must be well-defined on tropical projective coordinates, so the sum of the columns of A
 must be a multiple of the (1,..,1)-vector.
 If <a href="#Morphism__TRANSLATE" onclick="unfold('span:Morphism__TRANSLATE');">TRANSLATE</a> is set, but this property is not set, then it is the identity by default.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__TRANSLATE" onclick="swap_content('span:Morphism__TRANSLATE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__TRANSLATE" onclick="swap_content('span:Morphism__TRANSLATE'); return false;"><b>TRANSLATE</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:Morphism__TRANSLATE" class="foldit"><div class="descr"><p> If the morphism is a global affine linear map x |-&gt; Ax+v, then this contains the translation vector 
 v. If <a href="#Morphism__MATRIX" onclick="unfold('span:Morphism__MATRIX');">MATRIX</a> is set, but this property is not set, then it is the zero vector by default.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__VERTEX_VALUES" onclick="swap_content('span:Morphism__VERTEX_VALUES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__VERTEX_VALUES" onclick="swap_content('span:Morphism__VERTEX_VALUES'); return false;"><b>VERTEX_VALUES</b>:
		</a>common::Matrix&lt;Rational, NonSymmetric&gt;<br /><div style="display: inline" id="span:Morphism__VERTEX_VALUES" class="foldit"><div class="descr"><p> The vector at row i describes the function value of vertex <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>-&gt;SEPARATED_VERTICES-&gt;row(i). 
 (In tropical homogenous coordinates, but without leading coordinate).
 More precisely, if the corresponding vertex is not a far ray, it describes its function value. 
 If it is a directional ray, it describes the slope on that ray.</p></div></div></div></div></li></ul></div></div></div></li></ul><h4>User Methods of Morphism</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:Morphism__methods__Affine_and_projective_coordinates" onclick="swap_content('span:Morphism__methods__Affine_and_projective_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Morphism__methods__Affine_and_projective_coordinates" onclick="swap_content('span:Morphism__methods__Affine_and_projective_coordinates'); return false;"><span class="category">Affine and projective coordinates</span></a></h3></div><div style="display: inline" id="span:Morphism__methods__Affine_and_projective_coordinates" class="foldit"><div class="descr"><p> These methods deal with affine and projective coordinates, conversion between those 
 and properties like dimension that change in projective space.</p></div><ul><li><div class="li"><div class="icon" id="icon:Morphism__affine_representation" onclick="swap_content('span:Morphism__affine_representation'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__affine_representation" onclick="swap_content('span:Morphism__affine_representation'); return false;"><b>affine_representation</b></a>
			(domain_chart, target_chart)  

			
				→ Pair&lt;Matrix&lt;Rational&gt;, Vector&lt;Rational&gt; &gt;<div style="display: inline" id="span:Morphism__affine_representation" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the representation of a morphism (given by <a href="#Morphism__MATRIX" onclick="unfold('span:Morphism__MATRIX');">MATRIX</a> and <a href="#Morphism__TRANSLATE" onclick="unfold('span:Morphism__TRANSLATE');">TRANSLATE</a>)
 on tropical affine coordinates.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">domain_chart</td><td><div class="descr"><div>Which coordinate index of the homogenized domain is shifted to zero to identify
 it with the domain of the affine function. 0 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">target_chart</td><td><div class="descr"><div>Which coordinate of the homogenized target space is shifted to zero to identify
 it with the target of the affine function. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Pair&lt;Matrix&lt;Rational&gt;, Vector&lt;Rational&gt; &gt;</a></td><td><div class="descr"><div>A matrix and a translate in affine coordinates.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__methods__Morphisms" onclick="swap_content('span:Morphism__methods__Morphisms'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Morphism__methods__Morphisms" onclick="swap_content('span:Morphism__methods__Morphisms'); return false;"><span class="category">Morphisms</span></a></h3></div><div style="display: inline" id="span:Morphism__methods__Morphisms" class="foldit"><div class="descr"><p> These are general methods that deal with morphisms and their arithmetic.</p></div><ul><li><div class="li"><div class="icon" id="icon:Morphism__after" onclick="swap_content('span:Morphism__after'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__after" onclick="swap_content('span:Morphism__after'); return false;"><b>after</b></a>
			(g)  

			
				→ this<div style="display: inline" id="span:Morphism__after" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the composition of another morphism g and this morphism.
 This morphism comes after g.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td class="param">g</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td>this</td><td><div class="descr"><div>after g</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__before" onclick="swap_content('span:Morphism__before'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__before" onclick="swap_content('span:Morphism__before'); return false;"><b>before</b></a>
			(g)  

			
				→ g<div style="display: inline" id="span:Morphism__before" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the composition of this morphism and another morphism g.
 This morphism comes before g.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td class="param">g</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">g</a></td><td><div class="descr"><div>after f</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__restrict" onclick="swap_content('span:Morphism__restrict'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__restrict" onclick="swap_content('span:Morphism__restrict'); return false;"><b>restrict</b></a>
			(Some)  

			
				→ Morphism<div style="display: inline" id="span:Morphism__restrict" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the restriction of the morphism to a cycle.
 The cycle need not be contained in the <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a> of the morphism,
 the restriction will be computed on the intersection.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">Some</td><td><div class="descr"><div>cycle living in the same ambient space as the <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a></div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td><div class="descr"><div>The restriction of the morphism to the cycle (or its
 intersection with <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:Morphism__methods__Visualization" onclick="swap_content('span:Morphism__methods__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="Morphism__methods__Visualization" onclick="swap_content('span:Morphism__methods__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:Morphism__methods__Visualization" class="foldit"><div class="descr"><p> These methods are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:Morphism__BB_VISUAL" onclick="swap_content('span:Morphism__BB_VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="Morphism__BB_VISUAL" onclick="swap_content('span:Morphism__BB_VISUAL'); return false;"><b>BB_VISUAL</b></a>
			()  

			<div style="display: inline" id="span:Morphism__BB_VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualizes the domain of the morphism. Works exactly as BB_VISUAL of WeightedComplex, but has additional option
 @options</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">FunctionLabels</td><td><div class="descr"><div>If set to "show", textual function representations are diplayed on cones. False by default</div></div></td></tr><tr><td>option list:</td><td>Visual::Cycle::FunctionDecorations</td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve" onclick="swap_content('span:RationalCurve'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="RationalCurve" onclick="swap_content('span:RationalCurve'); return false;"><span class="object">RationalCurve</span></a></h3></div><div style="display: inline" id="span:RationalCurve" class="foldit"><div class="descr"><p> An n-marked rational curve, identified by its <a href="#RationalCurve__SETS" onclick="unfold('span:RationalCurve__SETS');">SETS</a>, i.e. its partitions of {1,...,n} and
 its <a href="#Hypersurface__COEFFICIENTS" onclick="unfold('span:Hypersurface__COEFFICIENTS');">COEFFICIENTS</a>, i.e. the lengths of the corresponding edges.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div><div class="level3"></div><h4>Properties of RationalCurve</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:RationalCurve__properties__Combinatorics" onclick="swap_content('span:RationalCurve__properties__Combinatorics'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalCurve__properties__Combinatorics" onclick="swap_content('span:RationalCurve__properties__Combinatorics'); return false;"><span class="category">Combinatorics</span></a></h3></div><div style="display: inline" id="span:RationalCurve__properties__Combinatorics" class="foldit"><div class="descr"><p> These properties capture combinatorial information of the object. 
 Combinatorial properties only depend on combinatorial data of the object like, e.g., the face lattice.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalCurve__COEFFS" onclick="swap_content('span:RationalCurve__COEFFS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__COEFFS" onclick="swap_content('span:RationalCurve__COEFFS'); return false;"><b>COEFFS</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:RationalCurve__COEFFS" class="foldit"><div class="descr"><p> A list of positive rational coefficients. The list should have the same length as <a href="#RationalCurve__SETS" onclick="unfold('span:RationalCurve__SETS');">SETS</a> and
 contain only entries &gt; 0. The i-th entry then gives the length of the bounded edge defined by
 the i-th partition. If you're not sure if all your coefficients are &gt; 0, use <a href="#RationalCurve__INPUT_SETS" onclick="unfold('span:RationalCurve__INPUT_SETS');">INPUT_SETS</a> and
 <a href="#RationalCurve__INPUT_COEFFS" onclick="unfold('span:RationalCurve__INPUT_COEFFS');">INPUT_COEFFS</a> instead.
 Note that the zero curve (i.e. no bounded edges, only leaves) is represented by one empty set
 with corresponding lenghth 0.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__GRAPH" onclick="swap_content('span:RationalCurve__GRAPH'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__GRAPH" onclick="swap_content('span:RationalCurve__GRAPH'); return false;"><b>GRAPH</b>:
		</a>graph::Graph&lt;Undirected&gt;<br /><div style="display: inline" id="span:RationalCurve__GRAPH" class="foldit"><div class="descr"><p> Contains the abstract graph (non-metric) corresponding to the curve. All unbounded leaves are modelled
 as bounded edges.
 The vertices at the ends of the "leaves" are always the first <a href="#RationalCurve__N_LEAVES" onclick="unfold('span:RationalCurve__N_LEAVES');">N_LEAVES</a> vertices.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__GRAPH_EDGE_LENGTHS" onclick="swap_content('span:RationalCurve__GRAPH_EDGE_LENGTHS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__GRAPH_EDGE_LENGTHS" onclick="swap_content('span:RationalCurve__GRAPH_EDGE_LENGTHS'); return false;"><b>GRAPH_EDGE_LENGTHS</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:RationalCurve__GRAPH_EDGE_LENGTHS" class="foldit"><div class="descr"><p> Contains the lengths of the edges of <a href="#RationalCurve__GRAPH" onclick="unfold('span:RationalCurve__GRAPH');">GRAPH</a> that represent bounded edges of the curve.
 The coefficients appear in the order that the corr. edges appear in <a href="#" onclick="unfold('span:');">EDGES</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__NODES_BY_LEAVES" onclick="swap_content('span:RationalCurve__NODES_BY_LEAVES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__NODES_BY_LEAVES" onclick="swap_content('span:RationalCurve__NODES_BY_LEAVES'); return false;"><b>NODES_BY_LEAVES</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:RationalCurve__NODES_BY_LEAVES" class="foldit"><div class="descr"><p> This incidence matrix gives a list of the vertices of the curve
 Each row corresponds to a vertex and contains as a set the [[LEAVES] that are
 attached to that vertex (again, counting from 1!)</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__NODES_BY_SETS" onclick="swap_content('span:RationalCurve__NODES_BY_SETS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__NODES_BY_SETS" onclick="swap_content('span:RationalCurve__NODES_BY_SETS'); return false;"><b>NODES_BY_SETS</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:RationalCurve__NODES_BY_SETS" class="foldit"><div class="descr"><p> This incidence matrix gives a list of the vertices of the curve
 Each row corresponds to a vertex and contains as a set the row indices of the <a href="#RationalCurve__SETS" onclick="unfold('span:RationalCurve__SETS');">SETS</a> that
 correspond to edges attached to that vertex</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__NODE_DEGREES" onclick="swap_content('span:RationalCurve__NODE_DEGREES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__NODE_DEGREES" onclick="swap_content('span:RationalCurve__NODE_DEGREES'); return false;"><b>NODE_DEGREES</b>:
		</a>common::Vector&lt;Int&gt;<br /><div style="display: inline" id="span:RationalCurve__NODE_DEGREES" class="foldit"><div class="descr"><p> This gives a list of the vertices of the curve in terms of their valences
 They appear in the same order as in <a href="#RationalCurve__NODES_BY_LEAVES" onclick="unfold('span:RationalCurve__NODES_BY_LEAVES');">NODES_BY_LEAVES</a> or <a href="#RationalCurve__NODES_BY_SETS" onclick="unfold('span:RationalCurve__NODES_BY_SETS');">NODES_BY_SETS</a></p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__N_LEAVES" onclick="swap_content('span:RationalCurve__N_LEAVES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__N_LEAVES" onclick="swap_content('span:RationalCurve__N_LEAVES'); return false;"><b>N_LEAVES</b>:
		</a>common::Int<br /><div style="display: inline" id="span:RationalCurve__N_LEAVES" class="foldit"><div class="descr"><p> The number of leaves of the rational curve.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__SETS" onclick="swap_content('span:RationalCurve__SETS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__SETS" onclick="swap_content('span:RationalCurve__SETS'); return false;"><b>SETS</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:RationalCurve__SETS" class="foldit"><div class="descr"><p> A list of partitions of [n] that define the tree of the curve: For each bounded edge we have 
 the corresponding partition of the n leaves. These should be irredundant. If you want to input
 a possibly redundant list, use <a href="#RationalCurve__INPUT_SETS" onclick="unfold('span:RationalCurve__INPUT_SETS');">INPUT_SETS</a> and <a href="#RationalCurve__INPUT_COEFFS" onclick="unfold('span:RationalCurve__INPUT_COEFFS');">INPUT_COEFFS</a> instead. The number of marked leaves
 should always be given by <a href="#RationalCurve__N_LEAVES" onclick="unfold('span:RationalCurve__N_LEAVES');">N_LEAVES</a>. The sets are subsets of {1,...,n} (NOT {0,..,n-1}!)
 Note that the zero curve (i.e. no bounded edges, only leaves) is represented by one empty set
 with corresponding lenghth 0.</p></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__properties__Input_property" onclick="swap_content('span:RationalCurve__properties__Input_property'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalCurve__properties__Input_property" onclick="swap_content('span:RationalCurve__properties__Input_property'); return false;"><span class="category">Input property</span></a></h3></div><div style="display: inline" id="span:RationalCurve__properties__Input_property" class="foldit"><div class="descr"><p> These properties are for input only. They allow redundant information.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalCurve__INPUT_COEFFS" onclick="swap_content('span:RationalCurve__INPUT_COEFFS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__INPUT_COEFFS" onclick="swap_content('span:RationalCurve__INPUT_COEFFS'); return false;"><b>INPUT_COEFFS</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:RationalCurve__INPUT_COEFFS" class="foldit"><div class="descr"><p> Same as <a href="#RationalCurve__COEFFS" onclick="unfold('span:RationalCurve__COEFFS');">COEFFS</a>, except that entries may be &lt;=0. This should have the same length as <a href="#RationalCurve__INPUT_SETS" onclick="unfold('span:RationalCurve__INPUT_SETS');">INPUT_SETS</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__INPUT_SETS" onclick="swap_content('span:RationalCurve__INPUT_SETS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__INPUT_SETS" onclick="swap_content('span:RationalCurve__INPUT_SETS'); return false;"><b>INPUT_SETS</b>:
		</a>common::IncidenceMatrix&lt;NonSymmetric&gt;<br /><div style="display: inline" id="span:RationalCurve__INPUT_SETS" class="foldit"><div class="descr"><p> Same as <a href="#RationalCurve__SETS" onclick="unfold('span:RationalCurve__SETS');">SETS</a>, except that sets may appear several times.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__INPUT_STRING" onclick="swap_content('span:RationalCurve__INPUT_STRING'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__INPUT_STRING" onclick="swap_content('span:RationalCurve__INPUT_STRING'); return false;"><b>INPUT_STRING</b>:
		</a>common::String<br /><div style="display: inline" id="span:RationalCurve__INPUT_STRING" class="foldit"><div class="descr"><p> This property can also be used to define a rational curve: A linear combination of partitions is
 given as a string, using the following syntax:
 A partition is given as a subset of {1,..,n} and written as a comma-separated list of leaf
 indices in round brackets, e.g. "(1,2,5)"
 A linear combination can be created using rational numbers, "+","+" and "-" in the obvious way, 
 e.g. "2*(1,2,5) + 1*(3,4,7) - 2(1,2) (The "*" is optional)
 Of course, each set should contain at least two elements. If you don't specify N_LEAVES, it is
 set to be the largest leaf index occuring in the sets.
 Partitions needn't be irredundant and coefficients can be any rational number. If the resulting 
 element is not in the moduli space, an error is thrown.</p></div></div></div></div></li></ul></div></div></div></li></ul><h4>User Methods of RationalCurve</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:RationalCurve__methods__Conversion" onclick="swap_content('span:RationalCurve__methods__Conversion'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalCurve__methods__Conversion" onclick="swap_content('span:RationalCurve__methods__Conversion'); return false;"><span class="category">Conversion</span></a></h3></div><div style="display: inline" id="span:RationalCurve__methods__Conversion" class="foldit"><div class="descr"><p> These deal with converting the representation of a rational curve between
 metric vector and matroid fan coordinates.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalCurve__metric_vector" onclick="swap_content('span:RationalCurve__metric_vector'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__metric_vector" onclick="swap_content('span:RationalCurve__metric_vector'); return false;"><b>metric_vector</b></a>
			()  

			<div style="display: inline" id="span:RationalCurve__metric_vector" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Returns the (n over 2) metric vector of the rational n-marked curve</p></div></div><div class="level3"></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalCurve__methods__Visualization" onclick="swap_content('span:RationalCurve__methods__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalCurve__methods__Visualization" onclick="swap_content('span:RationalCurve__methods__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:RationalCurve__methods__Visualization" class="foldit"><div class="descr"><p> These methods are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalCurve__VISUAL" onclick="swap_content('span:RationalCurve__VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalCurve__VISUAL" onclick="swap_content('span:RationalCurve__VISUAL'); return false;"><b>VISUAL</b></a>
			()  

			<div style="display: inline" id="span:RationalCurve__VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualizes a RationalCurve object. This visualization uses the VISUAL method of its GRAPH, so 
 it accepts all the options of Visual::Graph::decorations. In addition it has another option
 @options</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">LengthLabels</td><td><div class="descr"><div>If "hidden", the edges are not labelled with their lengths. Any other text is ignored. Not set to "hidden" by default.</div></div></td></tr><tr><td>option list:</td><td>Visual::RationalCurve::decorations</td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction" onclick="swap_content('span:RationalFunction'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="RationalFunction" onclick="swap_content('span:RationalFunction'); return false;"><span class="object">RationalFunction</span></a></h3></div><div style="display: inline" id="span:RationalFunction" class="foldit"><div class="descr"><p> A rational function on a polyhedral complex. It can be described by giving its <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>,
 a Cycle, and values on this domain - which are encoded in the properties <a href="#RationalFunction__VERTEX_VALUES" onclick="unfold('span:RationalFunction__VERTEX_VALUES');">VERTEX_VALUES</a> and 
 <a href="#RationalFunction__LINEALITY_VALUES" onclick="unfold('span:RationalFunction__LINEALITY_VALUES');">LINEALITY_VALUES</a>.
 Alternatively, it can be defined by a tropical quotient of homogeneous tropical polynomials of the 
 same degree i.e. by giving <a href="#RationalFunction__NUMERATOR" onclick="unfold('span:RationalFunction__NUMERATOR');">NUMERATOR</a> and <a href="#RationalFunction__DENOMINATOR" onclick="unfold('span:RationalFunction__DENOMINATOR');">DENOMINATOR</a>. 
 A <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a> can be defined additionally (though one should take
 care that both functions are actually piecewise affine linear on the cells), otherwise it will be
 computed as the common refinement of the domains of affine linearity of the two polynomials.
 Note: This has nothing to do with common's RationalFunction (which is univariate). If you want to 
 access that type or use this type from another application, be sure to prepend the appropriate 
 namespace identifier.</p></div><div class="descr">
			Contained in extension <code>atint</code>.
		</div><div class="level3"></div><h4>Properties of RationalFunction</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:RationalFunction__properties__Defining_morphisms_and_functions" onclick="swap_content('span:RationalFunction__properties__Defining_morphisms_and_functions'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalFunction__properties__Defining_morphisms_and_functions" onclick="swap_content('span:RationalFunction__properties__Defining_morphisms_and_functions'); return false;"><span class="category">Defining morphisms and functions</span></a></h3></div><div style="display: inline" id="span:RationalFunction__properties__Defining_morphisms_and_functions" class="foldit"><div class="descr"><p> These properties are used to define morphisms or rational functions on a Cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalFunction__DENOMINATOR" onclick="swap_content('span:RationalFunction__DENOMINATOR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__DENOMINATOR" onclick="swap_content('span:RationalFunction__DENOMINATOR'); return false;"><b>DENOMINATOR</b>:
		</a>common::Polynomial<br /><div style="display: inline" id="span:RationalFunction__DENOMINATOR" class="foldit"><div class="descr"><p> When representing the function as a quotient of tropical polynomials, this
 is the denominator. Should be a homogeneous polynomial of the same degree as <a href="#RationalFunction__NUMERATOR" onclick="unfold('span:RationalFunction__NUMERATOR');">NUMERATOR</a>. </p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__DOMAIN" onclick="swap_content('span:RationalFunction__DOMAIN'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__DOMAIN" onclick="swap_content('span:RationalFunction__DOMAIN'); return false;"><b>DOMAIN</b>:
		</a><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a><br /><div style="display: inline" id="span:RationalFunction__DOMAIN" class="foldit"><div class="descr"><p> This property describes the affine linearity domains of the function. I.e. the function is
 affine integral linear on each maximal polytope of <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>. </p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__IS_GLOBALLY_DEFINED" onclick="swap_content('span:RationalFunction__IS_GLOBALLY_DEFINED'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__IS_GLOBALLY_DEFINED" onclick="swap_content('span:RationalFunction__IS_GLOBALLY_DEFINED'); return false;"><b>IS_GLOBALLY_DEFINED</b>:
		</a>common::Bool<br /><div style="display: inline" id="span:RationalFunction__IS_GLOBALLY_DEFINED" class="foldit"><div class="descr"><p> This is TRUE, if the function is defined on the full projective torus by a <a href="#RationalFunction__NUMERATOR" onclick="unfold('span:RationalFunction__NUMERATOR');">NUMERATOR</a> and a 
 <a href="#RationalFunction__DENOMINATOR" onclick="unfold('span:RationalFunction__DENOMINATOR');">DENOMINATOR</a>.
 The rules do not actually check for completeness of the <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>. This property will be set to true, 
 if the function is created only via <a href="#RationalFunction__NUMERATOR" onclick="unfold('span:RationalFunction__NUMERATOR');">NUMERATOR</a> and <a href="#RationalFunction__DENOMINATOR" onclick="unfold('span:RationalFunction__DENOMINATOR');">DENOMINATOR</a>. Otherwise
 it will be set to FALSE (or you can set it manually upon creation).</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__LINEALITY_VALUES" onclick="swap_content('span:RationalFunction__LINEALITY_VALUES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__LINEALITY_VALUES" onclick="swap_content('span:RationalFunction__LINEALITY_VALUES'); return false;"><b>LINEALITY_VALUES</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:RationalFunction__LINEALITY_VALUES" class="foldit"><div class="descr"><p> The value at index i describes the function value of <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>-&gt;LINEALITY_SPACE-&gt;row(i)</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__NUMERATOR" onclick="swap_content('span:RationalFunction__NUMERATOR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__NUMERATOR" onclick="swap_content('span:RationalFunction__NUMERATOR'); return false;"><b>NUMERATOR</b>:
		</a>common::Polynomial<br /><div style="display: inline" id="span:RationalFunction__NUMERATOR" class="foldit"><div class="descr"><p> When representing the function as a quotient of tropical polynomials, this
 is the numerator. Should be a homogeneous polynomial of the same degree as <a href="#RationalFunction__DENOMINATOR" onclick="unfold('span:RationalFunction__DENOMINATOR');">DENOMINATOR</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__POWER" onclick="swap_content('span:RationalFunction__POWER'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__POWER" onclick="swap_content('span:RationalFunction__POWER'); return false;"><b>POWER</b>:
		</a>common::Int<br /><div style="display: inline" id="span:RationalFunction__POWER" class="foldit"><div class="descr"><p> This is an internally used property that should not actually be set by the user. When creating a
 rational function with the ^-operator, this property is set to the exponent. 
 The semantics is that when computing a divisor, this function should be applied so many times
 The usual application of this is a call to divisor($X, $f^4) or something similar.
 Warning: This property is not stored if the RationalFunction object is saved. Nor should be assumed
 to be preserved during any kind of arithmetic or restricting operation.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__VERTEX_VALUES" onclick="swap_content('span:RationalFunction__VERTEX_VALUES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__VERTEX_VALUES" onclick="swap_content('span:RationalFunction__VERTEX_VALUES'); return false;"><b>VERTEX_VALUES</b>:
		</a>common::Vector&lt;Rational&gt;<br /><div style="display: inline" id="span:RationalFunction__VERTEX_VALUES" class="foldit"><div class="descr"><p> The value at index i describes the function value at <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>-&gt;SEPARATED_VERTICES-&gt;row(i). 
 More precisely, if the corresponding vertex is not a far ray, it describes its function value. 
 If it is a directional ray, it describes the slope on that ray.</p></div></div></div></div></li></ul></div></div></div></li></ul><h4>User Methods of RationalFunction</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:RationalFunction__methods__Defining_morphisms_and_functions" onclick="swap_content('span:RationalFunction__methods__Defining_morphisms_and_functions'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalFunction__methods__Defining_morphisms_and_functions" onclick="swap_content('span:RationalFunction__methods__Defining_morphisms_and_functions'); return false;"><span class="category">Defining morphisms and functions</span></a></h3></div><div style="display: inline" id="span:RationalFunction__methods__Defining_morphisms_and_functions" class="foldit"><div class="descr"><p> These methods are used to define morphisms or rational functions on a Cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalFunction__restrict" onclick="swap_content('span:RationalFunction__restrict'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__restrict" onclick="swap_content('span:RationalFunction__restrict'); return false;"><b>restrict</b></a>
			(C)  

			
				→ RationalFunction&lt;Addition&gt;<div style="display: inline" id="span:RationalFunction__restrict" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the restriction of this RationalFunction on a given Cycle.
 The cycle need not be contained in the <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a> of the function, the restriction
 will be computed on the intersection of the cycle and the <a href="#RationalFunction__DOMAIN" onclick="unfold('span:RationalFunction__DOMAIN');">DOMAIN</a>.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>The new domain.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction&lt;Addition&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:RationalFunction__methods__Visualization" onclick="swap_content('span:RationalFunction__methods__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="RationalFunction__methods__Visualization" onclick="swap_content('span:RationalFunction__methods__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:RationalFunction__methods__Visualization" class="foldit"><div class="descr"><p> These methods are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:RationalFunction__BB_VISUAL" onclick="swap_content('span:RationalFunction__BB_VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="RationalFunction__BB_VISUAL" onclick="swap_content('span:RationalFunction__BB_VISUAL'); return false;"><b>BB_VISUAL</b></a>
			()  

			<div style="display: inline" id="span:RationalFunction__BB_VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualizes the domain of the function. Works exactly as BB_VISUAL of WeightedComplex, but has additional option
 @options</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">FunctionLabels</td><td><div class="descr"><div>If set to "show", textual function representations are diplayed on cones. False by default</div></div></td></tr><tr><td>option list:</td><td>Visual::Cycle::FunctionDecorations</td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope" onclick="swap_content('span:TropicalPolytope'); return false;">
		 	
	</div><div class="unfoldable"><div class="object"><h3><a href="#" class="javalink" id="TropicalPolytope" onclick="swap_content('span:TropicalPolytope'); return false;"><span class="object">TropicalPolytope</span></a></h3></div><div style="display: inline" id="span:TropicalPolytope" class="foldit"><div class="descr"><p> FIXME #775:
 change Rational to TropicalNumber&lt;Addition,Rational&gt;; maybe Scalar instead of crational for valuations of higher rank
 change TropicalPolytope to Cone</p></div><div class="level3"></div><h4>Properties of TropicalPolytope</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:TropicalPolytope__AMBIENT_DIM" onclick="swap_content('span:TropicalPolytope__AMBIENT_DIM'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__AMBIENT_DIM" onclick="swap_content('span:TropicalPolytope__AMBIENT_DIM'); return false;"><b>AMBIENT_DIM</b>:
		</a>common::Int<br /><div style="display: inline" id="span:TropicalPolytope__AMBIENT_DIM" class="foldit"><div class="descr"><p> Dimension of the tropical projective space which contains the tropical polytope.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__CONVEX_HULL_2D_CYCLIC" onclick="swap_content('span:TropicalPolytope__CONVEX_HULL_2D_CYCLIC'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__CONVEX_HULL_2D_CYCLIC" onclick="swap_content('span:TropicalPolytope__CONVEX_HULL_2D_CYCLIC'); return false;"><b>CONVEX_HULL_2D_CYCLIC</b>:
		</a>common::Array&lt;Int&gt;<br /><div style="display: inline" id="span:TropicalPolytope__CONVEX_HULL_2D_CYCLIC" class="foldit"><div class="descr"><p> Cyclic order of the <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a> in the boundary (for dimension 2 only).</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__ENVELOPE" onclick="swap_content('span:TropicalPolytope__ENVELOPE'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__ENVELOPE" onclick="swap_content('span:TropicalPolytope__ENVELOPE'); return false;"><b>ENVELOPE</b>:
		</a>polytope::Polytope<br /><div style="display: inline" id="span:TropicalPolytope__ENVELOPE" class="foldit"><div class="descr"><p> Tropical polytopes have a natural description as the complex of bounded faces of their envelopes.
 This envelope depends on the choice of the <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a> that generate the tropical polytope.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__HALF_SPACES" onclick="swap_content('span:TropicalPolytope__HALF_SPACES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__HALF_SPACES" onclick="swap_content('span:TropicalPolytope__HALF_SPACES'); return false;"><b>HALF_SPACES</b>:
		</a>common::Array<br /><div style="display: inline" id="span:TropicalPolytope__HALF_SPACES" class="foldit"><div class="descr"><p> Tropical halfspaces encoded as pairs of apices and sets of sectors.
 Maybe redundant (for now; subject to change in the future).</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__POINTS" onclick="swap_content('span:TropicalPolytope__POINTS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__POINTS" onclick="swap_content('span:TropicalPolytope__POINTS'); return false;"><b>POINTS</b>:
		</a>common::Matrix<br /><div style="display: inline" id="span:TropicalPolytope__POINTS" class="foldit"><div class="descr"><p> Input points in homogeneous coordinates.  This is the fixed system of generators with respect
 to which many combinatorial properties are expressed.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PSEUDOVERTEX_COARSE_TYPES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_COARSE_TYPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PSEUDOVERTEX_COARSE_TYPES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_COARSE_TYPES'); return false;"><b>PSEUDOVERTEX_COARSE_TYPES</b>:
		</a>common::Array&lt;Array&lt;Int&gt;&gt;<br /><div style="display: inline" id="span:TropicalPolytope__PSEUDOVERTEX_COARSE_TYPES" class="foldit"><div class="descr"><p> Coarse types of <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a> relative to <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PSEUDOVERTEX_GRAPH" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_GRAPH'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PSEUDOVERTEX_GRAPH" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_GRAPH'); return false;"><b>PSEUDOVERTEX_GRAPH</b>:
		</a>graph::Graph&lt;Undirected&gt;<br /><div style="display: inline" id="span:TropicalPolytope__PSEUDOVERTEX_GRAPH" class="foldit"><div class="descr"><p> Tropical polytopes have a natural description as ordinary polytopal complexes. This is the 1-skeleton of such a
 complex.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PSEUDOVERTEX_LABELS" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_LABELS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PSEUDOVERTEX_LABELS" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_LABELS'); return false;"><b>PSEUDOVERTEX_LABELS</b>:
		</a>common::Array&lt;String&gt;<br /><div style="display: inline" id="span:TropicalPolytope__PSEUDOVERTEX_LABELS" class="foldit"><div class="descr"><p> Unique names assigned to the <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a>.
 Can be used as "NodeLabels" in <a href="#TropicalPolytope__VISUAL_PLANAR" onclick="unfold('span:TropicalPolytope__VISUAL_PLANAR');">VISUAL_PLANAR</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PSEUDOVERTEX_TYPES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_TYPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PSEUDOVERTEX_TYPES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTEX_TYPES'); return false;"><b>PSEUDOVERTEX_TYPES</b>:
		</a>common::Array&lt;Array&lt;Set&lt;Int&gt;&gt;&gt;<br /><div style="display: inline" id="span:TropicalPolytope__PSEUDOVERTEX_TYPES" class="foldit"><div class="descr"><p> Types of <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a> relative to <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PSEUDOVERTICES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTICES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PSEUDOVERTICES" onclick="swap_content('span:TropicalPolytope__PSEUDOVERTICES'); return false;"><b>PSEUDOVERTICES</b>:
		</a>common::Matrix<br /><div style="display: inline" id="span:TropicalPolytope__PSEUDOVERTICES" class="foldit"><div class="descr"><p> Pseudovertices are the vertices of the <a href="#TropicalPolytope__ENVELOPE" onclick="unfold('span:TropicalPolytope__ENVELOPE');">ENVELOPE</a> (with respect to <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a>).
 original: property PSEUDOVERTICES : Matrix&lt;Scalar&gt;;</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VERTEX_LABELS" onclick="swap_content('span:TropicalPolytope__VERTEX_LABELS'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VERTEX_LABELS" onclick="swap_content('span:TropicalPolytope__VERTEX_LABELS'); return false;"><b>VERTEX_LABELS</b>:
		</a>common::Array&lt;String&gt;<br /><div style="display: inline" id="span:TropicalPolytope__VERTEX_LABELS" class="foldit"><div class="descr"><p> Unique names assigned to the <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a>.
 If specified, they are shown by visualization tools instead of vertex indices.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VERTEX_TYPES" onclick="swap_content('span:TropicalPolytope__VERTEX_TYPES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VERTEX_TYPES" onclick="swap_content('span:TropicalPolytope__VERTEX_TYPES'); return false;"><b>VERTEX_TYPES</b>:
		</a>common::Array&lt;Array&lt;Set&lt;Int&gt;&gt;&gt;<br /><div style="display: inline" id="span:TropicalPolytope__VERTEX_TYPES" class="foldit"><div class="descr"><p> Types of <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a> relative to <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a>.</p></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VERTICES" onclick="swap_content('span:TropicalPolytope__VERTICES'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VERTICES" onclick="swap_content('span:TropicalPolytope__VERTICES'); return false;"><b>VERTICES</b>:
		</a>common::Matrix<br /><div style="display: inline" id="span:TropicalPolytope__VERTICES" class="foldit"><div class="descr"><p> Vertices of the tropical convex hull in homogeneous coordinates:
 We normalize by setting the first homogeneous coordinate to zero.</p></div></div></div></div></li></ul><h4>User Methods of TropicalPolytope</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:TropicalPolytope__methods__Visualization" onclick="swap_content('span:TropicalPolytope__methods__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="TropicalPolytope__methods__Visualization" onclick="swap_content('span:TropicalPolytope__methods__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:TropicalPolytope__methods__Visualization" class="foldit"><div class="descr"><p> These methods are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VISUAL" onclick="swap_content('span:TropicalPolytope__VISUAL'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VISUAL" onclick="swap_content('span:TropicalPolytope__VISUAL'); return false;"><b>VISUAL</b></a>
			()  

			
				→ Visual::TropicalPolytope<div style="display: inline" id="span:TropicalPolytope__VISUAL" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualize the tropical polytope.</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td>option list:</td><td>Visual::Polygons::decorations</td></tr></table><h5>Returns</h5><table class="args"><tr><td>Visual::TropicalPolytope</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VISUAL_HYPERPLANE_ARRANGEMENT" onclick="swap_content('span:TropicalPolytope__VISUAL_HYPERPLANE_ARRANGEMENT'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VISUAL_HYPERPLANE_ARRANGEMENT" onclick="swap_content('span:TropicalPolytope__VISUAL_HYPERPLANE_ARRANGEMENT'); return false;"><b>VISUAL_HYPERPLANE_ARRANGEMENT</b></a>
			()  

			
				→ Visual::Hypersurface<div style="display: inline" id="span:TropicalPolytope__VISUAL_HYPERPLANE_ARRANGEMENT" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualize the arrangement of hyperplanes with apices in the <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a> of the tropical polytope.</p></div></div><div class="level3"><h5>Returns</h5><table class="args"><tr><td>Visual::Hypersurface</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VISUAL_PLANAR" onclick="swap_content('span:TropicalPolytope__VISUAL_PLANAR'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VISUAL_PLANAR" onclick="swap_content('span:TropicalPolytope__VISUAL_PLANAR'); return false;"><b>VISUAL_PLANAR</b></a>
			()  

			
				→ Visual::TropicalPolytope<div style="display: inline" id="span:TropicalPolytope__VISUAL_PLANAR" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualize the tropical polytope projected onto the plane.</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">Directions</td><td><div class="descr"><div>directions to project onto</div></div></td></tr><tr><td>option list:</td><td>Visual::Graph::decorations</td></tr></table><h5>Returns</h5><table class="args"><tr><td>Visual::TropicalPolytope</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:TropicalPolytope__VISUAL_PSEUDOVERTEX_GRAPH" onclick="swap_content('span:TropicalPolytope__VISUAL_PSEUDOVERTEX_GRAPH'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__VISUAL_PSEUDOVERTEX_GRAPH" onclick="swap_content('span:TropicalPolytope__VISUAL_PSEUDOVERTEX_GRAPH'); return false;"><b>VISUAL_PSEUDOVERTEX_GRAPH</b></a>
			()  

			
				→ Visual::TropicalPolytope<div style="display: inline" id="span:TropicalPolytope__VISUAL_PSEUDOVERTEX_GRAPH" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Visualize the <a href="#TropicalPolytope__PSEUDOVERTEX_GRAPH" onclick="unfold('span:TropicalPolytope__PSEUDOVERTEX_GRAPH');">PSEUDOVERTEX_GRAPH</a> of a tropical polytope.</p></div></div><div class="level3"><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">seed</td><td><div class="descr"><div>random seed value for the string embedder</div></div></td></tr><tr><td>option list:</td><td>Visual::Graph::decorations</td></tr></table><h5>Returns</h5><table class="args"><tr><td>Visual::TropicalPolytope</td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul><h4>Permutations of TropicalPolytope</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PseudoVertexPerm" onclick="swap_content('span:TropicalPolytope__PseudoVertexPerm'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PseudoVertexPerm" onclick="swap_content('span:TropicalPolytope__PseudoVertexPerm'); return false;"><b>PseudoVertexPerm</b></a><div style="display: inline" id="span:TropicalPolytope__PseudoVertexPerm" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div><h4>Properties of PseudoVertexPerm</h4><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:TropicalPolytope__PseudoVertexPerm__PERMUTATION" onclick="swap_content('span:TropicalPolytope__PseudoVertexPerm__PERMUTATION'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="TropicalPolytope__PseudoVertexPerm__PERMUTATION" onclick="swap_content('span:TropicalPolytope__PseudoVertexPerm__PERMUTATION'); return false;"><b>PERMUTATION</b>:
		</a>common::Array&lt;Int&gt;<br /><div style="display: inline" id="span:TropicalPolytope__PseudoVertexPerm__PERMUTATION" class="foldit"><div class="descr"><p> transforming <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a> from this into basic object</p></div></div></div></div></li></ul></div></div></div></li></ul></div></div></div></li></ul></div><div class="level2"><h2>User Functions</h2><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:gfan_tropicalbruteforce" onclick="swap_content('span:gfan_tropicalbruteforce'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="gfan_tropicalbruteforce" onclick="swap_content('span:gfan_tropicalbruteforce'); return false;"><b>gfan_tropicalbruteforce</b></a>
			()  

			<div style="display: inline" id="span:gfan_tropicalbruteforce" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This program preprocesses the input for gfan and then reads in the gfan output.
 It should be checked whether gfan_groebnerbla can really be left out.</p></div></div><div class="level3"></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:gfan_tropicalhypersurface" onclick="swap_content('span:gfan_tropicalhypersurface'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="gfan_tropicalhypersurface" onclick="swap_content('span:gfan_tropicalhypersurface'); return false;"><b>gfan_tropicalhypersurface</b></a>
			()  

			<div style="display: inline" id="span:gfan_tropicalhypersurface" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This program preprocesses the input for gfan and then reads in the gfan output.
 It should be checked whether gfan_groebnerbla can really be left out.</p></div></div><div class="level3"></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:gfan_tropicalintersection" onclick="swap_content('span:gfan_tropicalintersection'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="gfan_tropicalintersection" onclick="swap_content('span:gfan_tropicalintersection'); return false;"><b>gfan_tropicalintersection</b></a>
			()  

			<div style="display: inline" id="span:gfan_tropicalintersection" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This program preprocesses the input for gfan and then reads in the gfan output.</p></div></div><div class="level3"></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:gfan_tropicalvariety_of_prime" onclick="swap_content('span:gfan_tropicalvariety_of_prime'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="gfan_tropicalvariety_of_prime" onclick="swap_content('span:gfan_tropicalvariety_of_prime'); return false;"><b>gfan_tropicalvariety_of_prime</b></a>
			()  

			<div style="display: inline" id="span:gfan_tropicalvariety_of_prime" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This program preprocesses the input for gfan and then reads in the gfan output.</p></div></div><div class="level3"></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Abstract_rational_curves" onclick="swap_content('span:functions__Abstract_rational_curves'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Abstract_rational_curves" onclick="swap_content('span:functions__Abstract_rational_curves'); return false;"><span class="category">Abstract rational curves</span></a></h3></div><div style="display: inline" id="span:functions__Abstract_rational_curves" class="foldit"><div class="descr"><p> These functions deal with abstract rational n-marked curves.</p></div><ul><li><div class="li"><div class="icon" id="icon:insert_leaves" onclick="swap_content('span:insert_leaves'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="insert_leaves" onclick="swap_content('span:insert_leaves'); return false;"><b>insert_leaves</b></a>
			(curve, nodes)  

			<div style="display: inline" id="span:insert_leaves" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a RationalCurve and a list of node indices. Then inserts additional 
 leaves (starting from N_LEAVES+1) at these nodes and returns the resulting 
 RationalCurve object</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">curve</td><td><div class="descr"><div>A RationalCurve object</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">nodes</td><td><div class="descr"><div>A list of node indices of the curve</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:matroid_coordinates_from_curve" onclick="swap_content('span:matroid_coordinates_from_curve'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="matroid_coordinates_from_curve" onclick="swap_content('span:matroid_coordinates_from_curve'); return false;"><b>matroid_coordinates_from_curve</b></a>
			&lt;Addition&gt;
		 
			(r)  

			
				→ Vector&lt;Rational&gt;<div style="display: inline" id="span:matroid_coordinates_from_curve" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a rational curve and converts it into the corresponding matroid coordinates
 in the moduli space of rational curves (including the leading 0 for a ray!)</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, i.e. which coordinates to use.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">r</td><td><div class="descr"><div>A rational n-marked curve</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td><div class="descr"><div>The matroid coordinates, tropically homogeneous and
 with leading coordinate</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_from_cone" onclick="swap_content('span:rational_curve_from_cone'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_from_cone" onclick="swap_content('span:rational_curve_from_cone'); return false;"><b>rational_curve_from_cone</b></a>
			(X, n_leaves, coneIndex)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_from_cone" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a weighted complex X that is supposed to be of the form
 M_0,n x Y for some Y (It assumes that M_0,n occupies the first 
 coordinates) and an index of a maximal cone of that complex.
 It then computes a rational curve corresponding to an interior point of
 that cone (ignoring the second component Y)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">X</td><td><div class="descr"><div>A weighted complex of the form M_0,n x Y</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n_leaves</td><td><div class="descr"><div>The n in M_0,n. Needed to determine the dimension of
 the M_0,n component</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">coneIndex</td><td><div class="descr"><div>The index of the maximal cone</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td><div class="descr"><div>c The curve corresponding to an interior point</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_from_matroid_coordinates" onclick="swap_content('span:rational_curve_from_matroid_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_from_matroid_coordinates" onclick="swap_content('span:rational_curve_from_matroid_coordinates'); return false;"><b>rational_curve_from_matroid_coordinates</b></a>
			&lt;Addition&gt;
		 
			(v)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_from_matroid_coordinates" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a vector from Q^((n-1) over 2) that lies in M_0,n (in its matroid coordinates) 
 and computes the corresponding rational curve.
 In the isomorphism of the metric curve space and the moduli coordinates
 the last leaf is considered as the special leaf</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max (i.e. what are the matroid coordinates using)</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>A vector in the moduli space (WITH leading coordinate).</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_from_metric" onclick="swap_content('span:rational_curve_from_metric'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_from_metric" onclick="swap_content('span:rational_curve_from_metric'); return false;"><b>rational_curve_from_metric</b></a>
			(v)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_from_metric" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a vector from Q^(n over 2) that describes an n-marked rational abstract
 curve as a distance vector between its leaves. It then computes the 
 curve corresponding to this vector.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>A vector of length (n over 2). Its entries are 
 interpreted as the distances d(i,j) ordered lexicographically according to i,j. However, they need not be positive, as long as v is equivalent to a proper 
 metric modulo leaf lengths.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_from_rays" onclick="swap_content('span:rational_curve_from_rays'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_from_rays" onclick="swap_content('span:rational_curve_from_rays'); return false;"><b>rational_curve_from_rays</b></a>
			&lt;Addition&gt;
		 
			(rays)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_from_rays" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a matrix of rays of a given cone that is supposed to lie
 in a moduli space M_0,n and computes the rational curve corresponding
 to an interior point. More precisely, if there are k vertices in 
 homogeneous coordinates, it computes 1/k * (sum of these vertices),
 then it adds each directional ray. It then returns the curve corresponding
 to this point</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, where the coordinates live.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">rays</td><td><div class="descr"><div>The rays of the cone, in tropical homogeneous coordinates.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td><div class="descr"><div>c The curve corresponding to an interior point</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_immersion" onclick="swap_content('span:rational_curve_immersion'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_immersion" onclick="swap_content('span:rational_curve_immersion'); return false;"><b>rational_curve_immersion</b></a>
			&lt;Addition&gt;
		 
			(delta, type)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:rational_curve_immersion" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function creates an embedding of a rational tropical curve using
 a given abstract curve and degree</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">delta</td><td><div class="descr"><div>The degree of the curve in tropical projectve 
 coordinates without leading coordinate. The number of rows
 should correspond to the number of leaves of type and the number of columns
 is the dimension of the space in which the curve should be realized</div></div></td></tr><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">type</td><td><div class="descr"><div>An abstract rational curve</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The corresponding immersed complex.
 The position of the curve is determined by the first node, 
 which is always placed at the origin</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_list_from_matroid_coordinates" onclick="swap_content('span:rational_curve_list_from_matroid_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_list_from_matroid_coordinates" onclick="swap_content('span:rational_curve_list_from_matroid_coordinates'); return false;"><b>rational_curve_list_from_matroid_coordinates</b></a>
			&lt;Addition&gt;
		 
			(m)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_list_from_matroid_coordinates" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a matrix whose rows are elements in the moduli space M_0,n in matroid 
 coordinates. Returns a list, where the i-th element is the curve corr. to 
 the i-th row in the matrix</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Mir or Max (i.e. what are the matroid coordinates using</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">m</td><td><div class="descr"><div>A list of vectors in the moduli space (with leading coordinate).</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td><div class="descr"><div>: An array of RationalCurves</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_curve_list_from_metric" onclick="swap_content('span:rational_curve_list_from_metric'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_curve_list_from_metric" onclick="swap_content('span:rational_curve_list_from_metric'); return false;"><b>rational_curve_list_from_metric</b></a>
			(m)  

			
				→ RationalCurve<div style="display: inline" id="span:rational_curve_list_from_metric" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a matrix whose rows are metrics of rational n-marked curves.
 Returns a list, where the i-th element is the curve corr. to 
 the i-th row in the matrix</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">m</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td><div class="descr"><div>: An array of RationalCurves</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:sum_curves" onclick="swap_content('span:sum_curves'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="sum_curves" onclick="swap_content('span:sum_curves'); return false;"><b>sum_curves</b></a>
			(An, v)  

			
				→ RationalCurve<div style="display: inline" id="span:sum_curves" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a vector of coefficients a_i and a list of RationalCurves c_i and computes
 sum(a_i * c_i). In particular, it also checks, whether the result lies in M_0,n. If not, it returns undef</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">An</td><td><div class="descr"><div>arbitrary list of RationalCurve objects</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>A list of coefficients. Superfluous coefficients are ignored, missing ones replaced
 by +1(!)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td><div class="descr"><div>The linear combination of the curves defined by the coefficients or undef, if the result
 is not in M_0,n. The history of the operation is kept in INPUT_SETS and INPUT_COEFFS</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:testFourPointCondition" onclick="swap_content('span:testFourPointCondition'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="testFourPointCondition" onclick="swap_content('span:testFourPointCondition'); return false;"><b>testFourPointCondition</b></a>
			(v)  

			
				→ Int<div style="display: inline" id="span:testFourPointCondition" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a metric vector in Q^{(n over 2)} and checks whether it fulfills 
 the four-point condition, i.e. whether it lies in M_0,n. More precisely 
 it only needs to be equivalent to such a vector</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>The vector to be checked</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td><div class="descr"><div>A quadruple (array) of indices, where the four-point condition 
 is violated or an empty list, if the vector is indeed in M_0,n</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Affine_and_projective_coordinates" onclick="swap_content('span:functions__Affine_and_projective_coordinates'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Affine_and_projective_coordinates" onclick="swap_content('span:functions__Affine_and_projective_coordinates'); return false;"><span class="category">Affine and projective coordinates</span></a></h3></div><div style="display: inline" id="span:functions__Affine_and_projective_coordinates" class="foldit"><div class="descr"><p> These functions deal with affine and projective coordinates, conversion between those 
 and properties like dimension that change in projective space.</p></div><ul><li><div class="li"><div class="icon" id="icon:morphism_from_affine" onclick="swap_content('span:morphism_from_affine'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="morphism_from_affine" onclick="swap_content('span:morphism_from_affine'); return false;"><b>morphism_from_affine</b></a>
			&lt;Addition&gt;
		 
			(A, v, domain_chart, target_chart)  

			
				→ Morphism<div style="display: inline" id="span:morphism_from_affine" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a representation of a morphism on affine coordinates and converts it to projective ones.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">A</td><td><div class="descr"><div>. The matrix of the morphism x |-&gt; Ax + v in affine coordinates.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>. The translate of the morphism x |-&gt; Ax + v in affine coordinates.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">domain_chart</td><td><div class="descr"><div>Which coordinate index of the homogenized domain is shifted to zero to identify
 it with the domain of the affine function. 0 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">target_chart</td><td><div class="descr"><div>Which coordinate of the homogenized target space is shifted to zero to identify
 it with the target of the affine function. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int" onclick="swap_content('span:rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int" onclick="swap_content('span:rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int'); return false;"><b>rational_fct_from_affine_denominator</b></a>
			(p, chart)  

			
				→ RationalFunction<div style="display: inline" id="span:rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a tropical polynomial p defined on tropical affine coordinates and turns it into 
 the rational function (1/p) on tropical homogeneous coordinates</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Polynomial&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">p</td><td><div class="descr"><div>A polynomial on affine coordinates.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>The index of the homogenizing coordinate. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td><div class="descr"><div>A rational function, which on the given chart is described by (1/p).</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_fct_from_affine_denominator__String__Int" onclick="swap_content('span:rational_fct_from_affine_denominator__String__Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_fct_from_affine_denominator__String__Int" onclick="swap_content('span:rational_fct_from_affine_denominator__String__Int'); return false;"><b>rational_fct_from_affine_denominator</b></a>
			(p, chart)  

			
				→ RationalFunction<div style="display: inline" id="span:rational_fct_from_affine_denominator__String__Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Same as <a href="#rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int" onclick="unfold('span:rational_fct_from_affine_denominator__Polynomial_TropicalNumber_Addition___Int');">rational_fct_from_affine_denominator</a>(Polynomial), except that it takes
 a string which it converts to a tropical polynomial using <a href="#" onclick="unfold('span:');">toTropicalPolynomial</a>.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">p</td><td><div class="descr"><div>A string that will be converted to a tropical polynomial</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>The index of the homogenizing coordinate. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int" onclick="swap_content('span:rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int" onclick="swap_content('span:rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int'); return false;"><b>rational_fct_from_affine_numerator</b></a>
			(p, chart)  

			
				→ RationalFunction<div style="display: inline" id="span:rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a tropical polynomial defined on tropical affine coordinates and turns it into 
 a rational function on tropical homogeneous coordinates</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Polynomial&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">p</td><td><div class="descr"><div>A polynomial on affine coordinates.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>The index of the homogenizing coordinate. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td><div class="descr"><div>A rational function, which on the given chart is described by p.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:rational_fct_from_affine_numerator__String__Int" onclick="swap_content('span:rational_fct_from_affine_numerator__String__Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="rational_fct_from_affine_numerator__String__Int" onclick="swap_content('span:rational_fct_from_affine_numerator__String__Int'); return false;"><b>rational_fct_from_affine_numerator</b></a>
			(p, chart)  

			
				→ RationalFunction<div style="display: inline" id="span:rational_fct_from_affine_numerator__String__Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Same as <a href="#rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int" onclick="unfold('span:rational_fct_from_affine_numerator__Polynomial_TropicalNumber_Addition___Int');">rational_fct_from_affine_numerator</a>(Polynomial), except that it takes
 a string which it converts to a tropical polynomial using <a href="#" onclick="unfold('span:');">toTropicalPolynomial</a>.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">p</td><td><div class="descr"><div>A string that will be converted to a tropical polynomial</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>The index of the homogenizing coordinate. 0 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:tdehomog" onclick="swap_content('span:tdehomog'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="tdehomog" onclick="swap_content('span:tdehomog'); return false;"><b>tdehomog</b></a>
			(A, chart, has_leading_coordinate)  

			
				→ Matrix&lt;Rational&gt;<div style="display: inline" id="span:tdehomog" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This is the inverse operation of thomog. It assumes a list of
 rays and vertices is given in tropical projective coordinates and returns
 a conversion into affine coordinates.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">A</td><td><div class="descr"><div>The matrix. Can also be given as an anonymous array.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>Optional. Indicates which coordinate should be shifted
 to 0. If there is a leading coordinate, the first column of the matrix 
 will remain untouched and the subsequent
 ones are numbered from 0. The default value for this is 0.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">has_leading_coordinate</td><td><div class="descr"><div>Whether the matrix has a leading 1/0 to indicate
 whether a row is a vertex or a ray. In that case, this coordinate is not touched.
 This is true by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:thomog" onclick="swap_content('span:thomog'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="thomog" onclick="swap_content('span:thomog'); return false;"><b>thomog</b></a>
			(A, chart, has_leading_coordinate)  

			
				→ Matrix&lt;Rational&gt;<div style="display: inline" id="span:thomog" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Converts tropical affine to tropical projective coordinates.
 It takes a matrix of row vectors in R<sup>n-1</sup> and 
 identifies the latter with R<sup>n</sup> mod (1,..,1) by 
 assuming a certain coordinate has been set to 0.
 I.e. it will return the matrix with a 0 column inserted at
 the position indicated by chart</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">A</td><td><div class="descr"><div>The matrix. Can also be given as an anonymous array [[..],[..],..]</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>Optional. Indicates, which coordinate of
 R<sup>n</sup> mod (1,..,1) should be set to 0 to identify it
 with R<sup>n-1</sup>. Note that if there is a leading coordinate, 
 the first column is supposed to contain
 the 1/0-coordinate indicating whether a row is a vertex or a ray and
 the remaining coordinates are then labelled 0,..,n-1. This option is 0 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">has_leading_coordinate</td><td><div class="descr"><div>Whether the matrix has a leading 1/0 to indicate
 whether a row is a vertex or a ray. In that case, this coordinate is not touched.
 This is true by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Basic_polyhedral_operations" onclick="swap_content('span:functions__Basic_polyhedral_operations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Basic_polyhedral_operations" onclick="swap_content('span:functions__Basic_polyhedral_operations'); return false;"><span class="category">Basic polyhedral operations</span></a></h3></div><div style="display: inline" id="span:functions__Basic_polyhedral_operations" class="foldit"><div class="descr"><p> These functions provide basic functionality related to polyhedral geometry, but not
 necessarily to tropical geometry</p></div><ul><li><div class="li"><div class="icon" id="icon:affine_transform__Cycle_Addition__Matrix_Rational__Vector_Rational" onclick="swap_content('span:affine_transform__Cycle_Addition__Matrix_Rational__Vector_Rational'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="affine_transform__Cycle_Addition__Matrix_Rational__Vector_Rational" onclick="swap_content('span:affine_transform__Cycle_Addition__Matrix_Rational__Vector_Rational'); return false;"><b>affine_transform</b></a>
			&lt;Addition&gt;
		 
			(C, M, T)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:affine_transform__Cycle_Addition__Matrix_Rational__Vector_Rational" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the affine transform of a cycle under an affine linear map.
 This function assumes that the map is a lattice isomorphism on the cycle, i.e.
 no push-forward computations are performed, in particular the weights remain unchanged</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>a tropical cycle</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">M</td><td><div class="descr"><div>The transformation matrix. Should be given in tropical projective
 coordinates and be homogeneous, i.e. the sum over all rows should be the same.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">T</td><td><div class="descr"><div>The translate. Optional and zero vector by default. Should be given in
 tropical projective coordinates (but without leading coordinate for vertices or rays).
 If you only want to shift a cycle, use <a href="#shift_cycle" onclick="unfold('span:shift_cycle');">shift_cycle</a>.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The transform M*C + T</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:affine_transform__Cycle_Addition__Morphism_Addition" onclick="swap_content('span:affine_transform__Cycle_Addition__Morphism_Addition'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="affine_transform__Cycle_Addition__Morphism_Addition" onclick="swap_content('span:affine_transform__Cycle_Addition__Morphism_Addition'); return false;"><b>affine_transform</b></a>
			&lt;Addition&gt;
		 
			(C, M)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:affine_transform__Cycle_Addition__Morphism_Addition" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the affine transform of a cycle under an affine linear map.
 This function assumes that the map is a lattice isomorphism on the cycle, i.e.
 no push-forward computations are performed, in particular the weights remain unchanged</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>a tropical cycle</div></div></td></tr><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism&lt;Addition&gt;</a></td><td class="param">M</td><td><div class="descr"><div>A morphism. Should be defined via <a href="#Morphism__MATRIX" onclick="unfold('span:Morphism__MATRIX');">MATRIX</a> and <a href="#Morphism__TRANSLATE" onclick="unfold('span:Morphism__TRANSLATE');">TRANSLATE</a>,
 though its <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a> will be ignored.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The transform M(C)</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:cartesian_product" onclick="swap_content('span:cartesian_product'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cartesian_product" onclick="swap_content('span:cartesian_product'); return false;"><b>cartesian_product</b></a>
			(A)  

			
				→ Cycle<div style="display: inline" id="span:cartesian_product" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the cartesian product of a set of cycles. If any of them has weights, so will the product
 (all non-weighted cycles will be treated as if they had constant weight 1)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td>cycles</td><td class="param">A</td><td><div class="descr"><div>list of Cycles</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The cartesian product. 
 Note that the representation is noncanonical, as it identifies
 the product of two projective tori of dimensions d and e with a projective torus 
 of dimension d+e by dehomogenizing and then later rehomogenizing after the first coordinate.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:check_cycle_equality" onclick="swap_content('span:check_cycle_equality'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="check_cycle_equality" onclick="swap_content('span:check_cycle_equality'); return false;"><b>check_cycle_equality</b></a>
			(X, Y, check_weights)  

			
				→ Bool<div style="display: inline" id="span:check_cycle_equality" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes two pure-dimensional polyhedral complexes and checks if they are equal
 i.e. if they have the same lineality space, the same rays (modulo lineality space)
 and the same cones. Optionally, it can also check if the weights are equal</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">X</td><td><div class="descr"><div>A weighted complex</div></div></td></tr><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">Y</td><td><div class="descr"><div>A weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">check_weights</td><td><div class="descr"><div>Whether the algorithm should check for equality of weights. 
 This parameter is optional and true by default</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td><div class="descr"><div>Whether the cycles are equal</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:coarsen" onclick="swap_content('span:coarsen'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="coarsen" onclick="swap_content('span:coarsen'); return false;"><b>coarsen</b></a>
			(complex, testFan)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:coarsen" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a tropical variety on which a coarsest polyhedral structure exists
 and computes this structure.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">complex</td><td><div class="descr"><div>A tropical variety which has a unique 
 coarsest polyhedral structre </div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">testFan</td><td><div class="descr"><div>(Optional, FALSE by default). Whether the algorithm should perform some consistency 
 checks on the result. If true, it will check the following: 
 - That equivalence classes of cones have convex support
 - That all equivalence classes have the same lineality space
 If any condition is violated, the algorithm throws an exception
 Note that it does not check whether equivalence classes form a fan
 This can be done via <a href="#" onclick="unfold('span:');">fan::check_fan</a> afterwards, but it is potentially slow.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The corresponding coarse complex. Throws an 
 exception if testFan = True and consistency checks fail.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:contains_point" onclick="swap_content('span:contains_point'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="contains_point" onclick="swap_content('span:contains_point'); return false;"><b>contains_point</b></a>
			(A, point)  

			
				→ bool<div style="display: inline" id="span:contains_point" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a weighted complex and a point and computed whether that point lies in 
 the complex</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">A</td><td><div class="descr"><div>weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">point</td><td><div class="descr"><div>An arbitrary vector in the same ambient
 dimension as complex. Given in tropical projective coordinates with leading coordinate.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td>bool</td><td><div class="descr"><div>Whether the point lies in the support of complex</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:fan_decomposition" onclick="swap_content('span:fan_decomposition'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="fan_decomposition" onclick="swap_content('span:fan_decomposition'); return false;"><b>fan_decomposition</b></a>
			(C)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:fan_decomposition" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes the local fans at all (nonfar) vertices of a tropical cycle</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>A tropical cycle</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A list of local cycles</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:insert_rays" onclick="swap_content('span:insert_rays'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="insert_rays" onclick="swap_content('span:insert_rays'); return false;"><b>insert_rays</b></a>
			(F, R)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:insert_rays" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a cycle and a list of rays/vertices in tropical projective coordinates with
 leading coordinate and triangulates the fan
 such that it contains these rays</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A cycle (not necessarily weighted).</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">R</td><td><div class="descr"><div>A list of normalized vertices or rays
 Note that the function will NOT subdivide the lineality space, i.e. rays that are 
 equal to an existing ray modulo linealoty space will be ignored.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A triangulation of F that contains all the 
 original rays of F plus the ones in R</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:intersect_container" onclick="swap_content('span:intersect_container'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="intersect_container" onclick="swap_content('span:intersect_container'); return false;"><b>intersect_container</b></a>
			(cycle, container, forceLatticeComputation)  

			
				→ Cycle<div style="display: inline" id="span:intersect_container" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes two Cycles and computes the intersection of both. The function
 relies on the fact that the second cycle contains the first cycle to 
 compute the refinement correctly
 The function copies <a href="#Cycle__WEIGHTS" onclick="unfold('span:Cycle__WEIGHTS');">WEIGHTS</a>, <a href="#Cycle__LATTICE_BASES" onclick="unfold('span:Cycle__LATTICE_BASES');">LATTICE_BASES</a> and <a href="#Cycle__LATTICE_GENERATORS" onclick="unfold('span:Cycle__LATTICE_GENERATORS');">LATTICE_GENERATORS</a>
 in the obvious manner if they exist.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">cycle</td><td><div class="descr"><div>An arbitrary Cycle</div></div></td></tr><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">container</td><td><div class="descr"><div>A cycle containing the first one (as a set)
 Doesn't need to have any weights and its tropical addition is irrelevant.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">forceLatticeComputation</td><td><div class="descr"><div>Whether the properties
 <a href="#Cycle__LATTICE_BASES" onclick="unfold('span:Cycle__LATTICE_BASES');">LATTICE_BASES</a> and <a href="#Cycle__LATTICE_GENERATORS" onclick="unfold('span:Cycle__LATTICE_GENERATORS');">LATTICE_GENERATORS</a> of cycle should be computed
 before refining. False by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The intersection of both complexes
 (whose support is equal to the support of cycle).
 It uses the same tropical addition as cycle.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:recession_fan" onclick="swap_content('span:recession_fan'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="recession_fan" onclick="swap_content('span:recession_fan'); return false;"><b>recession_fan</b></a>
			(complex)  

			
				→ Cycle<div style="display: inline" id="span:recession_fan" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the recession fan of a tropical variety. WARNING: This is a highly experimental
 function. If it works at all, it is likely to take a very long time for larger objects.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">complex</td><td><div class="descr"><div>A tropical variety</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>A tropical fan, the recession fan of the complex</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:shift_cycle" onclick="swap_content('span:shift_cycle'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="shift_cycle" onclick="swap_content('span:shift_cycle'); return false;"><b>shift_cycle</b></a>
			&lt;Addition&gt;
		 
			(C, T)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:shift_cycle" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the shift of a tropical cycle by a given vector</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>a tropical cycle</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">T</td><td><div class="descr"><div>The translate. Optional and zero vector by default. Should be given in
 tropical projective coordinates (but without leading coordinate for vertices or rays).</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The shifted cycle</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:skeleton_complex" onclick="swap_content('span:skeleton_complex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="skeleton_complex" onclick="swap_content('span:skeleton_complex'); return false;"><b>skeleton_complex</b></a>
			(C, k, preserveRays)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:skeleton_complex" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a polyhedral complex and computes the k-skeleton. Will return an empty cycle, 
 if k is larger then the dimension of the given complex or smaller than 0.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">C</td><td><div class="descr"><div>A polyhedral complex.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The dimension of the skeleton that should be computed</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">preserveRays</td><td><div class="descr"><div>When true, the function assumes that all rays of the fan remain
 in the k-skeleton, so it just copies the VERTICES, instead of computing an irredundant list.
 By default, this property is false.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The k-skeleton (without any weights, except if k is the dimension of C</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:triangulateCycle" onclick="swap_content('span:triangulateCycle'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="triangulateCycle" onclick="swap_content('span:triangulateCycle'); return false;"><b>triangulateCycle</b></a>
			(F)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:triangulateCycle" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a cycle and computes a triangulation</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A cycle (not necessarily weighted)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>A simplicial refinement of F</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Conversion_of_tropical_addition" onclick="swap_content('span:functions__Conversion_of_tropical_addition'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Conversion_of_tropical_addition" onclick="swap_content('span:functions__Conversion_of_tropical_addition'); return false;"><span class="category">Conversion of tropical addition</span></a></h3></div><div style="display: inline" id="span:functions__Conversion_of_tropical_addition" class="foldit"><div class="descr"><p> These functions deal with the conversion of tropical objects between Min and Max.</p></div><ul><li><div class="li"><div class="icon" id="icon:dual_addition_version__Cycle_Addition__Bool" onclick="swap_content('span:dual_addition_version__Cycle_Addition__Bool'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__Cycle_Addition__Bool" onclick="swap_content('span:dual_addition_version__Cycle_Addition__Bool'); return false;"><b>dual_addition_version</b></a>
			(cycle, strong_conversion)  

			
				→ Cycle<div style="display: inline" id="span:dual_addition_version__Cycle_Addition__Bool" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a tropical cycle and returns a tropical cycle that 
 uses the opposite tropical addition. By default, the signs of the vertices are inverted.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">cycle</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">strong_conversion</td><td><div class="descr"><div>This is optional and TRUE by default.
 It indicates, whether the signs of the vertices should be inverted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dual_addition_version__TropicalNumber_Addition__Bool" onclick="swap_content('span:dual_addition_version__TropicalNumber_Addition__Bool'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__TropicalNumber_Addition__Bool" onclick="swap_content('span:dual_addition_version__TropicalNumber_Addition__Bool'); return false;"><b>dual_addition_version</b></a>
			(number, strong_conversion)  

			
				→ TropicalNumber<div style="display: inline" id="span:dual_addition_version__TropicalNumber_Addition__Bool" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a tropical number and returns a tropical number that 
 uses the opposite tropical addition. By default, the sign is inverted.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">TropicalNumber&lt;Addition&gt;</a></td><td class="param">number</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">strong_conversion</td><td><div class="descr"><div>This is optional and TRUE by default.
 It indicates, whether the sign of the number should be inverted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">TropicalNumber</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dual_addition_version__Vector_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Vector_TropicalNumber_Addition___Bool'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__Vector_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Vector_TropicalNumber_Addition___Bool'); return false;"><b>dual_addition_version</b></a>
			(vector, strong_conversion)  

			
				→ Vector&lt;TropicalNumber&gt;<div style="display: inline" id="span:dual_addition_version__Vector_TropicalNumber_Addition___Bool" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a vector of tropical numbers and returns a vector that 
 uses the opposite tropical addition. By default, the signs of the entries are inverted.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">vector</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">strong_conversion</td><td><div class="descr"><div>This is optional and TRUE by default.
 It indicates, whether the signs of the entries should be inverted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;TropicalNumber&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dual_addition_version__Matrix_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Matrix_TropicalNumber_Addition___Bool'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__Matrix_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Matrix_TropicalNumber_Addition___Bool'); return false;"><b>dual_addition_version</b></a>
			(matrix, strong_conversion)  

			
				→ Matrix&lt;TropicalNumber&gt;<div style="display: inline" id="span:dual_addition_version__Matrix_TropicalNumber_Addition___Bool" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a matrix of tropical numbers and returns a matrix that 
 uses the opposite tropical addition. By default, the signs of the entries are inverted.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">matrix</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">strong_conversion</td><td><div class="descr"><div>This is optional and TRUE by default.
 It indicates, whether the signs of the entries should be inverted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;TropicalNumber&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dual_addition_version__Ring_TropicalNumber_Addition_" onclick="swap_content('span:dual_addition_version__Ring_TropicalNumber_Addition_'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__Ring_TropicalNumber_Addition_" onclick="swap_content('span:dual_addition_version__Ring_TropicalNumber_Addition_'); return false;"><b>dual_addition_version</b></a>
			(ring)  

			
				→ Ring&lt;TropicalNumber&gt;<div style="display: inline" id="span:dual_addition_version__Ring_TropicalNumber_Addition_" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a ring over the tropical numbers and returns a ring that
 uses the opposite tropical addition. Variable names are preserved</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Ring&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">ring</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Ring&lt;TropicalNumber&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dual_addition_version__Polynomial_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Polynomial_TropicalNumber_Addition___Bool'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dual_addition_version__Polynomial_TropicalNumber_Addition___Bool" onclick="swap_content('span:dual_addition_version__Polynomial_TropicalNumber_Addition___Bool'); return false;"><b>dual_addition_version</b></a>
			(polynomial, strong_conversion)  

			
				→ Polynomial&lt;TropicalNumber&gt;<div style="display: inline" id="span:dual_addition_version__Polynomial_TropicalNumber_Addition___Bool" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a tropical polynomial and returns a tropical polynomial that 
 uses the opposite tropical addition. By default, the signs of the coefficients are inverted.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Polynomial&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">polynomial</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">strong_conversion</td><td><div class="descr"><div>This is optional and TRUE by default.
 It indicates, whether the signs of the coefficients should be inverted.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Polynomial&lt;TropicalNumber&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Creation_function_for_specific_morphisms_and_functions" onclick="swap_content('span:functions__Creation_function_for_specific_morphisms_and_functions'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Creation_function_for_specific_morphisms_and_functions" onclick="swap_content('span:functions__Creation_function_for_specific_morphisms_and_functions'); return false;"><span class="category">Creation function for specific morphisms and functions</span></a></h3></div><div style="display: inline" id="span:functions__Creation_function_for_specific_morphisms_and_functions" class="foldit"><div class="descr"><p> These functions create specific morphisms and functions.</p></div><ul><li><div class="li"><div class="icon" id="icon:projection_map__Int__Set_Int" onclick="swap_content('span:projection_map__Int__Set_Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="projection_map__Int__Set_Int" onclick="swap_content('span:projection_map__Int__Set_Int'); return false;"><b>projection_map</b></a>
			&lt;Addition&gt;
		 
			(n, s)  

			
				→ Morphism&lt;Addition&gt;<div style="display: inline" id="span:projection_map__Int__Set_Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This creates a linear projection from the projective torus of dimension n to a given set
 of coordinates. </p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The dimension of the projective torus which is the domain of the projection.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Set&lt;Int&gt;</a></td><td class="param">s</td><td><div class="descr"><div>The set of coordinaes to which the map should project. Should be
 a subset of (0,..,n)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism&lt;Addition&gt;</a></td><td><div class="descr"><div>The projection map.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:projection_map__Int__Int" onclick="swap_content('span:projection_map__Int__Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="projection_map__Int__Int" onclick="swap_content('span:projection_map__Int__Int'); return false;"><b>projection_map</b></a>
			(n, m)  

			
				→ Morphism<div style="display: inline" id="span:projection_map__Int__Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes the projection from a projective torus of given dimension to a projective
 torus of lower dimension which lives on the first coordinates</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The dimension of the larger torus</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">m</td><td><div class="descr"><div>The dimension of the smaller torus</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td><div class="descr"><div>The projection map</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Creation_functions_for_specific_cycles" onclick="swap_content('span:functions__Creation_functions_for_specific_cycles'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Creation_functions_for_specific_cycles" onclick="swap_content('span:functions__Creation_functions_for_specific_cycles'); return false;"><span class="category">Creation functions for specific cycles</span></a></h3></div><div style="display: inline" id="span:functions__Creation_functions_for_specific_cycles" class="foldit"><div class="descr"><p> These functions are special +++ for creating special tropical cycles.</p></div><ul><li><div class="li"><div class="icon" id="icon:affine_linear_space" onclick="swap_content('span:affine_linear_space'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="affine_linear_space" onclick="swap_content('span:affine_linear_space'); return false;"><b>affine_linear_space</b></a>
			&lt;Addition&gt;
		 
			(lineality, translate, weight)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:affine_linear_space" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This creates a true affine linear space.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">lineality</td><td><div class="descr"><div>(Row) generators of the lineality space, in tropical
 homogeneous coordinates, but without the leading zero</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">translate</td><td><div class="descr"><div>Optional. The vertex of the space. By default this is
 the origin</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">weight</td><td><div class="descr"><div>Optional. The weight of the space. By default, this is 1.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:cross_variety" onclick="swap_content('span:cross_variety'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cross_variety" onclick="swap_content('span:cross_variety'); return false;"><b>cross_variety</b></a>
			&lt;Addition&gt;
		 
			(n, k, h, weight)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:cross_variety" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This creates the k-skeleton of the tropical variety dual to the cross polytope</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The (projective) ambient dimension</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The (projective) dimension of the variety.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Rational</a></td><td class="param">h</td><td><div class="descr"><div>Optional, 1 by default. It is a nonnegative number, describing the 
 height of the one interior lattice point of the cross polytope. </div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">weight</td><td><div class="descr"><div>Optional, 1 by default. The (global) weight of the variety</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The k-skeleton of the tropical hypersurface dual to the cross
 polytope. It is a smooth (for weight 1), irreducible (for h &gt; 0) variety, which is invariant under reflection.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:empty_cycle" onclick="swap_content('span:empty_cycle'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="empty_cycle" onclick="swap_content('span:empty_cycle'); return false;"><b>empty_cycle</b></a>
			&lt;Addition&gt;
		 
			(ambient_dim)  

			
				→ Cycle<div style="display: inline" id="span:empty_cycle" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the empty cycle in a given ambient dimension
 (i.e. it will set the property <a href="#Cycle__PROJECTIVE_AMBIENT_DIM" onclick="unfold('span:Cycle__PROJECTIVE_AMBIENT_DIM');">PROJECTIVE_AMBIENT_DIM</a>.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Max or Min</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">ambient_dim</td><td><div class="descr"><div>The ambient dimension</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The empty cycle</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:halfspace_subdivision" onclick="swap_content('span:halfspace_subdivision'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="halfspace_subdivision" onclick="swap_content('span:halfspace_subdivision'); return false;"><b>halfspace_subdivision</b></a>
			&lt;Addition&gt;
		 
			(a, g, The)  

			
				→ Cycle<div style="display: inline" id="span:halfspace_subdivision" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates a subdivision of the tropical projective torus
 along an affine hyperplane into two halfspaces.
 This hyperplane is defined by an equation gx = a</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Max or Min</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Rational</a></td><td class="param">a</td><td><div class="descr"><div>The constant coefficient of the equation</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">g</td><td><div class="descr"><div>The linear coefficients of the equation
 Note that the equation must be homogeneous in the sense that (1,..1)
 is in its kernel, i.e. all entries of g add up to 0.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">The</td><td><div class="descr"><div>(constant) weight this cycle should have</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The halfspace subdivision</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:orthant_subdivision" onclick="swap_content('span:orthant_subdivision'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="orthant_subdivision" onclick="swap_content('span:orthant_subdivision'); return false;"><b>orthant_subdivision</b></a>
			&lt;Addition&gt;
		 
			(point, chart, weight)  

			<div style="display: inline" id="span:orthant_subdivision" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the orthant subdivision around a given point on a given chart,
 i.e. the corresponding affine chart of this cycle consists of all 2^n fulldimensional orthants</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">point</td><td><div class="descr"><div>The vertex of the subdivision. Should be given in tropical homogeneous coordinates with leading coordinate.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">chart</td><td><div class="descr"><div>On which chart the cones should be orthants, 0 by default.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">weight</td><td><div class="descr"><div>The constant weight of the cycle, 1 by default.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:point_collection" onclick="swap_content('span:point_collection'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="point_collection" onclick="swap_content('span:point_collection'); return false;"><b>point_collection</b></a>
			&lt;Addition&gt;
		 
			(points, weights)  

			
				→ Cycle<div style="display: inline" id="span:point_collection" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates a cycle consisting of a collection of points
 with given weights</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Max or Min</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">points</td><td><div class="descr"><div>The points, in tropical homogeneous coordinates
 (though not with leading ones for vertices).</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Integer&gt;</a></td><td class="param">weights</td><td><div class="descr"><div>The list of weights for the points</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The point collection.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:projective_torus" onclick="swap_content('span:projective_torus'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="projective_torus" onclick="swap_content('span:projective_torus'); return false;"><b>projective_torus</b></a>
			&lt;Addition&gt;
		 
			(n, w)  

			
				→ Cycle<div style="display: inline" id="span:projective_torus" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the tropical projective torus of a given dimension.
 In less fancy words, the cycle is the complete complex
 of given (tropical projective) dimension n, i.e. R<sup>n</sup></p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Max or Min.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The tropical projective dimension.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">w</td><td><div class="descr"><div>The weight of the cycle. Optional and 1 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The tropical projective torus.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:uniform_linear_space" onclick="swap_content('span:uniform_linear_space'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="uniform_linear_space" onclick="swap_content('span:uniform_linear_space'); return false;"><b>uniform_linear_space</b></a>
			&lt;Addition&gt;
		 
			(n, k, weight)  

			
				→ Cycle<div style="display: inline" id="span:uniform_linear_space" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the linear space of the uniform matroid of rank k+1 on n+1 variables.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>A The tropical addition (min or max)</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The ambient (projective) dimension.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The (projective dimension of the fan.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">weight</td><td><div class="descr"><div>The global weight of the cycle. 1 by default.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>A tropical linear space.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Degeneracy_tests" onclick="swap_content('span:functions__Degeneracy_tests'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Degeneracy_tests" onclick="swap_content('span:functions__Degeneracy_tests'); return false;"><span class="category">Degeneracy tests</span></a></h3></div><div style="display: inline" id="span:functions__Degeneracy_tests" class="foldit"><div class="descr"><p> These functions test cycles for degeneracy, i.e. whether a cycle is the empty cycle</p></div><ul><li><div class="li"><div class="icon" id="icon:is_empty" onclick="swap_content('span:is_empty'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="is_empty" onclick="swap_content('span:is_empty'); return false;"><b>is_empty</b></a>
			()  

			<div style="display: inline" id="span:is_empty" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This tests wheter a cycle is the empty cycle.</p></div></div><div class="level3"></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Divisor_computation" onclick="swap_content('span:functions__Divisor_computation'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Divisor_computation" onclick="swap_content('span:functions__Divisor_computation'); return false;"><span class="category">Divisor computation</span></a></h3></div><div style="display: inline" id="span:functions__Divisor_computation" class="foldit"><div class="descr"><p> These functions deal with the computation of divisors</p></div><ul><li><div class="li"><div class="icon" id="icon:divisor" onclick="swap_content('span:divisor'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="divisor" onclick="swap_content('span:divisor'); return false;"><b>divisor</b></a>
			(C, F)  

			
				→ Cycle<div style="display: inline" id="span:divisor" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes the divisor of one or more rational functions on a tropical cycle.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">C</td><td><div class="descr"><div>A tropical cycle</div></div></td></tr><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td class="param">F</td><td><div class="descr"><div>An arbitrary list of rational functions (r_1,...r_n). The <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>
 of r_i should contain the support of r_{i-1} * ... * r_1 * C. Note that using the ^-operator
 on these rational functions is allowed and will result in applying the corresponding function several times.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The divisor r_n * ... * r_1 * C</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:divisor_nr" onclick="swap_content('span:divisor_nr'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="divisor_nr" onclick="swap_content('span:divisor_nr'); return false;"><b>divisor_nr</b></a>
			(C, F)  

			
				→ Cycle<div style="display: inline" id="span:divisor_nr" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes the divisor of one or more rational functions on a tropical cycle.
 It should only be called, if the <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a> of all occuring cycles is the cycle itself. 
 This function will be faster than <a href="#divisor" onclick="unfold('span:divisor');">divisor</a>, since it computes no refinements.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">C</td><td><div class="descr"><div>A tropical cycle</div></div></td></tr><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td class="param">F</td><td><div class="descr"><div>An arbitrary list of rational functions (r_1,...r_n). The <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>
 of each function should be equal (in terms of <a href="#" onclick="unfold('span:');">VERTICES</a> and <a href="#" onclick="unfold('span:');">MAXIMAL_POLYTOPES</a>) to the cycle.
 Note that using the ^-operator on these rational functions is allowed and will result in 
 applying the corresponding function several times.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The divisor r_n * ... * r_1 * C</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:piecewise_divisor" onclick="swap_content('span:piecewise_divisor'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="piecewise_divisor" onclick="swap_content('span:piecewise_divisor'); return false;"><b>piecewise_divisor</b></a>
			(F, cones, coefficients)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:piecewise_divisor" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes a divisor of a linear sum of certain piecewise polynomials on a simplicial 
 fan. </p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A simplicial fan without lineality space in non-homog.
 coordinates</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">IncidenceMatrix</a></td><td class="param">cones</td><td><div class="descr"><div>A list of cones of F (not maximal, but all of the same 
 dimension). Each cone t corresponds to a piecewise polynomial psi_t, defined by 
 subsequently applying the rational functions that are 1 one exactly one ray of t and 
 0 elsewhere. 
 Note that cones should refer to indices in <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a>, which may have
 a different order</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Integer&gt;</a></td><td class="param">coefficients</td><td><div class="descr"><div>A list of coefficients a_t corresponding to the 
 cones. </div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The divisor sum_t a_t psi_t * F</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Hurwitz_cycles" onclick="swap_content('span:functions__Hurwitz_cycles'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Hurwitz_cycles" onclick="swap_content('span:functions__Hurwitz_cycles'); return false;"><span class="category">Hurwitz cycles</span></a></h3></div><div style="display: inline" id="span:functions__Hurwitz_cycles" class="foldit"><div class="descr"><p> These functions deal with the creation and study of tropical Hurwitz cycles.</p></div><ul><li><div class="li"><div class="icon" id="icon:hurwitz_cycle" onclick="swap_content('span:hurwitz_cycle'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hurwitz_cycle" onclick="swap_content('span:hurwitz_cycle'); return false;"><b>hurwitz_cycle</b></a>
			&lt;Addition&gt;
		 
			(k, degree, points)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:hurwitz_cycle" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes the Hurwitz cycle H_k(x), x = (x_1,...,x_n)</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, where the coordinates live.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The dimension of the Hurwitz cycle, i.e. the number of moving vertices</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">degree</td><td><div class="descr"><div>The degree x. Should add up to 0</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">points</td><td><div class="descr"><div>Optional. Should have length n-3-k. Gives the images of 
 the fixed vertices (besides 0). If not given all fixed vertices are mapped to 0
 and the function computes the recession fan of H_k(x)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>H_k(x), in homogeneous coordinates</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hurwitz_marked_cycle" onclick="swap_content('span:hurwitz_marked_cycle'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hurwitz_marked_cycle" onclick="swap_content('span:hurwitz_marked_cycle'); return false;"><b>hurwitz_marked_cycle</b></a>
			&lt;Addition&gt;
		 
			(k, degree, pullback_points)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:hurwitz_marked_cycle" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the marked k-dimensional tropical Hurwitz cycle H_k(degree)</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td>int</td><td class="param">k</td><td><div class="descr"><div>The dimension of the Hurwitz cycle</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">degree</td><td><div class="descr"><div>The degree of the covering. The sum over all entries should 
 be 0 and if n := degree.dim, then 0 &lt;= k &lt;= n-3</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">pullback_points</td><td><div class="descr"><div>The points p_i that should be pulled back to 
 determine the Hurwitz cycle (in addition to 0). Should have length n-3-k. If it is not given, 
 all p_i are by default equal to 0 (same for missing points)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The marked Hurwitz cycle H~_k(degree)</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hurwitz_pair" onclick="swap_content('span:hurwitz_pair'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hurwitz_pair" onclick="swap_content('span:hurwitz_pair'); return false;"><b>hurwitz_pair</b></a>
			&lt;Addition&gt;
		 
			(k, degree, points)  

			
				→ An<div style="display: inline" id="span:hurwitz_pair" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes hurwitz_subdivision and hurwitz_cycle at the same time, 
 returning the result in an array</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, where the coordinates live.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The dimension of the Hurwitz cycle, i.e. the number of moving vertices</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">degree</td><td><div class="descr"><div>The degree x. Should add up to 0</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">points</td><td><div class="descr"><div>Optional. Should have length n-3-k. Gives the images of 
 the fixed vertices (besides 0). If not given all fixed vertices are mapped to 0
 and the function computes the subdivision of M_0,n containing the recession fan of H_k(x)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td>An</td><td><div class="descr"><div>array, containing first the subdivision of M_0,n, then the Hurwitz cycle</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hurwitz_pair_local" onclick="swap_content('span:hurwitz_pair_local'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hurwitz_pair_local" onclick="swap_content('span:hurwitz_pair_local'); return false;"><b>hurwitz_pair_local</b></a>
			&lt;Addition&gt;
		 
			(k, degree, local_curve)  

			<div style="display: inline" id="span:hurwitz_pair_local" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Does the same as hurwitz_pair, except that no points are given and the user can give a 
 RationalCurve object representing a ray. If given, the computation
 will be performed locally around the ray.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, where the coordinates live.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">degree</td><td></td></tr><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">local_curve</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hurwitz_subdivision" onclick="swap_content('span:hurwitz_subdivision'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hurwitz_subdivision" onclick="swap_content('span:hurwitz_subdivision'); return false;"><b>hurwitz_subdivision</b></a>
			&lt;Addition&gt;
		 
			(k, degree, points)  

			
				→ Cycle<div style="display: inline" id="span:hurwitz_subdivision" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes a subdivision of M_0,n containing the Hurwitz cycle
 H_k(x), x = (x_1,...,x_n) as a subfan. If k = n-4, this subdivision is the unique
 coarsest subdivision fulfilling this property</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, where the coordinates live.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The dimension of the Hurwitz cycle, i.e. the number of moving vertices</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">degree</td><td><div class="descr"><div>The degree x. Should add up to 0</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">points</td><td><div class="descr"><div>Optional. Should have length n-3-k. Gives the images of 
 the fixed vertices (besides the first one, which always goes to 0) as elements of R.
 If not given, all fixed vertices are mapped to 0
 and the function computes the subdivision of M_0,n containing the recession fan of H_k(x)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>A subdivision of M_0,n</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Intersection_theory" onclick="swap_content('span:functions__Intersection_theory'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Intersection_theory" onclick="swap_content('span:functions__Intersection_theory'); return false;"><span class="category">Intersection theory</span></a></h3></div><div style="display: inline" id="span:functions__Intersection_theory" class="foldit"><div class="descr"><p> These are general functions related to intersection theory.</p></div><ul><li><div class="li"><div class="icon" id="icon:degree" onclick="swap_content('span:degree'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="degree" onclick="swap_content('span:degree'); return false;"><b>degree</b></a>
			(A)  

			
				→ Integer<div style="display: inline" id="span:degree" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the degree of a tropical variety as the total weight of the
 0-dimensional intersection product obtained by intersecting with the
 complementary uniform linear space.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">A</td><td><div class="descr"><div>tropical cycle</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td><div class="descr"><div>The degree </div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:intersect" onclick="swap_content('span:intersect'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="intersect" onclick="swap_content('span:intersect'); return false;"><b>intersect</b></a>
			(X, Y)  

			
				→ Cycle<div style="display: inline" id="span:intersect" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the intersection product of two tropical cycles in the projective torus
 Use <a href="#" onclick="unfold('span:');" class="invalid">intersection_check_transversality</a> to check for transversal intersections</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">X</td><td><div class="descr"><div>A tropical cycle</div></div></td></tr><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">Y</td><td><div class="descr"><div>A tropical cycle, living in the same ambient space as X</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The intersection product</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:intersect_check_transversality" onclick="swap_content('span:intersect_check_transversality'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="intersect_check_transversality" onclick="swap_content('span:intersect_check_transversality'); return false;"><b>intersect_check_transversality</b></a>
			(X, Y, ensure_transversality)  

			
				→ A<div style="display: inline" id="span:intersect_check_transversality" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the intersection product of two tropical cycles in R^n and tests whether the intersection is transversal.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">X</td><td><div class="descr"><div>A tropical cycle</div></div></td></tr><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">Y</td><td><div class="descr"><div>A tropical cycle, living in the same space as X</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">ensure_transversality</td><td><div class="descr"><div>Whether non-transversal intersections should not be computed. Optional and false by default. If true,
 returns the zero cycle if it detects a non-transversal intersection</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td>A</td><td><div class="descr"><div>tuple containing:
 A Cycle: The intersection product. Zero cycle if ensure_transversality is true and the intersection is not transversal.
 A Bool: Whether the intersection is transversal. This is always false, if the codimensions of the varieties add up to more than the ambient dimension.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:pullback" onclick="swap_content('span:pullback'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="pullback" onclick="swap_content('span:pullback'); return false;"><b>pullback</b></a>
			(m, r)  

			
				→ RationalFunction<div style="display: inline" id="span:pullback" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes the pullback of a rational function via a morphism
 Due to the implementation of composition of maps, the <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a> of the
 rational function need not be contained in the image of the morphism
 The pullback will be defined in the preimage of the domain.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td class="param">m</td><td><div class="descr"><div>A morphism.</div></div></td></tr><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td class="param">r</td><td><div class="descr"><div>A rational function.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#RationalFunction" onclick="unfold('span:RationalFunction');">RationalFunction</a></td><td><div class="descr"><div>The pullback m*r.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Inverse_problems" onclick="swap_content('span:functions__Inverse_problems'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Inverse_problems" onclick="swap_content('span:functions__Inverse_problems'); return false;"><span class="category">Inverse problems</span></a></h3></div><div style="display: inline" id="span:functions__Inverse_problems" class="foldit"><div class="descr"><p> These functions deal with finding rational functions to given divisors.</p></div><ul><li><div class="li"><div class="icon" id="icon:cutting_functions" onclick="swap_content('span:cutting_functions'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cutting_functions" onclick="swap_content('span:cutting_functions'); return false;"><b>cutting_functions</b></a>
			(F, weight_aim)  

			
				→ Matrix&lt;Rational&gt;<div style="display: inline" id="span:cutting_functions" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a weighted complex and a list of desired weights on its codimension one
 faces and computes all possible rational functions on (this subdivision of )
 the complex</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A tropical variety, assumed to be simplicial.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Integer&gt;</a></td><td class="param">weight_aim</td><td><div class="descr"><div>A list of weights, whose length should be equal
 to the number of <a href="#Cycle__CODIMENSION_ONE_POLYTOPES" onclick="unfold('span:Cycle__CODIMENSION_ONE_POLYTOPES');">CODIMENSION_ONE_POLYTOPES</a>. Gives the desired weight on each 
 codimension one face</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td><div class="descr"><div>The space of rational functions defined on this 
 particular subdivision. Each row is a generator. The columns correspond to 
 values on <a href="#Cycle__SEPARATED_VERTICES" onclick="unfold('span:Cycle__SEPARATED_VERTICES');">SEPARATED_VERTICES</a> and <a href="#" onclick="unfold('span:');" class="invalid">LINEALITY_SPACE</a>, except the last one,
 which is either 0 (then this 
 function cuts out zero and can be added to any solution) or non-zero (then 
 normalizing this entry to -1 gives a function cutting out the desired weights 
 on the codimension one skeleton
 Note that the function does not test if these generators actually define
 piecewise linear functions, as it assumes the cycle is simplicial</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:simplicial_diagonal_system" onclick="swap_content('span:simplicial_diagonal_system'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="simplicial_diagonal_system" onclick="swap_content('span:simplicial_diagonal_system'); return false;"><b>simplicial_diagonal_system</b></a>
			(fan)  

			
				→ Matrix&lt;Rational&gt;<div style="display: inline" id="span:simplicial_diagonal_system" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function computes the inhomogeneous version of simplicial_piecewise_system
 in the sense that it computes the result of the above mentioned function (i.e. 
 which coefficients for the piecewise polynomials yield the zero divisor)
 and adds another column at the end where only the entries corresponding to the 
 diagonal cones are 1, the rest is zero. This can be seen as asking for a 
 solution to the system that cuts out the diagonal (all solutions whose last entry is 1)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">fan</td><td><div class="descr"><div>. A simplicial fan without lineality space.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:simplicial_piecewise_system" onclick="swap_content('span:simplicial_piecewise_system'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="simplicial_piecewise_system" onclick="swap_content('span:simplicial_piecewise_system'); return false;"><b>simplicial_piecewise_system</b></a>
			(F)  

			
				→ Matrix&lt;Rational&gt;<div style="display: inline" id="span:simplicial_piecewise_system" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a d-dimensional simplicial fan F and computes the linear system 
 defined in the following way: For each d-dimensional cone t in the diagonal subdivision of FxF, let psi_t be the 
 piecewise polynomial defined by subsequently applying the rational functions that 
 are 1 one exactly one ray of t and 0 elsewhere. Now for which coefficients a_t
 is sum_t a_t psi_t * (FxF) = 0?</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A simplicial fan without lineality space</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td><div class="descr"><div>The above mentioned linear system. The rows 
 are equations, the columns correspond to d-dimensional cones of FxF in the order given 
 by skeleton_complex(simplicial_with_diagonal(F), d,TRUE)</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:simplicial_with_diagonal" onclick="swap_content('span:simplicial_with_diagonal'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="simplicial_with_diagonal" onclick="swap_content('span:simplicial_with_diagonal'); return false;"><b>simplicial_with_diagonal</b></a>
			(F)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:simplicial_with_diagonal" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This function takes a simplicial fan F (without 
 lineality space) and computes the coarsest subdivision of F x F containing all 
 diagonal rays (r,r)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">F</td><td><div class="descr"><div>A simplicial fan without lineality space.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The product complex FxF subdivided such that it contains 
 all diagonal rays</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Lattices" onclick="swap_content('span:functions__Lattices'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Lattices" onclick="swap_content('span:functions__Lattices'); return false;"><span class="category">Lattices</span></a></h3></div><div style="display: inline" id="span:functions__Lattices" class="foldit"><div class="descr"><p> These functions deal with lattices (meaning free abelian, finitely generated groups).</p></div><ul><li><div class="li"><div class="icon" id="icon:lattice_index" onclick="swap_content('span:lattice_index'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="lattice_index" onclick="swap_content('span:lattice_index'); return false;"><b>lattice_index</b></a>
			(m)  

			
				→ Integer<div style="display: inline" id="span:lattice_index" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes the index of a lattice in its saturation.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Integer&gt;</a></td><td class="param">m</td><td><div class="descr"><div>A list of (row) generators of the lattice.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td><div class="descr"><div>The index of the lattice in its saturation.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:randomInteger" onclick="swap_content('span:randomInteger'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="randomInteger" onclick="swap_content('span:randomInteger'); return false;"><b>randomInteger</b></a>
			(max_arg, n)  

			
				→ Array&lt;Integer&gt;<div style="display: inline" id="span:randomInteger" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Returns n random integers in the range 0.. (max_arg-1),inclusive
 Note that this algorithm is not optimal for real randomness:
 If you change the range parameter and then change it back, you will
 usually get the exact same sequence as the first time</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td>int</td><td class="param">max_arg</td><td><div class="descr"><div>The upper bound for the random integers</div></div></td></tr><tr><td>int</td><td class="param">n</td><td><div class="descr"><div>The number of integers to be created</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Array&lt;Integer&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Lines_in_surfaces" onclick="swap_content('span:functions__Lines_in_surfaces'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Lines_in_surfaces" onclick="swap_content('span:functions__Lines_in_surfaces'); return false;"><span class="category">Lines in surfaces</span></a></h3></div><div style="display: inline" id="span:functions__Lines_in_surfaces" class="foldit"><div class="descr"><p> These functions deal with the computation and representation of (families of) lines
 in surfaces.</p></div><ul><li><div class="li"><div class="icon" id="icon:lines_in_cubic" onclick="swap_content('span:lines_in_cubic'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="lines_in_cubic" onclick="swap_content('span:lines_in_cubic'); return false;"><b>lines_in_cubic</b></a>
			(p)  

			
				→ LinesInCubic&lt;Addition&gt;<div style="display: inline" id="span:lines_in_cubic" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes either:
 - A homogeneous polynomial of degree 3 in 4 variables or
 - A polynomial of degree 3 in 3 variables
 and computes the corresponding
 cubic and finds all tropical lines and families thereof in the cubic.
 The result is returned as a <a href="#LinesInCubic" onclick="unfold('span:LinesInCubic');">LinesInCubic</a> object.
 Note that the function has some heuristics for recognizing families, but might still return
 a single family as split up into two.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Polynomial&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">p</td><td><div class="descr"><div>A homogeneous tropical polynomial of degree 3
 in four variables.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#LinesInCubic" onclick="unfold('span:LinesInCubic');">LinesInCubic&lt;Addition&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Local_computations" onclick="swap_content('span:functions__Local_computations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Local_computations" onclick="swap_content('span:functions__Local_computations'); return false;"><span class="category">Local computations</span></a></h3></div><div style="display: inline" id="span:functions__Local_computations" class="foldit"><div class="descr"><p> These functions are used for doing computations locally around a specified part of a Cycle.
-----
 These +++ deal with the creation and modification of cycles with nontrivial
 <a href="#Cycle__LOCAL_RESTRICTION" onclick="unfold('span:Cycle__LOCAL_RESTRICTION');">LOCAL_RESTRICTION</a>.</p></div><ul><li><div class="li"><div class="icon" id="icon:local_codim_one" onclick="swap_content('span:local_codim_one'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="local_codim_one" onclick="swap_content('span:local_codim_one'); return false;"><b>local_codim_one</b></a>
			(complex, face)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:local_codim_one" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a weighted complex and an index of one of its codimension one faces
 (The index is in CODIMENSION_ONE_POLYTOPES) and computes the complex locally restricted
 to that face</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">complex</td><td><div class="descr"><div>An arbitrary weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">face</td><td><div class="descr"><div>An index of a face in CODIMENSION_ONE_POLYTOPES</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The complex locally restricted to the given face</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:local_point" onclick="swap_content('span:local_point'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="local_point" onclick="swap_content('span:local_point'); return false;"><b>local_point</b></a>
			(complex, v)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:local_point" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a weighted complex and an arbitrary vertex in homogeneous 
 coordinates (including the leading coordinate) that is supposed to lie 
 in the support of the complex.
 It then refines the complex such that the vertex is a cell in the polyhedral 
 structure and returns the complex localized at this vertex</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">complex</td><td><div class="descr"><div>An arbitrary weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Rational&gt;</a></td><td class="param">v</td><td><div class="descr"><div>A vertex in homogeneous coordinates and with leading coordinate. It should lie
 in the support of the complex (otherwise an error is thrown)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The complex localized at the vertex</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:local_restrict" onclick="swap_content('span:local_restrict'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="local_restrict" onclick="swap_content('span:local_restrict'); return false;"><b>local_restrict</b></a>
			(complex, cones)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:local_restrict" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a tropical variety and an IncidenceMatrix describing a set
 of cones (not necessarily maximal ones) of this variety. It will then
 create a variety that contains all compatible maximal cones and is
 locally restricted to the given cone set.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">complex</td><td><div class="descr"><div>An arbitrary weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">IncidenceMatrix</a></td><td class="param">cones</td><td><div class="descr"><div>A set of cones, indices refer to VERTICES</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The same complex, locally restricted to the given
 cones</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:local_vertex" onclick="swap_content('span:local_vertex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="local_vertex" onclick="swap_content('span:local_vertex'); return false;"><b>local_vertex</b></a>
			(complex, ray)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:local_vertex" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This takes a weighted complex and an index of one of its vertices 
 (the index is to be understood in VERTICES)
 It then localizes the variety at this vertex. The index should never
 correspond to a far vertex in a complex, since this would not be a cone</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">complex</td><td><div class="descr"><div>An arbitrary weighted complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">ray</td><td><div class="descr"><div>The index of a ray/vertex in RAYS</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The complex locally restricted to the given vertex</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Matroids" onclick="swap_content('span:functions__Matroids'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Matroids" onclick="swap_content('span:functions__Matroids'); return false;"><span class="category">Matroids</span></a></h3></div><div style="display: inline" id="span:functions__Matroids" class="foldit"><div class="descr"><p> These functions deal with matroids and matroidal fans.</p></div><ul><li><div class="li"><div class="icon" id="icon:is_smooth" onclick="swap_content('span:is_smooth'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="is_smooth" onclick="swap_content('span:is_smooth'); return false;"><b>is_smooth</b></a>
			(a)  

			
				→ perl::ListReturn<div style="display: inline" id="span:is_smooth" class="foldit"><br /><div class="descr_func"><div class="descr"><p>Takes a weighted fan and returns if it is smooth 
 (i.e. isomorphic to a Bergman fan B(M)/L for some matroid M) or not. 
 The algorithm works for fans of dimension 0,1,2 and 
 codimension 0,1! For other dimensions the algorithm 
 could give an answer but it is not guaranteed. </p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">a</td><td><div class="descr"><div>tropical fan F</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td>perl::ListReturn</td><td><div class="descr"><div>containing an integer s, 
 a matroid M and a Morphism&lt;Addition&gt; A. If s=1 then F is smooth, the 
 corresponding matroid fan is Z-isomorphic to the matroid fan 
 associated to M. The Z-isomorphism is given by A, i.e.
 B(M)/L = affine_transform(F,A)
 If s=0, F is not smooth. If s=2 the algorithm is not able to determine 
 if F is smooth or not. </div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:matroid_fan__matroid_Matroid" onclick="swap_content('span:matroid_fan__matroid_Matroid'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="matroid_fan__matroid_Matroid" onclick="swap_content('span:matroid_fan__matroid_Matroid'); return false;"><b>matroid_fan</b></a>
			&lt;Addition&gt;
		 
			(m)  

			
				→ Cycle<div style="display: inline" id="span:matroid_fan__matroid_Matroid" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Uses an algorithm by Felipe Rincón to compute the matroidal fan of a given matroid.
 If you have a matrix at hand that represents this matroid, it is recommended to call
 this function with that matrix as an argument - it is significantly faster.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max - determines the coordinates.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">matroid::Matroid</a></td><td class="param">m</td><td><div class="descr"><div>A matroid</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The matroidal fan or Bergman fan of the matroid.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:matroid_fan__Matrix_Rational" onclick="swap_content('span:matroid_fan__Matrix_Rational'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="matroid_fan__Matrix_Rational" onclick="swap_content('span:matroid_fan__Matrix_Rational'); return false;"><b>matroid_fan</b></a>
			&lt;Addition&gt;
		 
			(m)  

			
				→ Cycle<div style="display: inline" id="span:matroid_fan__Matrix_Rational" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Uses an algorithm by Felipe Rincón to compute the bergman fan of the column matroid
 of the given matrix. Calling the function in this manner is significantly faster than calling it
 on the matroid.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max - determines the coordinates.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">m</td><td><div class="descr"><div>A matrix, whose column matroid is considered.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The matroidal fan or Bergman fan of the matroid.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:matroid_fan_from_flats" onclick="swap_content('span:matroid_fan_from_flats'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="matroid_fan_from_flats" onclick="swap_content('span:matroid_fan_from_flats'); return false;"><b>matroid_fan_from_flats</b></a>
			&lt;Addition&gt;
		 
			(A)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:matroid_fan_from_flats" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the fan of a matroid in its chains-of-flats subdivision.
 Note that this is potentially very slow for large matroids.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or max, determines the matroid fan coordinates.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">matroid::Matroid</a></td><td class="param">A</td><td><div class="descr"><div>matroid. Should be loopfree.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:matroid_from_fan" onclick="swap_content('span:matroid_from_fan'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="matroid_from_fan" onclick="swap_content('span:matroid_from_fan'); return false;"><b>matroid_from_fan</b></a>
			(A)  

			
				→ matroid::Matroid<div style="display: inline" id="span:matroid_from_fan" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes the bergman fan of a matroid and reconstructs the corresponding matroid
 The fan has to be given in its actual matroid coordinates, not as an isomorphic
 transform. The actual subdivision is not relevant.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td class="param">A</td><td><div class="descr"><div>tropical cycle, the Bergman fan of a matroid</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">matroid::Matroid</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Moduli_of_rational_curves" onclick="swap_content('span:functions__Moduli_of_rational_curves'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Moduli_of_rational_curves" onclick="swap_content('span:functions__Moduli_of_rational_curves'); return false;"><span class="category">Moduli of rational curves</span></a></h3></div><div style="display: inline" id="span:functions__Moduli_of_rational_curves" class="foldit"><div class="descr"><p> These functions deal with moduli spaces of abstract or parametrized rational curves.</p></div><ul><li><div class="li"><div class="icon" id="icon:count_mn_cones" onclick="swap_content('span:count_mn_cones'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="count_mn_cones" onclick="swap_content('span:count_mn_cones'); return false;"><b>count_mn_cones</b></a>
			(n, k)  

			
				→ Integer<div style="display: inline" id="span:count_mn_cones" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the number of k-dimensional cones of the tropical moduli space M_0,n</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of leaves. Should be &gt;= 3</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">k</td><td><div class="descr"><div>The number of bounded edges. This argument is optional and n-3 by default</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td><div class="descr"><div>The number of k-dimensional cones of M_0,n</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:count_mn_rays" onclick="swap_content('span:count_mn_rays'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="count_mn_rays" onclick="swap_content('span:count_mn_rays'); return false;"><b>count_mn_rays</b></a>
			(n)  

			
				→ Integer<div style="display: inline" id="span:count_mn_rays" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the number of rays of the tropical moduli space M_0,n</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td>int</td><td class="param">n</td><td><div class="descr"><div>The number of leaves. Should be &gt;= 3</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td><div class="descr"><div>The number of rays</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:evaluation_map__Int__Int__Matrix_Rational__Int" onclick="swap_content('span:evaluation_map__Int__Int__Matrix_Rational__Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="evaluation_map__Int__Int__Matrix_Rational__Int" onclick="swap_content('span:evaluation_map__Int__Int__Matrix_Rational__Int'); return false;"><b>evaluation_map</b></a>
			&lt;Addition&gt;
		 
			(n, r, Delta, i)  

			
				→ Morphism&lt;Addition&gt;<div style="display: inline" id="span:evaluation_map__Int__Int__Matrix_Rational__Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This creates the i-th evaluation function on M_0,n^(lab)(R^r,Delta)
 (which is actually realized as M_0,(n+|Delta|) x R^r)
 and can be created via <a href="#space_of_stable_maps" onclick="unfold('span:space_of_stable_maps');">space_of_stable_maps</a>.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of marked (contracted) points</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">r</td><td><div class="descr"><div>The dimension of the embedding space</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">Delta</td><td><div class="descr"><div>The directions of the unbounded edges (given as row vectors 
 in tropical projective coordinates without leading coordinate)</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">i</td><td><div class="descr"><div>The index of the marked point that should be evaluated.
 Should lie in between 1 and n
 Note that the i-th marked point is realized as the |Delta|+i-th leaf in M_0,(n+|Delta|)
 and that the R^r - coordinate is interpreted as the position of the n-th leaf. 
 In particular, ev_n is just the projection to the R^r-coordinates</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism&lt;Addition&gt;</a></td><td><div class="descr"><div>ev_i. Its domain is the ambient space of the moduli space 
 as created by <a href="#space_of_stable_maps" onclick="unfold('span:space_of_stable_maps');">space_of_stable_maps</a>. The target space is the tropical projective
 torus of dimension r</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:evaluation_map__Int__Int__Int__Int" onclick="swap_content('span:evaluation_map__Int__Int__Int__Int'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="evaluation_map__Int__Int__Int__Int" onclick="swap_content('span:evaluation_map__Int__Int__Int__Int'); return false;"><b>evaluation_map</b></a>
			&lt;Addition&gt;
		 
			(n, r, d, i)  

			
				→ Morphism&lt;Addition&gt;<div style="display: inline" id="span:evaluation_map__Int__Int__Int__Int" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This creates the i-th evaluation function on M_0,n^(lab)(R^r,d)
 (which is actually realized as M_0,(n+d(r+1)) x R^r)
 This is the same as calling the function
 evaluation_map(Int,Int,Matrix&lt;Rational&gt;,Int) with the standard d-fold
 degree as matrix (i.e. each (inverted) unit vector of R^(r+1) occuring d times).</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of marked (contracted) points</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">r</td><td><div class="descr"><div>The dimension of the target space</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">d</td><td><div class="descr"><div>The degree of the embedding. The direction matrix will be
 the standard d-fold directions, i.e. each unit vector (inverted for Max),
 occuring d times.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">i</td><td><div class="descr"><div>The index of the marked point that should be evaluated. i 
 should lie in between 1 and n</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism&lt;Addition&gt;</a></td><td><div class="descr"><div>ev_i. Its domain is the ambient space of the moduli space 
 as created by <a href="#space_of_stable_maps" onclick="unfold('span:space_of_stable_maps');">space_of_stable_maps</a>. The target space is the tropical projective
 torus of dimension r</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:forgetful_map" onclick="swap_content('span:forgetful_map'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="forgetful_map" onclick="swap_content('span:forgetful_map'); return false;"><b>forgetful_map</b></a>
			(n, S)  

			
				→ Morphism<div style="display: inline" id="span:forgetful_map" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes the forgetful map from the moduli space M_0,n to M_0,(n-|S|)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of leaves in the moduli space M_0,n</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Set&lt;Int&gt;</a></td><td class="param">S</td><td><div class="descr"><div>The set of leaves to be forgotten. Should be a subset of (1,..,n)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td><div class="descr"><div>The forgetful map. It will identify the remaining leaves 
 i_1,..,i_(n-|S|) with the leaves of M_0,(n-|S|) in canonical order.
 The domain of the morphism is the ambient space of the morphism in matroid coordinates,
 as created by <a href="#m0n" onclick="unfold('span:m0n');">m0n</a>.</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:local_m0n" onclick="swap_content('span:local_m0n'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="local_m0n" onclick="swap_content('span:local_m0n'); return false;"><b>local_m0n</b></a>
			&lt;Addition&gt;
		 
			(R ...)  

			
				→ Cycle&lt;Addition&gt;<div style="display: inline" id="span:local_m0n" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the moduli space M_0,n locally around a given list of combinatorial
 types. More precisely: It computes the weighted complex consisting of all
 maximal cones containing any of the given combinatorial types and localizes 
 at these types 
 This should only be used for curves of small codimension. What the function 
 actually does, is that it combinatorially computes the cartesian products 
 of M_0,v's, where v runs over the possible valences of vertices in the curves
 For max(v) &lt;= 8 this should terminate in a reasonable time (depending on the 
 number of curves)
 The coordinates are the same that would be produced by the function 
 <a href="#m0n" onclick="unfold('span:m0n');">m0n</a></p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max, determines the coordinates</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#RationalCurve" onclick="unfold('span:RationalCurve');">RationalCurve</a></td><td class="param">R ...</td><td><div class="descr"><div>A list of rational curves (preferrably in the same M_0,n)</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle&lt;Addition&gt;</a></td><td><div class="descr"><div>The local complex</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:m0n" onclick="swap_content('span:m0n'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="m0n" onclick="swap_content('span:m0n'); return false;"><b>m0n</b></a>
			&lt;Addition&gt;
		 
			(n)  

			
				→ Cycle<div style="display: inline" id="span:m0n" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the moduli space of abstract rational n-marked curves. Its coordinates are
 given as the coordinates of the bergman fan of the matroid of the complete graph on 
 n-1 nodes (but not computed as such)
 The isomorphism to the space of curve metrics is obtained by choosing
 the last leaf as special leaf</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of leaves. Should be at least 3</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The tropical moduli space M_0,n</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:psi_class" onclick="swap_content('span:psi_class'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="psi_class" onclick="swap_content('span:psi_class'); return false;"><b>psi_class</b></a>
			&lt;Addition&gt;
		 
			(n, i)  

			
				→ Cycle<div style="display: inline" id="span:psi_class" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the i-th psi class in the moduli space of n-marked rational tropical curves
 M_0,n</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of leaves in M_0,n</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">i</td><td><div class="descr"><div>The leaf for which we want to compute the psi class ( in 1,..,n )</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The corresponding psi class</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:psi_product" onclick="swap_content('span:psi_product'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="psi_product" onclick="swap_content('span:psi_product'); return false;"><b>psi_product</b></a>
			&lt;Addition&gt;
		 
			(n, exponents)  

			
				→ Cycle<div style="display: inline" id="span:psi_product" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes a product of psi classes psi_1^k_1 * ... * psi_n^k_n on the moduli space
 of rational n-marked tropical curves M_0,n</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of leaves in M_0,n</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Int&gt;</a></td><td class="param">exponents</td><td><div class="descr"><div>The exponents of the psi classes k_1,..,k_n. If the 
 vector does not have length n or if some entries are negative, an error is thrown</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The corresponding psi class divisor</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:space_of_stable_maps" onclick="swap_content('span:space_of_stable_maps'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="space_of_stable_maps" onclick="swap_content('span:space_of_stable_maps'); return false;"><b>space_of_stable_maps</b></a>
			&lt;Addition&gt;
		 
			(n, d, r)  

			
				→ Cycle<div style="display: inline" id="span:space_of_stable_maps" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Creates the moduli space of stable maps of rational n-marked curves into a 
 projective torus. It is given as the cartesian product of M_{0,n+d} and R^r,
 where n is the number of contracted leaves, d the number of non-contracted leaves
 and r is the dimension of the target torus. The R^r - coordinate is interpreted as 
 the image of the last (n-th) contracted leaf.
 Due to the implementation of <a href="#cartesian_product" onclick="unfold('span:cartesian_product');">cartesian_product</a>, the projective coordinates are
 non-canonical: Both M_{0,n+d} and R^r are dehomogenized after the first coordinate, then
 the product is taken and homogenized after the first coordinate again.
 Note that functions in a-tint will usually treat this space in such a way that the
 first d leaves are the non-contracted ones and the remaining n leaves are the 
 contracted ones.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div>Min or Max. Determines the coordinates.</div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>The number of contracted leaves</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">d</td><td><div class="descr"><div>The number of non-contracted leaves</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">r</td><td><div class="descr"><div>The dimension of the target space for the stable maps.</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td><div class="descr"><div>The moduli space of rational stable maps.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Morphisms" onclick="swap_content('span:functions__Morphisms'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Morphisms" onclick="swap_content('span:functions__Morphisms'); return false;"><span class="category">Morphisms</span></a></h3></div><div style="display: inline" id="span:functions__Morphisms" class="foldit"><div class="descr"><p> These are general functions that deal with morphisms and their arithmetic.</p></div><ul><li><div class="li"><div class="icon" id="icon:add_morphisms" onclick="swap_content('span:add_morphisms'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="add_morphisms" onclick="swap_content('span:add_morphisms'); return false;"><b>add_morphisms</b></a>
			(f, g)  

			
				→ Morphism<div style="display: inline" id="span:add_morphisms" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the sum of two morphisms. Both <a href="#Morphism__DOMAIN" onclick="unfold('span:Morphism__DOMAIN');">DOMAIN</a>s should have the same support
 and the target spaces should have the same ambient dimension
 The domain of the result will be the common refinement of the two domains.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td class="param">f</td><td></td></tr><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td class="param">g</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Morphism" onclick="unfold('span:Morphism');">Morphism</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Other" onclick="swap_content('span:functions__Other'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Other" onclick="swap_content('span:functions__Other'); return false;"><span class="category">Other</span></a></h3></div><div style="display: inline" id="span:functions__Other" class="foldit"><div class="descr"><p> Special purpose functions.</p></div><ul><li><div class="li"><div class="icon" id="icon:ch2d_3phases" onclick="swap_content('span:ch2d_3phases'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="ch2d_3phases" onclick="swap_content('span:ch2d_3phases'); return false;"><b>ch2d_3phases</b></a>
			(n, Types, G)  

			
				→ Array&lt;int&gt;<div style="display: inline" id="span:ch2d_3phases" class="foldit"><br /><div class="descr_func"><div class="descr"><p> List the pseudovertices of a 2-dimensional tropical polytope on the boundary
 in counter-clockwise cyclic order.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Int</a></td><td class="param">n</td><td><div class="descr"><div>the number of generators</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Array&lt;Array&lt;Set&gt;&gt;</a></td><td class="param">Types</td><td><div class="descr"><div>the types of the generators</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Graph</a></td><td class="param">G</td><td><div class="descr"><div>the <a href="#TropicalPolytope__PSEUDOVERTEX_GRAPH" onclick="unfold('span:TropicalPolytope__PSEUDOVERTEX_GRAPH');">PSEUDOVERTEX_GRAPH</a></div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Array&lt;int&gt;</a></td><td><div class="descr"><div>the pseudovertices on the boundary</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:check_minimality" onclick="swap_content('span:check_minimality'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="check_minimality" onclick="swap_content('span:check_minimality'); return false;"><b>check_minimality</b></a>
			(T, I, n)  

			
				→ Set<div style="display: inline" id="span:check_minimality" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Checks the three criteria of Gaubert and Katz to be
 the type <em class="param">T</em> of an apex of a minimal tropical halfspace.
 It is assumed that the points that the type refers to are given by 0,...,<em class="param">n</em>-1
 and that the index set <em class="param">I</em> is a subset of 0,...,<em class="param">d</em>-1
 where <em class="param">d</em> is the <a href="#TropicalPolytope__AMBIENT_DIM" onclick="unfold('span:TropicalPolytope__AMBIENT_DIM');">AMBIENT_DIM</a> of the tropical polytope.
 If the input fulfills all criteria, the output set is empty.
 If the input doesn't fulfill the first criterion the whole set 0,...,<em class="param">d</em>-1 is given back.
 If the input doesn't fulfill the second and third criterion, then the violating indices are stored.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Array&lt;Set&gt;</a></td><td class="param">T</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Set</a></td><td class="param">I</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Integer</a></td><td class="param">n</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Set</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:coarse_types" onclick="swap_content('span:coarse_types'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="coarse_types" onclick="swap_content('span:coarse_types'); return false;"><b>coarse_types</b></a>
			&lt;Coord&gt;
		 
			(points, generators)  

			
				→ Array&lt; Array&lt;int&gt;&gt;<div style="display: inline" id="span:coarse_types" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the coarse types of the <em class="param">points</em> set relative to a set of <em class="param">generators</em>.
 The following are two typical cases:
</p><blockquote><div> (1) <em class="param">points</em> = <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a> and <em class="param">generators</em> = <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a></div><div> (2) <em class="param">points</em> = <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a>  and <em class="param">generators</em> = <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a></div></blockquote></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Coord&gt;</a></td><td class="param">points</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Coord&gt;</a></td><td class="param">generators</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Array&lt; Array&lt;int&gt;&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:extract_pseudovertices" onclick="swap_content('span:extract_pseudovertices'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="extract_pseudovertices" onclick="swap_content('span:extract_pseudovertices'); return false;"><b>extract_pseudovertices</b></a>
			(T, P)  

			<div style="display: inline" id="span:extract_pseudovertices" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Get the pseudovertices of a tropical polytope <em class="param">T</em> from the bounded subcomplex of the corresponding unbounded polyhedron <em class="param">P</em>.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td class="param">P</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:get_corners" onclick="swap_content('span:get_corners'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="get_corners" onclick="swap_content('span:get_corners'); return false;"><b>get_corners</b></a>
			(input)  

			
				→ Matrix<div style="display: inline" id="span:get_corners" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the corners of a tropical polytope given by its vertices.
 Cf.
</p><blockquote><div> M. Joswig, arXiv:0809.4694v2, Lemma 17.</div></blockquote></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">input</td><td><div class="descr"><div>points</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:lifted_pluecker" onclick="swap_content('span:lifted_pluecker'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="lifted_pluecker" onclick="swap_content('span:lifted_pluecker'); return false;"><b>lifted_pluecker</b></a>
			(V)  

			
				→ Vector<div style="display: inline" id="span:lifted_pluecker" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the tropical Pluecker vector from a matrix representing points in the tropical torus.
 This can be used to lift regular subdivisions of a product of simplices to a
 matroid decomposition of hypersimplices.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">V</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:minimal_tropical_halfspaces" onclick="swap_content('span:minimal_tropical_halfspaces'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="minimal_tropical_halfspaces" onclick="swap_content('span:minimal_tropical_halfspaces'); return false;"><b>minimal_tropical_halfspaces</b></a>
			&lt;Coord&gt;
		 
			(T)  

			
				→ hash_set&lt; Pair&lt;Vector&lt;Coord&gt;,Set&lt;Int&gt; &gt; &gt;<div style="display: inline" id="span:minimal_tropical_halfspaces" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the minimal tropical halfspaces of a
 tropical polytope <em class="param">T</em>.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td>hash_set&lt; Pair&lt;Vector&lt;Coord&gt;,Set&lt;Int&gt; &gt; &gt;</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:types" onclick="swap_content('span:types'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="types" onclick="swap_content('span:types'); return false;"><b>types</b></a>
			&lt;Coord&gt;
		 
			(points, generators)  

			
				→ Array&lt;Array&lt;Set&gt;&gt;<div style="display: inline" id="span:types" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the fine types of the <em class="param">points</em> set relative to a set of <em class="param">generators</em>.
 The following are two typical cases:
</p><blockquote><div> (1) <em class="param">points</em> = <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a> and <em class="param">generators</em> = <a href="#TropicalPolytope__VERTICES" onclick="unfold('span:TropicalPolytope__VERTICES');">VERTICES</a></div><div> (2) <em class="param">points</em> = <a href="#TropicalPolytope__POINTS" onclick="unfold('span:TropicalPolytope__POINTS');">POINTS</a>  and <em class="param">generators</em> = <a href="#TropicalPolytope__PSEUDOVERTICES" onclick="unfold('span:TropicalPolytope__PSEUDOVERTICES');">PSEUDOVERTICES</a></div></blockquote></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Coord&gt;</a></td><td class="param">points</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Coord&gt;</a></td><td class="param">generators</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Array&lt;Array&lt;Set&gt;&gt;</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Producing_a_tropical_hypersurface" onclick="swap_content('span:functions__Producing_a_tropical_hypersurface'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Producing_a_tropical_hypersurface" onclick="swap_content('span:functions__Producing_a_tropical_hypersurface'); return false;"><span class="category">Producing a tropical hypersurface</span></a></h3></div><div style="display: inline" id="span:functions__Producing_a_tropical_hypersurface" class="foldit"><div class="descr"><p> These functions produce a <a href="#Hypersurface" onclick="unfold('span:Hypersurface');">tropical hypersurface</a> from other objects.</p></div><ul><li><div class="li"><div class="icon" id="icon:hyperplane" onclick="swap_content('span:hyperplane'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hyperplane" onclick="swap_content('span:hyperplane'); return false;"><b>hyperplane</b></a>
			&lt;Addition&gt;
		 
			(coeffs)  

			
				→ Hypersurface&lt;Addition&gt;<div style="display: inline" id="span:hyperplane" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Create a tropical hyperplane as object of type Hypersurface.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div><a href="#" onclick="unfold('span:');">Min</a> or <a href="#" onclick="unfold('span:');">Max</a></div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;TropicalNumber&lt;Addition&gt; &gt;</a></td><td class="param">coeffs</td><td><div class="descr"><div>coefficients of the tropical linear form 
 (can also be specified as anonymous array).</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Hypersurface" onclick="unfold('span:Hypersurface');">Hypersurface&lt;Addition&gt;</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hypersurface_union" onclick="swap_content('span:hypersurface_union'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hypersurface_union" onclick="swap_content('span:hypersurface_union'); return false;"><b>hypersurface_union</b></a>
			(H1, H2, internal)  

			
				→ Hypersurface<div style="display: inline" id="span:hypersurface_union" class="foldit"><br /><div class="descr_func"><div class="undoc">UNDOCUMENTED</div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Hypersurface" onclick="unfold('span:Hypersurface');">Hypersurface</a></td><td class="param">H1</td><td></td></tr><tr><td><a href="#Hypersurface" onclick="unfold('span:Hypersurface');">Hypersurface</a></td><td class="param">H2</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Bool</a></td><td class="param">internal</td><td><div class="descr"><div>default 1: both input hyperplanes lie in the same space</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Hypersurface" onclick="unfold('span:Hypersurface');">Hypersurface</a></td><td><div class="descr"><div>H1 cup H2</div></div></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:points2hypersurface" onclick="swap_content('span:points2hypersurface'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="points2hypersurface" onclick="swap_content('span:points2hypersurface'); return false;"><b>points2hypersurface</b></a>
			&lt;Addition&gt;
		 
			(points)  

			
				→ Hypersurface<div style="display: inline" id="span:points2hypersurface" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Constructs a tropical hypersurface defined by the linear
 hypersurfaces associated to the points.
 If the points are part of a min-tropical polytope then the output is a
 max-tropical hypersurface, and conversely.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div><a href="#" onclick="unfold('span:');">Min</a> or <a href="#" onclick="unfold('span:');">Max</a>, default <a href="#" onclick="unfold('span:');">Min</a></div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">points</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#Hypersurface" onclick="unfold('span:Hypersurface');">Hypersurface</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Producing_a_tropical_polytope" onclick="swap_content('span:functions__Producing_a_tropical_polytope'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Producing_a_tropical_polytope" onclick="swap_content('span:functions__Producing_a_tropical_polytope'); return false;"><span class="category">Producing a tropical polytope</span></a></h3></div><div style="display: inline" id="span:functions__Producing_a_tropical_polytope" class="foldit"><div class="descr"><p> These functions produce an object of type <a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a> from other objects.</p></div><ul><li><div class="li"><div class="icon" id="icon:cornered_hull" onclick="swap_content('span:cornered_hull'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cornered_hull" onclick="swap_content('span:cornered_hull'); return false;"><b>cornered_hull</b></a>
			(T)  

			
				→ TropicalPolytope<div style="display: inline" id="span:cornered_hull" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the cornered hull of a tropical polytope.
 Cf.
</p><blockquote><div> M. Joswig, arXiv:0809.4694v2, Lemma 17.</div></blockquote></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:cyclic" onclick="swap_content('span:cyclic'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cyclic" onclick="swap_content('span:cyclic'); return false;"><b>cyclic</b></a>
			(d, n)  

			
				→ TropicalPolytope<div style="display: inline" id="span:cyclic" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Produces a tropical cyclic <em class="param">d</em>-polytope with <em class="param">n</em> vertices.
 Cf.
</p><blockquote><div> Josephine Yu &amp; Florian Block, arXiv: math.MG/0503279.</div></blockquote></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td>int</td><td class="param">d</td><td><div class="descr"><div>the dimension</div></div></td></tr><tr><td>int</td><td class="param">n</td><td><div class="descr"><div>the number of generators</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:discard_non_vertices" onclick="swap_content('span:discard_non_vertices'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="discard_non_vertices" onclick="swap_content('span:discard_non_vertices'); return false;"><b>discard_non_vertices</b></a>
			(points)  

			
				→ Matrix<div style="display: inline" id="span:discard_non_vertices" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Given points in the tropical projective space, discard all the non-vertices of the tropical convex hull.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">points</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:dualize" onclick="swap_content('span:dualize'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="dualize" onclick="swap_content('span:dualize'); return false;"><b>dualize</b></a>
			&lt;Coord&gt;
		 
			(points, generators)  

			
				→ Matrix<div style="display: inline" id="span:dualize" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Dualizes a point set with respect to the generators of a tropical polytope.
 The points are dualized with respect to the (rows of the) matrix of the generators.
 Cf.
</p><blockquote><div> Develin &amp; Sturmfels, Tropical Convexity, Lemma 22.</div></blockquote></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">points</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td class="param">generators</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:hypersimplex" onclick="swap_content('span:hypersimplex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="hypersimplex" onclick="swap_content('span:hypersimplex'); return false;"><b>hypersimplex</b></a>
			(k, d)  

			
				→ TropicalPolytope<div style="display: inline" id="span:hypersimplex" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Produce the tropical hypersimplex Δ(<em class="param">k</em>,<em class="param">d</em>).
 Cf.
</p><blockquote><div> M. Joswig math/0312068v3, Ex. 2.10.</div></blockquote><p> The value of <em class="param">k</em> defaults to 1, yielding a tropical standard simplex.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td>int</td><td class="param">k</td><td><div class="descr"><div>the number of -1 entries</div></div></td></tr><tr><td>int</td><td class="param">d</td><td><div class="descr"><div>the dimension</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:minkowski_sum" onclick="swap_content('span:minkowski_sum'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="minkowski_sum" onclick="swap_content('span:minkowski_sum'); return false;"><b>minkowski_sum</b></a>
			&lt;Coord&gt;
		 
			(lambda, P, mu, Q)  

			
				→ TropicalPolytope<div style="display: inline" id="span:minkowski_sum" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Produces the tropical polytope (<em class="param">lambda</em> \( \otimes \) <em class="param">P</em>) \( \oplus \) (<em class="param">mu</em> \( \otimes \) <em class="param">Q</em>), where \( \otimes \) and \( \oplus \) are tropical scalar multiplication
 and tropical addition, respectively.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td>Scalar</td><td class="param">lambda</td><td></td></tr><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">P</td><td></td></tr><tr><td>Scalar</td><td class="param">mu</td><td></td></tr><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">Q</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:poly2trop" onclick="swap_content('span:poly2trop'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="poly2trop" onclick="swap_content('span:poly2trop'); return false;"><b>poly2trop</b></a>
			(P)  

			
				→ TropicalPolytope<div style="display: inline" id="span:poly2trop" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes an ordinary convex polytope and interprets it in tropical projective space.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td class="param">P</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:tropical_matroid_polytope" onclick="swap_content('span:tropical_matroid_polytope'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="tropical_matroid_polytope" onclick="swap_content('span:tropical_matroid_polytope'); return false;"><b>tropical_matroid_polytope</b></a>
			(m, v)  

			
				→ TropicalPolytope<div style="display: inline" id="span:tropical_matroid_polytope" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Produce the tropical matroid polytope from a matroid <em class="param">m</em>.
 Each vertex corresponds to a basis of the matroid,
 the non-bases coordinates get value 0, the bases coordinates
 get value <em class="param">v</em>, default is -1.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">matroid::Matroid</a></td><td class="param">m</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Rational</a></td><td class="param">v</td><td><div class="descr"><div>value for the bases</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Producing_another_object" onclick="swap_content('span:functions__Producing_another_object'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Producing_another_object" onclick="swap_content('span:functions__Producing_another_object'); return false;"><span class="category">Producing another object</span></a></h3></div><div style="display: inline" id="span:functions__Producing_another_object" class="foldit"><div class="descr"><p> These functions produce an object of another type not contained in application tropical.</p></div><ul><li><div class="li"><div class="icon" id="icon:cornered_hull_poly" onclick="swap_content('span:cornered_hull_poly'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="cornered_hull_poly" onclick="swap_content('span:cornered_hull_poly'); return false;"><b>cornered_hull_poly</b></a>
			(T)  

			
				→ polytope::Polytope<div style="display: inline" id="span:cornered_hull_poly" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the cornered hull of a tropical polytope.
 Cf.
</p><blockquote><div> M. Joswig, arXiv:0809.4694v2, Lemma 17.</div></blockquote></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:pseudovertices2poly" onclick="swap_content('span:pseudovertices2poly'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="pseudovertices2poly" onclick="swap_content('span:pseudovertices2poly'); return false;"><b>pseudovertices2poly</b></a>
			(T)  

			
				→ polytope::Polytope<div style="display: inline" id="span:pseudovertices2poly" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a tropical polytope <em class="param">T</em> and interprets it in Euclidean space.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:trop2poly" onclick="swap_content('span:trop2poly'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="trop2poly" onclick="swap_content('span:trop2poly'); return false;"><b>trop2poly</b></a>
			&lt;Coord&gt;
		 
			(T)  

			
				→ polytope::Polytope<div style="display: inline" id="span:trop2poly" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Given points in tropical projective space, compute an ordinary unbounded polyhedron such that
 the tropical convex hull of the input is the bounded subcomplex of the latter.
 Cf.
</p><blockquote><div> Develin &amp; Sturmfels math.MG/0308254v2, Lemma 22.</div></blockquote><p> Warning: This client does not implement the reverse transformation to <a href="#poly2trop" onclick="unfold('span:poly2trop');">poly2trop</a>.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">T</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:tropical_complex" onclick="swap_content('span:tropical_complex'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="tropical_complex" onclick="swap_content('span:tropical_complex'); return false;"><b>tropical_complex</b></a>
			&lt;Coord&gt;
		 
			(points)  

			
				→ fan::PolyhedralComplex<div style="display: inline" id="span:tropical_complex" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the tropical complex of <em class="param">points</em>.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Coord&gt;</a></td><td class="param">points</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:tropical_intersection" onclick="swap_content('span:tropical_intersection'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="tropical_intersection" onclick="swap_content('span:tropical_intersection'); return false;"><b>tropical_intersection</b></a>
			&lt;Coord&gt;
		 
			(pc1, pc2)  

			
				→ fan::PolyhedralComplex<div style="display: inline" id="span:tropical_intersection" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the intersection of two polyhedral complexes.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex</a></td><td class="param">pc1</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex</a></td><td class="param">pc2</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">fan::PolyhedralComplex</a></td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Tropical_operations" onclick="swap_content('span:functions__Tropical_operations'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Tropical_operations" onclick="swap_content('span:functions__Tropical_operations'); return false;"><span class="category">Tropical operations</span></a></h3></div><div style="display: inline" id="span:functions__Tropical_operations" class="foldit"><div class="descr"><p> These functions deal with general tropical arithmetic.</p></div><ul><li><div class="li"><div class="icon" id="icon:nearest_point" onclick="swap_content('span:nearest_point'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="nearest_point" onclick="swap_content('span:nearest_point'); return false;"><b>nearest_point</b></a>
			&lt;Coord&gt;
		 
			(P, x)  

			
				→ Vector<div style="display: inline" id="span:nearest_point" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Compute the projection of a point <em class="param">x</em> in  tropical projective space onto a tropical polytope <em class="param">P</em>.
 Cf.
</p><blockquote><div> Develin &amp; Sturmfels math.MG/0308254v2, Proposition 9.</div></blockquote></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Coord</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#TropicalPolytope" onclick="unfold('span:TropicalPolytope');">TropicalPolytope</a></td><td class="param">P</td><td></td></tr><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Coord&gt;</a></td><td class="param">x</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:norm" onclick="swap_content('span:norm'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="norm" onclick="swap_content('span:norm'); return false;"><b>norm</b></a>
			&lt;Scalar&gt;
		 
			(v)  

			
				→ Scalar<div style="display: inline" id="span:norm" class="foldit"><br /><div class="descr_func"><div class="descr"><p> The <em class="u">tropical norm</em> of a vector <em class="param">v</em> in the tropical torus
 is the difference between the maximal and minimal coordinate 
 in any coordinate representation of the vector.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Scalar</td><td></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Vector&lt;Scalar&gt;</a></td><td class="param">v</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td>Scalar</td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:tdet" onclick="swap_content('span:tdet'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="tdet" onclick="swap_content('span:tdet'); return false;"><b>tdet</b></a>
			&lt;Addition&gt;
		 
			(matrix)  

			
				→ Scalar<div style="display: inline" id="span:tdet" class="foldit"><br /><div class="descr_func"><div class="descr"><p> The <em class="u">tropical determinant</em> of a matrix.</p></div></div><div class="level3"><h5>Type Parameters</h5><table class="args"><tr><td class="param">Addition</td><td><div class="descr"><div><a href="#" onclick="unfold('span:');">Min</a> or <a href="#" onclick="unfold('span:');">Max</a>, default <a href="#" onclick="unfold('span:');">Min</a></div></div></td></tr></table><h5>Parameters</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Scalar&gt;</a></td><td class="param">matrix</td><td></td></tr></table><h5>Returns</h5><table class="args"><tr><td>Scalar</td><td></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Visualization" onclick="swap_content('span:functions__Visualization'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Visualization" onclick="swap_content('span:functions__Visualization'); return false;"><span class="category">Visualization</span></a></h3></div><div style="display: inline" id="span:functions__Visualization" class="foldit"><div class="descr"><p> These functions are for visualization.</p></div><ul><li><div class="li"><div class="icon" id="icon:visualize_in_surface" onclick="swap_content('span:visualize_in_surface'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="visualize_in_surface" onclick="swap_content('span:visualize_in_surface'); return false;"><b>visualize_in_surface</b></a>
			()  

			<div style="display: inline" id="span:visualize_in_surface" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This visualizes a surface in R^3 and an arbitrary list of (possibly non-pure)
 Cycle objects. A common bounding box is computed for all objects and a 
 random color is chosen for each object (except the surface)</p></div></div><div class="level3"></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Weight_space" onclick="swap_content('span:functions__Weight_space'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Weight_space" onclick="swap_content('span:functions__Weight_space'); return false;"><span class="category">Weight space</span></a></h3></div><div style="display: inline" id="span:functions__Weight_space" class="foldit"><div class="descr"><p> These functions deal with the weight space of a cycle, i.e. the space of weights
 that make it balanced and related properties.</p></div><ul><li><div class="li"><div class="icon" id="icon:decomposition_polytope" onclick="swap_content('span:decomposition_polytope'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="decomposition_polytope" onclick="swap_content('span:decomposition_polytope'); return false;"><b>decomposition_polytope</b></a>
			(A)  

			
				→ polytope::Polytope<div style="display: inline" id="span:decomposition_polytope" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Computes the possible positive decompositions into irreducible subvarieties of the same 
 weight positivity signature (i.e. the weight on a cone has to have the same sign as in the cycle)
 To be precise, it computes the irreducible varieties as rays of the weight cone
 (where the corresponding orthant is taken such that the weight vector of X 
 lies in that orthant). It then computes the polytope of all positive linear combinations 
 of those irreducible varieties that produce the original weight vector.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">A</td><td><div class="descr"><div>weighted complex</div></div></td></tr></table><h5>Returns</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">polytope::Polytope</a></td><td></td></tr></table></div></div></div></div></li><li><div class="li"><div class="icon" id="icon:weight_cone" onclick="swap_content('span:weight_cone'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="weight_cone" onclick="swap_content('span:weight_cone'); return false;"><b>weight_cone</b></a>
			(X, negative)  

			<div style="display: inline" id="span:weight_cone" class="foldit"><br /><div class="descr_func"><div class="descr"><p> Takes a polyhedral complex and computes a weight cone, i.e. 
 intersects the <a href="#Cycle__WEIGHT_SPACE" onclick="unfold('span:Cycle__WEIGHT_SPACE');">WEIGHT_SPACE</a> with a chosen orthant (by default the positive orthant)</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">X</td><td><div class="descr"><div>A polyhedral complex</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Set&lt;int&gt;</a></td><td class="param">negative</td><td><div class="descr"><div>A subset of the coordinates {0,..,N-1}, where N is 
 the number of maximal cells of X. Determines the orthant to
 intersect the weight space with: All coordinates in the set are negative, the others positive
 If the set is not given, it is empty by default (i.e. we take the positive orthant)</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li><li><div class="li"><div class="icon" id="icon:functions__Weights_and_lattices" onclick="swap_content('span:functions__Weights_and_lattices'); return false;">
		 	
	</div><div class="unfoldable"><div class="category"><h3><a href="#" class="javalink" id="functions__Weights_and_lattices" onclick="swap_content('span:functions__Weights_and_lattices'); return false;"><span class="category">Weights and lattices</span></a></h3></div><div style="display: inline" id="span:functions__Weights_and_lattices" class="foldit"><div class="descr"><p> These functions relate to the weights of a tropical cycle.</p></div><ul><li><div class="li"><div class="icon" id="icon:is_balanced" onclick="swap_content('span:is_balanced'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="is_balanced" onclick="swap_content('span:is_balanced'); return false;"><b>is_balanced</b></a>
			(C)  

			<div style="display: inline" id="span:is_balanced" class="foldit"><br /><div class="descr_func"><div class="descr"><p> This computes whether a given cycle is balanced.</p></div></div><div class="level3"><h5>Parameters</h5><table class="args"><tr><td><a href="#Cycle" onclick="unfold('span:Cycle');">Cycle</a></td><td class="param">C</td><td><div class="descr"><div>The cycle for which to check balancing.$ @return Bool Whether the cycle is balanced.</div></div></td></tr></table></div></div></div></div></li></ul></div></div></div></li></ul></div><div class="level3"><h2>Common Option Lists</h2><ul class="unfoldable"><li><div class="li"><div class="icon" id="icon:options__Visual_Cycle_BoundingDecorations" onclick="swap_content('span:options__Visual_Cycle_BoundingDecorations'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="options__Visual_Cycle_BoundingDecorations" onclick="swap_content('span:options__Visual_Cycle_BoundingDecorations'); return false;"><b>Visual::Cycle::BoundingDecorations</b></a><div style="display: inline" id="span:options__Visual_Cycle_BoundingDecorations" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div><b>imports from: </b>Visual::Polygons::decorations, Visual::PointSet::decorations<br /><br /><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Flexible&lt;Int&gt;</a></td><td class="param">Chart</td><td><div class="descr"><div>The visualization is always a visualization in affine coordinates. This 
 chooses the chart</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">WeightLabels</td><td><div class="descr"><div>if set to "hidden", the labels indicating the weights are hidden</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">CoordLabels</td><td><div class="descr"><div>If set to "show", the labels indicating the vertex coordinates are displayed, otherwise they are not. Note that this is expensive and significantly increases computation time.</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Flexible&lt;Rational&gt;</a></td><td class="param">BoundingDistance</td><td><div class="descr"><div>The distance of the border of the bounding box from the smallest box 
 containing the affine points of the complex. This is only relevant, if BoundingMode is "relative"</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Matrix&lt;Rational&gt;</a></td><td class="param">BoundingBox</td><td><div class="descr"><div>A fixed bounding box, determined by two row vectors that specify two of its vertices (on "on top" and one "at the bottom"). Is only relevant, if BoundingMode is "absolute"</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">BoundingMode</td><td><div class="descr"><div>If set to "relative", the function determines the smallest possible box containing all affine points of the complex and then enlarges the box by BoundingDistance to all sides. If set to "absolute", BoundingBox must be specified and the complex will be intersected with that box. "cube" does a similar thing as relative, except that the resulting bounding box is always a cube. By default this is set to "cube".</div></div></td></tr><tr><td><a href="#" onclick="unfold('span:');">Array&lt;String&gt;</a></td><td class="param">ConeLabels</td><td><div class="descr"><div>A list of strings to be displayed as labels for the maximal cones. If this is empty, the weight labels (if present and not suppressed by WeightLabels=&gt;"hidden") are displayed</div></div></td></tr></table></div></div></div></li><li><div class="li"><div class="icon" id="icon:options__Visual_Cycle_decorations" onclick="swap_content('span:options__Visual_Cycle_decorations'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="options__Visual_Cycle_decorations" onclick="swap_content('span:options__Visual_Cycle_decorations'); return false;"><b>Visual::Cycle::decorations</b></a><div style="display: inline" id="span:options__Visual_Cycle_decorations" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div><b>imports from: </b>Visual::Polygons::decorations, Visual::PointSet::decorations<br /><br /><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">Flexible&lt;Int&gt;</a></td><td class="param">Chart</td><td><div class="descr"><div>The visualization is always a visualization in affine coordinates. This 
 chooses the chart</div></div></td></tr></table></div></div></div></li><li><div class="li"><div class="icon" id="icon:options__Visual_Cycle_FunctionDecorations" onclick="swap_content('span:options__Visual_Cycle_FunctionDecorations'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="options__Visual_Cycle_FunctionDecorations" onclick="swap_content('span:options__Visual_Cycle_FunctionDecorations'); return false;"><b>Visual::Cycle::FunctionDecorations</b></a><div style="display: inline" id="span:options__Visual_Cycle_FunctionDecorations" class="foldit"><div class="descr"><p>Visualization options for RationalFunction/Morphism-&gt;BB_VISUAL</p></div><b>imports from: </b>Visual::Cycle::BoundingDecorations, Visual::Polygons::decorations, Visual::PointSet::decorations<br /><br /><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">FunctionLabels</td><td><div class="descr"><div>, if set to "show", the function labels indicatingt the affine linear representation of each function
 on each cone are computed</div></div></td></tr></table></div></div></div></li><li><div class="li"><div class="icon" id="icon:options__Visual_RationalCurve_decorations" onclick="swap_content('span:options__Visual_RationalCurve_decorations'); return false;">
		 	
	</div><div class="unfoldable"><a href="#" class="javalink" id="options__Visual_RationalCurve_decorations" onclick="swap_content('span:options__Visual_RationalCurve_decorations'); return false;"><b>Visual::RationalCurve::decorations</b></a><div style="display: inline" id="span:options__Visual_RationalCurve_decorations" class="foldit"><div class="undoc"><p>UNDOCUMENTED</p></div><b>imports from: </b>Visual::Graph::decorations, Visual::Wire::decorations, Visual::PointSet::decorations<br /><br /><h5>Options</h5><table class="args"><tr><td><a href="#" onclick="unfold('span:');">String</a></td><td class="param">LengthLabels</td><td><div class="descr"><div>if set to "hidden", the labels indicating the lengths are hidden</div></div></td></tr></table></div></div></div></li></ul></div></div>
      </div>
    </div>
    <div id="footer"></div>
  </body>
</html>
