<?xml version="1.0"?>
<pm:polymake_apps xmlns:pm="http://www.polymake.de/ns/docs#3"><application xmlns="http://www.polymake.de/ns/docs#3" xmlns:html="http://www.w3.org/1999/xhtml" name="atint">
  <description>UNDOCUMENTED</description>
  <imports-from>
    <application name="graph"/>
    <application name="common"/>
  </imports-from>
  <uses>
    <application name="fan"/>
    <application name="topaz"/>
    <application name="polytope"/>
    <application name="tropical"/>
    <application name="group"/>
    <application name="matroid"/>
  </uses>
  <common-option-lists>
    <common-option-list name="Visual::WeightedComplex::decorations" id="i17">
      <description><html:p> require Visual;
 require Visual::PointSet;
 require Visual::Wire;
 require Visual::Polygon;</html:p></description>
      <imports-from>
        <common-option-list name="Visual::Polygons::decorations" href="#" class="invalid"/>
        <common-option-list name="Visual::PointSet::decorations" href="#" class="invalid"/>
      </imports-from>
      <option name="DirScale" type="Flexible&lt;Rational&gt;" href="#">
        <description><html:div>length of the directional rays</html:div></description>
      </option>
      <option name="WeightLabels" type="String" href="#">
        <description><html:div>if set to "hidden", the labels indicating the weights are hidden</html:div></description>
      </option>
      <option name="CoordLabels" type="String" href="#">
        <description><html:div>If set to "show", the labels indicating the vertex coordinates are displayed, otherwise they are not. Note that this is expensive and significantly increases computation time.
 String If set to "pinned", the weight labels are computed in such a way that they stick to the cells when the complex
 is exploded. Note that this is expensive and significantly increases computation time.
 WeightLabelStyle =&gt; "",</html:div></description>
      </option>
    </common-option-list>
    <common-option-list name="Visual::WeightedComplex::BoundingDecorations" id="i16">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <imports-from>
        <common-option-list name="Visual::WeightedComplex::decorations" href="#i17" class="invalid"/>
        <common-option-list name="Visual::Polygons::decorations" href="#" class="invalid"/>
        <common-option-list name="Visual::PointSet::decorations" href="#" class="invalid"/>
      </imports-from>
      <option name="BoundingDistance" type="Flexible&lt;Rational&gt;" href="#">
        <description><html:div>The distance of the border of the bounding box from the smallest box 
 containing the affine points of the complex. This is only relevant, if BoundingMode is "relative"</html:div></description>
      </option>
      <option name="BoundingBox" type="Matrix&lt;Rational&gt;" href="#">
        <description><html:div>A fixed bounding box, determined by two row vectors that specify two of its vertices (on "on top" and one "at the bottom"). Is only relevant, if BoundingMode is "absolute"</html:div></description>
      </option>
      <option name="BoundingMode" type="String" href="#">
        <description><html:div>If set to "relative", the function determines the smallest possible box containing all affine points of the complex and then enlarges the box by BoundingDistance to all sides. If set to "absolute", BoundingBox must be specified and the complex will be intersected with that box. By default this is set to "relative".</html:div></description>
      </option>
    </common-option-list>
    <common-option-list name="Visual::RationalCurve::decorations" id="i15">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <imports-from>
        <common-option-list name="Visual::Graph::decorations" href="#" class="invalid"/>
        <common-option-list name="Visual::Wire::decorations" href="#" class="invalid"/>
        <common-option-list name="Visual::PointSet::decorations" href="#" class="invalid"/>
      </imports-from>
      <option name="LengthLabels" type="String" href="#">
        <description><html:div>if set to "hidden", the labels indicating the lengths are hidden</html:div></description>
      </option>
    </common-option-list>
  </common-option-lists>
  <objects>
    <object name="WeightedComplex" id="i18">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <derived-from object="fan::PolyhedralFan&lt;Rational&gt;" href="#" class="invalid"/>
      <properties>
        <category name="Polyhedral complex" id="i83">
          <property name="INPUT_HOM_RAYS" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i100">
            <description><html:p> A matrix of the rays of the fan. This should be used *instead of* <html:a href="#">INPUT_RAYS</html:a>, if the coordinates of the
 fan should be interpreted as homogeneous coordinates and the fan as the complex at x0 = 1.
 The input rays are normalized to x0 = 1 and the fan is then initialized with the normalized rays as
 <html:a href="#">INPUT_RAYS</html:a>.
 <html:a href="#">INPUT_CONES</html:a> can be combined with this as usual. If your rays are already homogenized and you are sure they
 are also your rays, you can directly put this into RAYS and manually set USES_HOMOGENEOUS_C=&gt;TRUE</html:p></description>
          </property>
          <property name="INPUT_HOM_LINEALITY" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i103">
            <description><html:p> A matrix of generators of the lineality space, but in homogeneous coordinates (i.e. x0 should be 0, otherwise 
 this throws an error). This should be used *instead of* <html:a href="#">INPUT_LINEALITY</html:a> / <html:a href="#">LINEALITY_SPACE</html:a></html:p></description>
          </property>
          <property name="USES_HOMOGENEOUS_C" type="common::Bool" href="#" class="invalid" id="i104">
            <description><html:p> Indicates whethere this fan's coordinates should be interpreted as affine coordinates or as homogeneous coordinates.
 In the latter case the fan would actually represent the polyhedral complex that comes from intersecting the fan
 (in affine coordinates) with the affine hyperplane x0 = 1. This property should not be set manually. It will be set
 as true, if <html:a href="#i100">INPUT_HOM_RAYS</html:a> or <html:a href="#i103">INPUT_HOM_LINEALITY</html:a> are used and to false, if <html:a href="#">INPUT_RAYS</html:a> or <html:a href="#">INPUT_LINEALITY</html:a>
 are used.</html:p></description>
          </property>
          <property name="CMPLX_RAYS" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i99">
            <description><html:p> If the fan does not use homogeneous coordinates, this is just a copy of RAYS and actually needn't be requested. Otherwise this computes
 a matrix of rays of the complex obtained by intersecting the fan with {x0 = 1}. More precisely, each ray r from <html:a href="#">RAYS</html:a> occurs  
 as a row in this matrix...
 - once, if r_0 = 1
 - k times, if r_0 = 0 and k is the number of equivalence classes of maximal cones containing r with respect to the following relation:
 Two maximal cones m, m' containing r are equivalent, if they are equal or there exists a sequence of maximal cones
 m = m_1,...m_r = m', such that r is contained in each m_i and each intersection m_i cap m_i+1 contains at least one ray s with s_0 = 1.
 The reason for this is that, when specifying a piecewise affine linear function on a polyhedral complex, the same directional ray with 
 x0 = 0 might be assigned two different values, if it is contained in two "non-connected" maximal cones (where connectedness is to be 
 understood as described above).</html:p></description>
          </property>
          <property name="CMPLX_MAXIMAL_CONES" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i106">
            <description><html:p> An incidence matrix describing which maximal cone in the complex at x0 = 1 is generated by which rays. 
 Each row corresponds to a maximal cone (More precisely, the i-th element represents the
 same maximal cone as the i-th element of <html:a href="#">MAXIMAL_CONES</html:a>). The indices in a row refer to rows of <html:a href="#i99">CMPLX_RAYS</html:a>, i.e. the maximal
 cone described by the i-th element is generated by the rays corresponding to these row indices.
 If the fan does not use homogeneous coordinates, it is just a copy of <html:a href="#">MAXIMAL_CONES</html:a></html:p></description>
          </property>
          <property name="CMPLX_CODIM_1_FACES" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i105">
            <description><html:p> An incidence matrix describing which codim 1 cone in the complex at x0 = 1 is generated by which rays. 
 Each row corresponds to a codimension one cone (More precisely, the i-th element represents the
 same codim 1 cone as the i-th element of <html:a href="#i111">CODIM_1_FACES</html:a>). The indices in a row refer to rows of <html:a href="#i99">CMPLX_RAYS</html:a>, i.e. the cone
 cone described by the i-th element is generated by the rays corresponding to these row indices.
 If the fan does not use homogeneous coordinates, it is just a copy of <html:a href="#i111">CODIM_1_FACES</html:a>.</html:p></description>
          </property>
          <property name="CMPLX_DIM" type="common::Int" href="#" class="invalid" id="i98">
            <description><html:p> Returns the dimension of the polyhedral complex. In the case of non-homogeneous coordinates, this is 
 just DIM, otherwise DIM-1. When computing this property, it is assumed that the complex is pure.</html:p></description>
          </property>
          <property name="CMPLX_AMBIENT_DIM" type="common::Int" href="#" class="invalid" id="i107">
            <description><html:p> Returns the ambient dimension of the polyhedral complex. In the case of non-homogeneous coordinates, this is 
 just FAN_AMBIENT_DIM, otherwise FAN_AMBIENT_DIM-1</html:p></description>
          </property>
          <property name="CMPLX_CODIMENSION" type="common::Int" href="#" class="invalid" id="i97">
            <description><html:p> Returns the codimension of the polyhedral complex in its ambient vector space. More precisely, this
 value is equal to <html:a href="#i107">CMPLX_AMBIENT_DIM</html:a> - <html:a href="#i98">CMPLX_DIM</html:a></html:p></description>
          </property>
          <property name="VERTICES" type="common::Set&lt;Int&gt;" href="#" class="invalid" id="i101">
            <description><html:p> Computes the subset of row indices of RAYS, such that the corresponding rows describe a vertex of the complex.
 This set is empty if <html:a href="#i104">USES_HOMOGENEOUS_C</html:a> is false and is the complement of <html:a href="#i102">DIRECTIONAL_RAYS</html:a></html:p></description>
          </property>
          <property name="DIRECTIONAL_RAYS" type="common::Set&lt;Int&gt;" href="#" class="invalid" id="i102">
            <description><html:p> Computes the subset of row indices of RAYS, such that the corresponding rows describe a directional ray of the complex.
 This set contains all row indices  if <html:a href="#i104">USES_HOMOGENEOUS_C</html:a> is false and is the complement of <html:a href="#i101">VERTICES</html:a></html:p></description>
          </property>
        </category>
        <category name="Tropical geometry" id="i84">
          <property name="LATTICE_NORMAL_FCT_VECTOR" type="common::Map&lt;Int, Map&lt;Int, Vector&lt;Rational&gt;&gt;&gt;" href="#" class="invalid" id="i108">
            <description><html:p> For each lattice normal vector, this gives a vector of length (number of rays) + (lineality dim.), such that
 if a rational function is given by values on the rays and lin space generators, the value of the corresponding
 normal <html:a href="#i114">LATTICE_NORMALS</html:a>-&gt;{i}-&gt;{j} can be computed by multiplying the function value vector with 
 the vector <html:a href="#i108">LATTICE_NORMAL_FCT_VECTOR</html:a>-&gt;{i}-&gt;{j}. This is done in the following way:  If this fan does not 
 use homogeneous coordinates, it computes a representation of the lattice normal in the generating system 
 consisting of the rays of <html:a href="#">MAXIMAL_CONES</html:a>-&gt;row(j) and the generators 
 of the lineality space. It then inserts the coefficients of the representation at the right position. 
 If the fan uses homog. coordinates, however, we use a different generating system (and indices refer to CMPLX_RAYS)
 &lt;(r_i-r_0)_i&gt;0, s_j, l_k&gt;, where r_0 is the ray of the maximal cone 
 with the lowest index in <html:a href="#i99">CMPLX_RAYS</html:a>, such that it fulfills x0 = 1, r_i are the remaining rays with x0 = 1, ordered
 according to their index in <html:a href="#i99">CMPLX_RAYS</html:a>, s_j are the rays of the cone with x0 = 0 and l_k are the lineality space 
 generators. We will then store the coefficients a_i of (r_i - r_0) at the index of r_i, then - sum(a_i) at 
 the index of r_0 and the remaining coefficients at the appropriate places.</html:p></description>
          </property>
          <property name="LATTICE_NORMAL_SUM" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i110">
            <description><html:p> Rows of this matrix correspond to <html:a href="#i111">CODIM_1_FACES</html:a>, and each row contains the weighted sum:
 sum_{cone &gt; codim-1-face}( weight(cone) * <html:a href="#i114">LATTICE_NORMALS</html:a>-&gt;{codim-1-face}-&gt;{cone})</html:p></description>
          </property>
          <property name="LATTICE_NORMAL_SUM_FCT_VECTOR" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i109">
            <description><html:p> Rows of this matrix correspond to <html:a href="#i111">CODIM_1_FACES</html:a> (or <html:a href="#i105">CMPLX_CODIM_1_FACES</html:a> in the homog. case), and each row 
 contains a function vector for the corresponding row of <html:a href="#i110">LATTICE_NORMAL_SUM</html:a>. This function vector is computed 
 in the same way as described under <html:a href="#i108">LATTICE_NORMAL_FCT_VECTOR</html:a>.</html:p></description>
          </property>
        </category>
        <category name="Basic properties" id="i85">
          <property name="CODIM_1_FACES" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i111">
            <description><html:p> An incidence matrix of all codimension one faces. Each row is a face and column indices refer to <html:a href="#">RAYS</html:a>.
 If the fan uses homogeneous coordinates, only those faces that intersect {x0 = 1} are listed here.</html:p></description>
          </property>
          <property name="CODIM_1_IN_MAXIMAL_CONES" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i113">
            <description><html:p> An incidence matrix indicating which codim 1 faces are contained in which maximal cone. Rows refer
 to (rows of) <html:a href="#i111">CODIM_1_FACES</html:a>, columns to (rows of) <html:a href="#">MAXIMAL_CONES</html:a></html:p></description>
          </property>
          <property name="DESCRIPTION" type="common::String" href="#" class="invalid" id="i112">
            <description><html:p> An arbitrary textual description of the complex, to be specified by the user. Some
 operations that produce a WeightedComplex automatically set this property to something
 informative.</html:p></description>
          </property>
        </category>
        <category name="Tropical properties" id="i86">
          <property name="TROPICAL_WEIGHTS" type="common::Vector&lt;Integer&gt;" href="#" class="invalid" id="i115">
            <description><html:p> Vector of (integer) weights for maximal cones. Indices refer to (the rows of) <html:a href="#">MAXIMAL_CONES</html:a>
 If, however, the fan only consists of a lineality space, specifying the weight of this single maximal
 cone is only necessary, if you want to compute refinements of this fan later on (e.g. for computing
 divisors of rational functions)</html:p></description>
          </property>
          <property name="IS_BALANCED" type="common::Bool" href="#" class="invalid" id="i116">
            <description><html:p> Indicates whether the fan is balanced with the given <html:a href="#i115">TROPICAL_WEIGHTS</html:a>.</html:p></description>
          </property>
          <property name="LATTICE_NORMALS" type="common::Map&lt;Int, Map&lt;Int, Vector&lt;Integer&gt;&gt;&gt;" href="#" class="invalid" id="i114">
            <description><html:p> A list of lattice normal vectors. They are associated to the faces and maximal cones in the following 
 way: For face i and adjacent maximal cone j, the element <html:a href="#i114">LATTICE_NORMALS</html:a>-&gt;{i}-&gt;{j} is the corresp.
 lattice normal vector. There is a convenience method lattice_normal(i,j)
 If <html:a href="#i104">USES_HOMOGENEOUS_C</html:a> is TRUE, this actually computes a lattice normal of the cone (face i)\cap {x0 =1} wrt the
 cone (maximal cone j) \cap {x0=1} to ensure that the normal is of the form (0,...)</html:p></description>
          </property>
        </category>
      </properties>
      <user-methods>
        <category name="Visualization" id="i78">
          <function name="CMPLX_VISUAL" id="i93">
            <common-option-list name="Visual::WeightedComplex::decorations" href="#i17" class="invalid"/>
            <description><html:p> Displays a weighted polyhedral complex in ambient dimension up to 3 (4 in homog. coordinates) by visualizing all its
 cells in the following way: For each cell, every directional ray is added to every affine ray (which is only the origin
 in the non-homog. case) and the resulting polytope is displayed. The visualization has the following options:
 * DirScale: A rational number with which the directional rays are multiplied before added to the affine rays
 * WeightLabels:  if set to "hidden", the labels indicating the weights are hidden 
 * CoordLabels: If set to "show", the labels indicating the vertex coordinates are displayed, otherwise they are not. Note that this is expensive and significantly increases computation time.</html:p></description>
          </function>
          <function name="boundingBox" id="i94">
            <param name="distance" type="Rational" href="#">
              <description><html:div>The distance of the bounding box from the affine part of the variety (Can also be a standard perl number type)</html:div></description>
            </param>
            <return type="Matrix&lt;Rational&gt;" href="#">
              <description><html:div>A 2x<html:a href="#i107">CMPLX_AMBIENT_DIM</html:a>-matrix specifying the bounding box (it can be used as input for BoundingBox in <html:a href="#i81">BB_VISUAL</html:a></html:div></description>
            </return>
            <description><html:p> Takes a tropical variety and a (positive) Rational as input and computes the relative bounding box of the visualization with the Rational as BoundingDistance (see also the description of <html:a href="#i81">BB_VISUAL</html:a></html:p></description>
          </function>
        </category>
        <category name="Polyhedral geometry" id="i79">
          <function name="homogenize" id="i95">
            <return type="If" href="#" class="invalid">
              <description><html:div>this fan uses homog. coordinates, returns the fan itself, Otherwise it will replace the ray matrix
 by the following matrix: One affine ray [1,0,...0] and then [0,ray] for any ray of the original fan. In <html:a href="#">MAXIMAL_CONES</html:a>
 all get the additional affine ray and <html:a href="#" class="invalid">TROPICAL WEIGHTS</html:a> is simply copied</html:div></description>
            </return>
            <description><html:p> Transforms the fan into homogeneous coordinates</html:p></description>
          </function>
        </category>
        <category name="Tropical methods" id="i80">
          <function name="lattice_normal" id="i96">
            <param name="i" type="Int" href="#">
              <description><html:div>The index of the facet</html:div></description>
            </param>
            <param name="j" type="Int" href="#">
              <description><html:div>The index of the maximal cone</html:div></description>
            </param>
            <return type="The" href="#" class="invalid">
              <description><html:div>lattice normal vector of cone j wrt. facet i</html:div></description>
            </return>
            <description><html:p> Convenience method, returns LATTICE_NORMALS-&gt;[i]-&gt;[j]</html:p></description>
          </function>
        </category>
        <function name="characteristic" id="i82">
          <description><html:blockquote><html:div>user_method adjHomology {</html:div><html:div>  my $this = shift;</html:div><html:div>  #Create set graph</html:div><html:div>  my $facets = new Vector&lt;Set&lt;Int&gt; &gt;();</html:div><html:div>  my $maximalInCodim = $this-&gt;CODIM_1_IN_MAXIMAL_CONES;</html:div><html:div>  my $codimInMaximal = transpose($this-&gt;CODIM_1_IN_MAXIMAL_CONES);</html:div><html:div>  for my $mc (0 .. $this-&gt;MAXIMAL_CONES-&gt;rows() -1) {</html:div><html:div>      print "Finding adjacencies of cone $mc...\n";</html:div><html:div>      my $cdset = $codimInMaximal-&gt;row($mc);</html:div><html:div>      for my $cd (@{$cdset}) {</html:div><html:div>	my $mcset = ($maximalInCodim-&gt;row($cd) - $mc);</html:div><html:div>	for my $othermc (@{$mcset}) {</html:div><html:div>	  if($othermc &gt; $mc) {</html:div><html:div>	    my $s = new Set&lt;Int&gt;($mc,$othermc);</html:div><html:div>	    $facets = $facets | $s;</html:div><html:div>	  }</html:div><html:div>	}</html:div><html:div>      }</html:div><html:div>  }</html:div><html:div>  my $cplx = new topaz::SimplicialComplex(FACETS=&gt;$facets);</html:div><html:div>  $cplx-&gt;VISUAL;</html:div><html:div>  return $cplx-&gt;HOMOLOGY;</html:div><html:div>}</html:div></html:blockquote></description>
        </function>
        <function name="BB_VISUAL" id="i81">
          <common-option-list name="Visual::WeightedComplex::BoundingDecorations" href="#i16" class="invalid"/>
          <description><html:p> ---------------------------------------------------------------------------------------------------------</html:p></description>
        </function>
      </user-methods>
    </object>
    <object name="RationalFunction" id="i21">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <properties>
        <category name="Tropical geometry" id="i92">
          <property name="DOMAIN" type="WeightedComplex" href="#i18" id="i138">
            <description><html:p> This property describes the linearity domains of the function. I.e. the function is
 affine integral linear on each maximal cone of <html:a href="#i138">DOMAIN</html:a>. It is of type WeightedComplex, but
 actually only the basic geometric properties <html:a href="#">RAYS</html:a>/<html:a href="#i99">CMPLX_RAYS</html:a>,<html:a href="#">MAXIMAL_CONES</html:a>/<html:a href="#i106">CMPLX_MAXIMAL_CONES</html:a>,<html:a href="#">LINEALITY_SPACE</html:a> and <html:a href="#i104">USES_HOMOGENEOUS_C</html:a> are of any interest. Further properties are ignored and can be omitted upon generation.</html:p></description>
          </property>
          <property name="RAY_VALUES" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i137">
            <description><html:p> The value at index i describes the function value of ray <html:a href="#i138">DOMAIN</html:a>-&gt;CMPLX_RAYS-&gt;row(i). More precisely, if the
 corresponding ray is a vertex, it describes its function value. If it is a directional ray, it describes 
 the slope on that ray.</html:p></description>
          </property>
          <property name="LIN_VALUES" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i139">
            <description><html:p> The value at index i describes the function value of <html:a href="#i138">DOMAIN</html:a>-&gt;LINEALITY_SPACE-&gt;row(i)</html:p></description>
          </property>
        </category>
      </properties>
    </object>
    <object name="RationalCurve" id="i20">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <properties>
        <category name="Basic properties" id="i91">
          <property name="SETS" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i136">
            <description><html:p> A list of partitions of [n] that define the tree of the curve: For each bounded edge we have 
 the corresponding partition of the n leaves. These should be irredundant. If you want to input
 a possibly redundant list, use <html:a href="#i135">INPUT_SETS</html:a> and <html:a href="#i130">INPUT_COEFFS</html:a> instead. The number of marked leaves
 should always be given by <html:a href="#i131">N_LEAVES</html:a>. The sets are subsets of {1,...,n} (NOT {0,..,n-1}!)</html:p></description>
          </property>
          <property name="COEFFS" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i132">
            <description><html:p> A list of positive rational coefficients. The list should have the same length as <html:a href="#i136">SETS</html:a> and
 contain only entries &gt; 0. The i-th entry then gives the length of the bounded edge defined by
 the i-th partition. If you're not sure if all your coefficients are &gt; 0, use <html:a href="#i135">INPUT_SETS</html:a> and
 <html:a href="#i130">INPUT_COEFFS</html:a> instead.</html:p></description>
          </property>
          <property name="INPUT_SETS" type="common::IncidenceMatrix&lt;NonSymmetric&gt;" href="#" class="invalid" id="i135">
            <description><html:p> Same as <html:a href="#i136">SETS</html:a>, except that sets may appear several times.</html:p></description>
          </property>
          <property name="INPUT_COEFFS" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i130">
            <description><html:p> Same as <html:a href="#i132">COEFFS</html:a>, except that entries may be &lt;=0. This should have the same length as <html:a href="#i135">INPUT_SETS</html:a>.</html:p></description>
          </property>
          <property name="N_LEAVES" type="common::Int" href="#" class="invalid" id="i131">
            <description><html:p> The number of leaves of the rational curve.</html:p></description>
          </property>
          <property name="INPUT_STRING" type="common::String" href="#" class="invalid" id="i129">
            <description><html:p> This property can also be used to define a rational curve: A linear combination of partitions is
 given as a string, using the following syntax:
 A partition is given as a subset of {1,..,n} and written as a comma-separated list of leaf
 indices in round brackets, e.g. "(1,2,5)"
 A linear combination can be created using rational numbers, "+","+" and "-" in the obvious way, 
 e.g. "2*(1,2,5) + 1*(3,4,7) - 2(1,2) (The "*" is optional)
 Of course, each set should contain at least two elements. If you don't specify N_LEAVES, it is
 set to be the largest leaf index occuring in the sets.
 Partitions needn't be irredundant and coefficients can be any rational number. If the resulting 
 element is not in the moduli space, an error is thrown.</html:p></description>
          </property>
          <property name="GRAPH" type="graph::Graph&lt;Undirected&gt;" href="#" class="invalid" id="i134">
            <description><html:p> Contains the abstract graph (non-metric) corresponding to the curve. All unbounded leaves are modelled
 as bounded edges.</html:p></description>
          </property>
          <property name="GRAPH_EDGE_LENGTHS" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i133">
            <description><html:p> Contains the lengths of the edges of <html:a href="#i134">GRAPH</html:a> that represent bounded edges of the curve.
 The coefficients appear in the order that the corr. edges appear in <html:a href="#">EDGES</html:a>.</html:p></description>
          </property>
        </category>
      </properties>
      <user-methods>
        <category name="Tropical geometry" id="i90">
          <function name="metric_vector" id="i128">
            <description><html:p> Returns the (n over 2) metric vector of the rational n-marked curve</html:p></description>
          </function>
          <function name="matroid_vector" id="i127">
            <return type="Vector&lt;Rational&gt;" href="#"/>
            <description><html:p> Computes the coordinates of the curve in the moduli space given in matroid coordinates.</html:p></description>
          </function>
        </category>
        <function name="VISUAL" id="i89">
          <common-option-list name="Visual::RationalCurve::decorations" href="#i15" class="invalid"/>
          <description><html:p>UNDOCUMENTED</html:p></description>
        </function>
      </user-methods>
    </object>
    <object name="MinMaxFunction" id="i19">
      <description><html:p>UNDOCUMENTED</html:p></description>
      <derived-from object="RationalFunction" href="#i21"/>
      <properties>
        <category name="Basic properties" id="i88">
          <property name="INPUT_STRING" type="common::String" href="#" class="invalid" id="i121">
            <description><html:p> The syntax for STRING in pseudo-regex is the following (after deleting any whitespace): 
 "(min|max)\((SUM)+(,SUM)*\)"
 where SUM = "(TERM)+([\+\-](TERM))*"
 where TERM = (RAT)|(RAT[:alpha:][^\+,\)]*)
 where RAT is any string that can be parsed to a polymake Rational and does not contain any letters.
 To make this more comprehensible: STRING takes anything of the form min(...) or max(...), 
 where ... is a comma-separated list of strings of the form a + bx + cy + ... , where a,b,c are rational 
 numbers and x,y are variables. Any string that starts with a letter and does not contain "+" or "," can be 
 a variable. Such a sum can contain several such terms for the same variable and they need not be in any order.
 A term can be of the form "3x", "3*x", but "x3" will be interpreted as 1 * "x3". Coefficients should not contain letters,
 i.e. 3E10*x would be interpreted as 3 * "E10*x". Empty terms are allowed.
 If no INPUT_VARS are given, MinMaxFunction will recognize the dimension of the domain from the number of variables and will
 assign the variables to the standard basis vectors by sorting them alphabetically. 
 E.g. INPUT_STRING=&gt;"min(x+2z,3+z)",INPUT_VARS=&gt;["x","y","z"] is a different function than INPUT_STRING=&gt;"min(x+2z,3+z)",
 since the second is the function f:R² -&gt; R, (a,b) -&gt; min(a+2b,3+b) and the first is f: R³-&gt;R, (a,b,c)-&gt;min(a+2c,3+c)
 If however, <html:a href="#i122">INPUT_VARS</html:a> is given, the parse will *ignore* any terms containing variables that are not 
 defined in <html:a href="#i122">INPUT_VARS</html:a>. The variables will be assigned to the standard basis vectors in order of their
 appearance in <html:a href="#i122">INPUT_VARS</html:a>.
 E.g. INPUT_STRING=&gt;"min(x+2c,3+x)",INPUT_VARS=&gt;["x","y"] will give the function f:R²-&gt;R, (a,b) -&gt; min(a,3+a)
 Note that ANY whitespace in <html:a href="#i121">INPUT_STRING</html:a> is ignore, as well as any brackets '(',')' besides the ones enclosing
 the function list.</html:p></description>
          </property>
          <property name="INPUT_VARS" type="common::Array&lt;String&gt;" href="#" class="invalid" id="i122">
            <description><html:p> A list of strings that are variables. Any string that starts with a letter (i.e. [a-zA-Z]) and does not contain
 '+' or ',' can be a variable. Illegal variable names will not cause an error, but the parser will not detect them
 in <html:a href="#i121">INPUT_STRING</html:a>, so their coefficients will be 0. If you assign a value to this, only terms with variables in 
 this array will be parsed. Note that ANY whitespace in a variable name will be ignored. The i-th element of this array
 will be assigned to the i-th standard basis vector.</html:p></description>
          </property>
          <property name="STANDARD_FORM" type="common::String" href="#" class="invalid" id="i126">
            <description><html:p> This will give a nice string representation of the function, where all variables are of the form 'x_i',
 i = 1,..,<html:a href="#i138">DOMAIN</html:a>. There are no redundancies and terms are sorted in ascending alphabetic order of their variable,
 with the constant term at the end</html:p></description>
          </property>
          <property name="USES_MIN" type="common::Bool" href="#" class="invalid" id="i120">
            <description><html:p> Indicates whether this function uses min (TRUE) or max (FALSE). The default (if you directly give a coefficient matrix,
 but not this value) is FALSE</html:p></description>
          </property>
          <property name="DOMAIN_DIMENSION" type="common::Int" href="#" class="invalid" id="i119">
            <description><html:p> The dimension n of the domain R^n of the function. Is equal to the columns of <html:a href="#i124">LINEAR_COEFFICIENTS</html:a></html:p></description>
          </property>
          <property name="LINEAR_COEFFICIENTS" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i124">
            <description><html:p> A matrix of the linear coefficients of the functions. Each row corresponds to a linear function within
 the min or max and the entry in column j is the coefficient of variable x_j</html:p></description>
          </property>
          <property name="CONSTANT_COEFFICIENTS" type="common::Vector&lt;Rational&gt;" href="#" class="invalid" id="i125">
            <description><html:p> A vector of the constant coefficients of the function. The i-th entry is the constant term of the function 
 represented by the i-th row of <html:a href="#i124">LINEAR_COEFFICIENTS</html:a>.</html:p></description>
          </property>
          <property name="FUNCTION_MATRIX" type="common::Matrix&lt;Rational, NonSymmetric&gt;" href="#" class="invalid" id="i123">
            <description><html:p> This is simply the concatenation of <html:a href="#i124">LINEAR_COEFFICIENTS</html:a> and <html:a href="#i125">CONSTANT_COEFFICIENTS</html:a></html:p></description>
          </property>
        </category>
      </properties>
      <user-methods>
        <category name="Tropical geometry" id="i87">
          <function name="linearityDomains" id="i118">
            <description><html:p> This computes the (homogenized version of the) domains of linearity of the function. More precisely, it computes the 
 normal fan of the polytope defined by this function in the following way:
 If the positive form reads max(a_i*x + c_i,i=1,..,k) with a_i in Q^n and c_i in Q, then the polytope is
 conv( (c_i,a_i) ) in Q^{n+1} (in homog. coordinates its actually in n+2 coordinates).
 If you want to refine a tropical variety along these domains, you have to do the following: If the variety is already
 in homogeneous coordinates, simply call intersect_complete_fan(variety, linearityDomains). Otherwise you have to 
 homogenize the variety (call method homogenize on the variety) and intersect then.
 If the function uses min, the coefficients are multiplied by -1 before computing the polytope. Note that, since
 min(f_i) = - max (-f_i), this doesn't change the domain of linearity.
 Note that this function returns the same as <html:a href="#i138">DOMAIN</html:a></html:p></description>
          </function>
          <function name="valueAt" id="i117">
            <return type="Rational" href="#">
              <description><html:div>The function value at the given point.</html:div></description>
            </return>
            <description><html:p> Computes the value of this function at a given point. If the point has dimension DOMAIN_DIMENSION, it simply computes the value. 
 If it has dimension DOMAIN_DIMENSION +1, it assumes the point is given in homogeneous coordinates (i.e. the first coordinate should be one or zero, 
 this is not checked, however) and computes the function value of the last DOMAIN_DIMENSION coordinates.</html:p></description>
          </function>
        </category>
      </user-methods>
    </object>
  </objects>
  <user-functions>
    <category name="Polyhedral geometry" id="i5">
      <function name="skeleton_complex" id="i24">
        <param name="fan" type="WeightedComplex" href="#i18">
          <description><html:div>A fan (or polyhedral complex)</html:div></description>
        </param>
        <param name="k" type="Int" href="#">
          <description><html:div>The dimension of the skeleton that should be computed</html:div></description>
        </param>
        <param name="preserveRays" type="Bool" href="#">
          <description><html:div>When true, the function assumes that all rays of the fan remain in the k-skeleton, so it just copies the RAYS, instead of passing them to INPUT_RAYS. This property can always be set to true, if fan is not in homogeneous coordinates or if the corresponding complex at x0 = 1 only has vertices. By default, this property is false.</html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>k-skeleton of the fan (or complex, if USES_HOMOGENEOUS_C is true)</html:div></description>
        </return>
        <description><html:p> Takes a polyhedral complex and computes the k-skeleton. Will return an empty fan, if k is larger then the dimension
 of the given complex or smaller than 1.</html:p></description>
      </function>
      <function name="product_complex" id="i23">
        <param name="A" type="complexes" href="#" class="invalid">
          <description><html:div>list of WeightedComplex objects</html:div></description>
        </param>
        <return type="the" href="#" class="invalid">
          <description><html:div>cartesian product of the complexes. If any of the complexes use homogeneous coordinates, so does the result. If any of the complexex carries weights, the result carries the sum of the weights of its factors (Complexes without weights are treated as complexes with weight 1).</html:div></description>
        </return>
        <description><html:p> Computes the cartesian product of a set of polyhedral fans. If any of them uses homogeneous coordinates, so will the result</html:p></description>
      </function>
      <function name="complexify" id="i22">
        <param name="rays" type="Matrix&lt;Rational&gt;" href="#">
          <description><html:div>A matrix of rays of the cones. Has to be irredundant and 
 normalized.</html:div></description>
        </param>
        <param name="cones" type="Vector&lt;Set&lt;int&gt; &gt;" href="#">
          <description><html:div>The maximal cones, given in terms of row indices of their 
 rays </html:div></description>
        </param>
        <param name="weights" type="Vector&lt;Integer&gt;" href="#">
          <description><html:div>The i-th element is the weight of the cone described by the 
 i-th row of cones</html:div></description>
        </param>
        <param name="uses_homog" type="bool" href="#" class="invalid">
          <description><html:div>Whether the rays are given in homogeneous coordinates </html:div></description>
        </param>
        <return type="perl::Object" href="#" class="invalid">
          <description><html:div>A WeightedComplex object, whose support is the union of the cones. 
 The weight of a cone is the sum of the weights of the orginal cones containing it. The 
 result is homogeneous iff uses_homog is true</html:div></description>
        </return>
        <description><html:p> Takes a collection of weighted cones of the same dimension and refines them such that they 
 form a weighted complex. Weights of cones lying one over the other add up.</html:p></description>
      </function>
    </category>
    <category name="Random number generators" id="i6">
      <function name="randomInteger" id="i25">
        <param name="max_arg" type="int" href="#" class="invalid">
          <description><html:div>The upper bound for the random integers</html:div></description>
        </param>
        <param name="n" type="int" href="#" class="invalid">
          <description><html:div>The number of integers to be created</html:div></description>
        </param>
        <return type="Array&lt;Integer&gt;" href="#"/>
        <description><html:p> Returns n random integers in the range 0.. (max_arg-1),inclusive
 Note that this algorithm is not optimal for real randomness:
 If you change the range parameter and then change it back, you will
 usually get the exact same sequence</html:p></description>
      </function>
    </category>
    <category name="Homology" id="i7">
      <function name="adjacencyComplex" id="i27">
        <param name="fan" type="WeightedComplex" href="#i18">
          <description><html:div>A tropical variety</html:div></description>
        </param>
        <return type="topaz::SimplicialComplex" href="#">
          <description><html:div>The adjacency graph as a simplicial complex</html:div></description>
        </return>
        <description><html:p> Computes the codimension one adjacency graph of a tropical variety and returns it as a 
 simplicial complex. The nodes of the graph are the maximal cones, which are connected, iff 
 they share a codimension one face</html:p></description>
      </function>
      <function name="equivalenceComplex" id="i26">
        <param name="fan" type="WeightedComplex" href="#i18">
          <description><html:div>A tropical variety</html:div></description>
        </param>
        <return type="topaz::SimplicialComplex" href="#">
          <description><html:div>The canonical complex of the variety.</html:div></description>
        </return>
        <description><html:p> Computes the canonical complex of a tropical variety. The one-skeleton is determined 
 in the following way: Two cones a,b are equivalent, if there exists a sequence of 
 maximal cones a=c0,...,cr=b, such that ci,ci+1 intersect in a codimension one face of 
 which they are the only neighbours
 The vertices are the equivalence classes and two of them are connected if any cones in 
 them are connected.</html:p></description>
      </function>
    </category>
    <category name="Graph theory" id="i8">
      <function name="spanning_complete" id="i28">
        <param name="n" type="int" href="#" class="invalid">
          <description><html:div>The number of nodes</html:div></description>
        </param>
        <return type="perl::ListReturn" href="#" class="invalid">
          <description><html:div>An array of Set&lt;Int&gt; The spanning trees, each encoded as
 the set of edges, where the edge indices are determined as follows: For i,j =
 0,..,n-1 and i &lt; j we sort the edges (i,j) in ascending lexicographical ordering
 , i.e, (0,1) &lt; (0,2) &lt; .. &lt; (n-2,n-1).</html:div></description>
        </return>
        <description><html:p> Computes the set of all spanning trees of the complete graph on n nodes</html:p></description>
      </function>
    </category>
    <category name="Tropical geometry" id="i9">
      <function name="diagonal_functions" id="i56">
        <param name="n" type="Int" href="#">
          <description><html:div>Them dimension of the vector space (and the number of functions)</html:div></description>
        </param>
        <return type="MinMaxFunction" href="#i19">
          <description><html:div>A list of the functions (max(x_n,y_n),...,max(x_1,y_1)), where x_i is the coordinate function in the first part of the cartesian product R^n x R^n and y_i is the coordinate function of the second half.</html:div></description>
        </return>
        <description><html:p> Produces the rational functions that cut out the diagonal of the vector space R^n.</html:p></description>
      </function>
      <function name="linear_space_by_matrix" id="i40">
        <param name="rowspace" type="Matrix&lt;Rational&gt;" href="#">
          <description><html:div>A matrix whose rows span the lineality space of the fan (hence the whole fan).
 If you already know that your rows are a basis, call linear_space_by_basis instead.</html:div></description>
        </param>
        <param name="weight" type="int" href="#" class="invalid">
          <description><html:div>The weight of the linear space (1, if none is given)</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The resulting fan object in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Creates a tropical variety consisting of a single linear space defined by a matrix and assigns it a given weight.</html:p></description>
      </function>
      <function name="linear_space_by_basis" id="i61">
        <param name="rowspace" type="Matrix&lt;Rational&gt;" href="#">
          <description><html:div>A matrix whose rows span the lineality space of the fan (hence the whole fan) and
 which are assumed to be linearly independent. If you are not sure of this, call linear_space_by_matrix instead.</html:div></description>
        </param>
        <param name="weight" type="int" href="#" class="invalid">
          <description><html:div>The weight of the linear space (1, if none is given)</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The resulting fan object in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Creates a tropical variety consisting of a single linear space defined by a matrix and assigns it a given weight.</html:p></description>
      </function>
      <function name="linear_nspace" id="i52">
        <param name="n" type="int" href="#" class="invalid">
          <description><html:div>The dimension of the linear space</html:div></description>
        </param>
        <param name="weight" type="int" href="#" class="invalid">
          <description><html:div>The weight of the linear space (1, if none is given)</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The resulting fan object in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Creates the tropical variety R^n as a single lineality space with a given weight </html:p></description>
      </function>
      <function name="bergman_fan" id="i44">
        <param name="m" type="matroid::Matroid" href="#">
          <description><html:div>A matroid</html:div></description>
        </param>
        <param name="modOutLineality" type="Bool" href="#">
          <description><html:div>Optional argument. If set to TRUE, the lineality space is divided out before returning the 
 fan. The next parameter specifies the exact modalities of the division. By default, this parameter is set to FALSE</html:div></description>
        </param>
        <param name="projectionCoordinate" type="int" href="#" class="invalid">
          <description><html:div>Optional argument. An integer in {0,..,n-1}, where n is the number of elements of the matroid. If modOutLineality is set to TRUE, the standard basis vector with index projectionCoordinate is mapped to minus the sum of the remaining standard basis vectors to mod out the lineality space. By default, this is the last coordinate n-1.</html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>bergman fan of the given matroid in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Creates the bergman fan of a given matroid fan.</html:p></description>
      </function>
      <function name="random_minmaxdivisor" id="i46">
        <param name="ambient_dim" type="int" href="#" class="invalid">
          <description><html:div>The ambient dimension of the divisor</html:div></description>
        </param>
        <param name="equations" type="int" href="#" class="invalid">
          <description><html:div>The number of equations to use</html:div></description>
        </param>
        <param name="upperCoeffBound" type="int" href="#" class="invalid">
          <description><html:div>The upper bound  of the coefficients (All coefficients are positive)</html:div></description>
        </param>
        <param name="onlyFunction" type="Bool" href="#">
          <description><html:div>If true, only the random function is returned and the divisor is not computed. FALSE by default.</html:div></description>
        </param>
        <return type="MinMaxFunction" href="#i19">
          <description><html:div>if onlyFunction is TRUE, otherwise an array containing first the function, then the divisor</html:div></description>
        </return>
        <description><html:p> Creates a divisor of a random MinMaxFunction (in n-space) with integer coefficients.
 By default this uses maximum for the function. It returns an array containing the function created and its
 divisor in n-space.</html:p></description>
      </function>
      <function name="zero_cycle" id="i54">
        <description><html:p> Returns the zero cycle, i.e. a weighted complex with no rays and cones</html:p></description>
      </function>
      <function name="is_zerocycle" id="i49">
        <param name="c" type="WeightedComplex" href="#i18"/>
        <return type="Bool" href="#"/>
        <description><html:p> Checks whether a cycle is the 0 cycle</html:p></description>
      </function>
      <function name="divisorByValue" id="i35">
        <param name="A" type="WeightedComplex" href="#i18">
          <description><html:div>tropical variety on which the divisor is computed. </html:div></description>
        </param>
        <param name="An" type="values" href="#" class="invalid">
          <description><html:div>array of rational values that define an integer affine map on the fan. </html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>divisor of the function defined by values on the given fan, as a tropical variety.</html:div></description>
        </return>
        <description><html:p> Takes as input a tropical fan / tropical variety and an array of rational values. The array length should coincide 
 with the number of <html:a href="#i99">CMPLX_RAYS</html:a> of the fan plus the dimension of the lineality space and will be interpreted as a rational
 function, where each value has been assigned to the rays given by $fan-&gt;CMPLX_RAYS and to the generators given by $fan-&gt;LINEALITY_SPACE  
 (in that order). Missing values will be filled up by 0's, superfluous ones will be ignored. 
 The function will then compute the corresponding Weil divisor and return it as a 
 tropical variety given as a fan. The fan uses homogeneous coordinates, if and only the input fan does.</html:p></description>
      </function>
      <function name="sum_curves" id="i48">
        <param name="An" type="RationalCurve" href="#i20">
          <description><html:div>arbitrary list of RationalCurve objects</html:div></description>
        </param>
        <param name="v" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>A list of coefficients. Superfluous coefficients are ignored, missing ones replaced
 by +1(!)</html:div></description>
        </param>
        <return type="RationalCurve" href="#i20">
          <description><html:div>The linear combination of the curves defined by the coefficients or undef, if the result
 is not in M_0,n. The history of the operation is kept in INPUT_SETS and INPUT_COEFFS</html:div></description>
        </return>
        <description><html:p> This function takes a vector of coefficients a_i and a list of RationalCurves c_i and computes
 sum(a_i * c_i). In particular, it also checks, whether the result lies in M_0,n. If not, it returns unded</html:p></description>
      </function>
      <function name="bergman_fan_linear" id="i36">
        <param name="m" type="Matrix&lt;Rational&gt;" href="#">
          <description><html:div>Any rational matrix</html:div></description>
        </param>
        <param name="modOutLineality" type="Bool" href="#">
          <description><html:div>Optional argument. If set to TRUE, the lineality space is divided out before returning the 
 fan. The next parameter specifies the exact modalities of the division. By default, this parameter is set to FALSE</html:div></description>
        </param>
        <param name="projectionCoordinate" type="int" href="#" class="invalid">
          <description><html:div>Optional argument. An integer in {0,..,n-1}, where n is the number of elements of the matroid. If modOutLineality is set to TRUE, the standard basis vector with index projectionCoordinate is mapped to minus the sum of the remaining standard basis vectors to mod out the lineality space. By default, this is the last coordinate n-1.</html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>bergman fan of the given matroid in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Uses an algorithm by Felipe Rincón to compute the bergman fan of a linear matroid</html:p></description>
      </function>
      <function name="bergman_fan_matroid" id="i39">
        <param name="m" type="matroid::Matroid" href="#">
          <description><html:div>Any matroid</html:div></description>
        </param>
        <param name="modOutLineality" type="Bool" href="#">
          <description><html:div>Optional argument. If set to TRUE, the lineality space is divided out before returning the 
 fan. The next parameter specifies the exact modalities of the division. By default, this parameter is set to FALSE</html:div></description>
        </param>
        <param name="projectionCoordinate" type="int" href="#" class="invalid">
          <description><html:div>Optional argument. An integer in {0,..,n-1}, where n is the number of elements of the matroid. If modOutLineality is set to TRUE, the standard basis vector with index projectionCoordinate is mapped to minus the sum of the remaining standard basis vectors to mod out the lineality space. By default, this is the last coordinate n-1.</html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>bergman fan of the given matroid in non-homog. coordinates</html:div></description>
        </return>
        <description><html:p> Uses an algorithm by Felipe Rincón to compute the bergman fan of a general matroid</html:p></description>
      </function>
      <function name="tropical_lnk" id="i41">
        <param name="n" type="Int" href="#">
          <description><html:div>The ambient dimension of the fan.</html:div></description>
        </param>
        <param name="k" type="Int" href="#">
          <description><html:div>The dimension of the fan (should be smaller equal n, otherwise an error is thrown).</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>A PolyhedralFan object representing L^n_k</html:div></description>
        </return>
        <description><html:p> Creates the linear tropical space L^n_k. This tropical fan is defined in the following way: 
 As rays we take -e_i,i=1,...,n, where e_i is the i-th standard basis vector of R^n and 
 e_0 = e_1 + ... + e_n. As maximal cones we take the cones generated by rays {e_i, i in S}, where
 S runs over all k-element subsets of {0,..,n}.</html:p></description>
      </function>
      <function name="halfspace_complex" id="i31">
        <param name="constant" type="Rational" href="#">
          <description><html:div>The constant translation a</html:div></description>
        </param>
        <param name="equation" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>The defining equation g</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The resultin halfspace complex</html:div></description>
        </return>
        <description><html:p> Creates the halfspace complex defined by an rational vector g and a rational b, i.e. the 
 complex consisting of the two maximal cones g &gt;= a and g &lt;= a</html:p></description>
      </function>
      <function name="tropical_cube" id="i30">
        <param name="n" type="Int" href="#">
          <description><html:div>The ambient dimension</html:div></description>
        </param>
        <param name="k" type="Int" href="#">
          <description><html:div>The dimension of the cube</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>cube</html:div></description>
        </return>
        <description><html:p> Creates the tropical cube T^n_k, i.e. the tropical variety obtained by
 glueing together the 2^n L^n_k obtained by applying all possible sign 
 changes, such that the vertices form the k-skeleton of 
 the n-dimensional cube</html:p></description>
      </function>
      <function name="moduliDimensionFromLength" id="i47">
        <param name="k" type="Int" href="#">
          <description><html:div>The length = (n over 2)</html:div></description>
        </param>
        <return type="Int" href="#">
          <description><html:div>n. If k is not of the form (n over 2), the result is arbitrary</html:div></description>
        </return>
        <description><html:p> Takes a positive length (of a vector) and assumes it is of the form (n over 2)
 It then computes n</html:p></description>
      </function>
      <function name="curve_graph_from_metric" id="i57">
        <param name="v" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>A vector of length (n over 2). Its entries are 
 interpreted as the distances d(i,j) ordered lexicographically according to i,j. However, they need not be positive, as long as v is equivalent to a proper 
 metric modulo leaf lengths.</html:div></description>
        </param>
        <return type="An" href="#" class="invalid">
          <description><html:div>array containing first the graph::Graph and then a Vector&lt;Rational&gt;, containing 
 the lengths of the bounded edges (in the order they appear in EDGES)</html:div></description>
        </return>
        <description><html:p> Takes a vector from Q^(n over 2) that describes an n-marked rational abstract
 curve as a distance vector between its leaves. It then computes the 
 graph of the curve corresponding to this vector.</html:p></description>
      </function>
      <function name="rational_curve_from_moduli" id="i42">
        <param name="v" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>A vector in the moduli space</html:div></description>
        </param>
        <return type="RationalCurve" href="#i20"/>
        <description><html:p> Takes a vector from Q^((n over 2) - n) that lies in M_0,n (in its matroid coordinates 
 and computes the corresponding rational curve.</html:p></description>
      </function>
      <function name="rational_curve_list_from_moduli" id="i34">
        <param name="m" type="Matrix&lt;Rational&gt;" href="#"/>
        <return type="RationalCurve" href="#i20">
          <description><html:div>: An array of RationalCurves</html:div></description>
        </return>
        <description><html:p> Takes a matrix whose rows are elements in the moduli space M_0,n in matroid 
 coordinates. Returns a list, where the i-th element is the curve corr. to 
 the i-th row in the matrix</html:p></description>
      </function>
      <function name="rational_curve_list_from_metric" id="i37">
        <param name="m" type="Matrix&lt;Rational&gt;" href="#"/>
        <return type="RationalCurve" href="#i20">
          <description><html:div>: An array of RationalCurves</html:div></description>
        </return>
        <description><html:p> Takes a matrix whose rows are metrics of rational n-marked curves.
 Returns a list, where the i-th element is the curve corr. to 
 the i-th row in the matrix</html:p></description>
      </function>
      <function name="testFourPointCondition" id="i38">
        <param name="v" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>The vector to be checked</html:div></description>
        </param>
        <return type="Int" href="#">
          <description><html:div>A quadruple (array) of indices, where the four-point condition 
 is violated or an empty list, if the vector is indeed in M_0,n</html:div></description>
        </return>
        <description><html:p> Takes a metric vector in Q^{(n over 2)} and checks whether it fulfills 
 the four-point condition, i.e. whether it lies in M_0,n. More precisely 
 it only needs to be equivalent to such a vector</html:p></description>
      </function>
      <function name="latticeNormalByCone" id="i33">
        <param name="tau" type="polytope::Cone" href="#">
          <description><html:div>a codimension one face of tau, given as a cone</html:div></description>
        </param>
        <param name="sigma" type="polytope::Cone" href="#">
          <description><html:div>an arbitrary cone</html:div></description>
        </param>
        <return type="Vector" href="#"/>
        <description><html:p> Assuming that tau is a codimension one face of sigma, computes a representative of
 the primitive lattice normal vector of sigma with respect to tau</html:p></description>
      </function>
      <function name="latticeNormal" id="i58">
        <param name="taumatrix" type="Matrix" href="#">
          <description><html:div>a codimension one face of sigma, given as a matrix defining its linear span</html:div></description>
        </param>
        <param name="sigmamatrix" type="Matrix" href="#">
          <description><html:div>an arbitrary cone, given as a matrix defining its linear span</html:div></description>
        </param>
        <param name="additionalRay" type="Vector" href="#">
          <description><html:div>A ray that is contained in sigma, but not in tau. Used to calculate proper orientation of the normal vector.</html:div></description>
        </param>
        <return type="Vector" href="#"/>
        <description><html:p> Takes two matrices whose rows define the dual of the linear span of cone tau and sigma.
 Assuming that tau is a codimension one face of sigma, computes a representative of
 the primitive lattice normal vector of sigma with respect to tau</html:p></description>
      </function>
      <function name="latticeBasis" id="i55">
        <param name="cone" type="polytope::Cone" href="#">
          <description><html:div>A cone for which a Z-basis is to be computed</html:div></description>
        </param>
        <return type="Matrix&lt;Integer&gt;" href="#"/>
        <description><html:p> Takes a cone and computes a Z-basis of the vector space spanned by the cone,
 returned as row vectors of a matrix</html:p></description>
      </function>
      <function name="count_mn_cones" id="i29">
        <param name="n" type="Int" href="#">
          <description><html:div>The number of leaves. Should be &gt;= 3</html:div></description>
        </param>
        <return type="Integer" href="#">
          <description><html:div>The number of maximal cones</html:div></description>
        </return>
        <description><html:p> Computes the number of maximal cones of the tropical moduli space M_0,n</html:p></description>
      </function>
      <function name="count_mn_rays" id="i32">
        <param name="n" type="int" href="#" class="invalid">
          <description><html:div>The number of leaves. Should be &gt;= 3</html:div></description>
        </param>
        <return type="Integer" href="#">
          <description><html:div>The number of rays</html:div></description>
        </return>
        <description><html:p> Computes the number of rays of the tropical moduli space M_0,n</html:p></description>
      </function>
      <function name="tropical_m0n" id="i59">
        <param name="n" type="Int" href="#">
          <description><html:div>The number of leaves. Should be at least 4</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The tropical moduli space M_0,n</html:div></description>
        </return>
        <description><html:p> Creates the moduli space of abstract rational n-marked curves. Its coordinates are
 given as the coordinates of the bergman fan of the matroid of the complete graph on 
 n-1 nodes (but not computed as such)</html:p></description>
      </function>
      <function name="cycle_intersection" id="i50">
        <param name="X" type="WeightedComplex" href="#i18">
          <description><html:div>The first tropical variety</html:div></description>
        </param>
        <param name="Y" type="WeightedComplex" href="#i18">
          <description><html:div>The second tropical variety. Should have the same actual ambient 
 dimension (homogeneous coordinates don't count) as X.</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>Z The intersection product X*Y in V = R^n, where n is the ambient 
 dimension of X and Y. The result has homogeneous coordinates, if and only if X or Y has homog. 
 coordinates.</html:div></description>
        </return>
        <description><html:p> Computes the intersection product of two tropical cycles in a common ambient vector space V.</html:p></description>
      </function>
      <function name="recession_fan" id="i43">
        <param name="complex" type="WeightedComplex" href="#i18">
          <description><html:div>A tropical variety. If it is a fan, the complex itself is returned</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>A tropical fan, the recession fan of the complex</html:div></description>
        </return>
        <description><html:p> Computes the recession fan of a tropical variety</html:p></description>
      </function>
      <function name="degree" id="i45">
        <param name="complex" type="WeightedComplex" href="#i18"/>
        <return type="Int" href="#"/>
        <description><html:p> Computes the degree of a tropical variety as the degree of the 
 0-dimensional complex obtained when intersecting 
 the variety with an appropriate linear space L^n_k</html:p></description>
      </function>
      <function name="intersect_complete_fan" id="i53">
        <param name="fan" type="WeightedComplex" href="#i18">
          <description><html:div>An arbitrary weighted polyhedral fan</html:div></description>
        </param>
        <param name="completeFan" type="fan::PolyhedralFan" href="#">
          <description><html:div>A complete polyhedral fan</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The intersection of both fans (whose support is equal to the support of fan). The 
 resulting fan uses homogeneous coordinates if and only fan does. If fan has a property TROPICAL_WEIGHTS, 
 the tropical weights of the refinement are also computed. If fan is zero-dimensional (i.e. a point), fan is returned.</html:div></description>
        </return>
        <description><html:p> Takes two fans and computes the intersection of both. The function relies on the fact that the latter fan is complete 
 (i.e. its support is the whole ambient space) to compute the intersection correctly.</html:p></description>
      </function>
      <function name="divisorByPLF" id="i51">
        <param name="fan" type="WeightedComplex" href="#i18">
          <description><html:div>A tropical variety, on which the divisor is computed</html:div></description>
        </param>
        <param name="A" type="MinMaxFunction" href="#i19">
          <description><html:div>function whose DOMAIN should be equal to the affine coordinate 
 space of the variety, i.e. AMBIENT_DIM-1, if the variety uses homogeneous coordinates, 
 AMBIENT_DIM otherwise.</html:div></description>
        </param>
        <return type="The" href="#" class="invalid">
          <description><html:div>corresponding divisor as a tropical variety in homogeneous coordinates.</html:div></description>
        </return>
        <description><html:p> Computes the divisor of a MinMaxFunction on a given tropical variety. The result will be 
 in homogeneous coordinates, whether the tropical variety uses them or not. The function 
 should be given on the affine coordinates of the variety, NOT the homogeneous ones.</html:p></description>
      </function>
      <function name="fan_decomposition" id="i60">
        <param name="complex" type="WeightedComplex" href="#i18">
          <description><html:div>A tropical variety</html:div></description>
        </param>
        <return type="perl::ListReturn" href="#" class="invalid">
          <description><html:div>A list of WeightedComplex objects in 
 non-homogeneous coordinates. The i-th complex corresponds to the i-th 
 affine ray ( vertex). If the complex is not in homogeneous coordinates, 
 the list contains just the complex itself </html:div></description>
        </return>
        <description><html:p> Take a polyhedral complex and returns a list of all the local vertex fans, 
 i.e. for each affine ray r, the list contains the fan Star_complex(r) 
 (in non-homogeneous coordinates)</html:p></description>
      </function>
    </category>
    <category name="Testing" id="i10">
      <function name="atint_testrun" id="i62">
        <description><html:p> Tests the extension a-tint by calling (more or less) all functions and methods
 Needs no parameters and returns nothing.</html:p></description>
      </function>
    </category>
    <category name="Arithmetic" id="i11">
      <function name="gcdext" id="i63">
        <param name="a" type="Integer" href="#">
          <description><html:div>first argument of gcd(,)</html:div></description>
        </param>
        <param name="b" type="Integer" href="#">
          <description><html:div>second argument of gcd(,)</html:div></description>
        </param>
        <param name="s" type="Integer" href="#">
          <description><html:div>coefficient of a (will be set)</html:div></description>
        </param>
        <param name="t" type="Integer" href="#">
          <description><html:div>coefficient of b (will be set)</html:div></description>
        </param>
        <return type="Integer" href="#"/>
        <description><html:p> Computes the gcd of <html:em class="param">a</html:em> and <html:em class="param">b</html:em> and returns it. <html:em class="param">s</html:em> and <html:em class="param">t</html:em> are set
 such that gcd(<html:em class="param">a</html:em>,<html:em class="param">b</html:em>) = <html:em class="param">s</html:em> * <html:em class="param">a</html:em> + <html:em class="param">t</html:em> * <html:em class="param">b</html:em></html:p></description>
      </function>
    </category>
    <category name="Linear algebra" id="i12">
      <function name="affineTransform" id="i68">
        <param name="complex" type="WeightedComplex" href="#i18">
          <description><html:div>The complex to be transformed, supposed to be in homogeneous 
 coordinates (if translate != 0)</html:div></description>
        </param>
        <param name="translate" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>A vector whose dimension should be equal to the column dimension
 of the transformation matrix</html:div></description>
        </param>
        <param name="matrix" type="Matrix&lt;Integer&gt;" href="#">
          <description><html:div>An integer (square) invertible matrix. </html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>The transformed complex</html:div></description>
        </return>
        <description><html:p> Takes a polyhedral complex and applies an affine linear transformation, given by a translate 
 vector and a matrix. The method assumes the function is bijective and preserves cones, i.e. it 
 just applies the transformation to the rays and lineality space and leaves the cones and weights
 unchanged.</html:p></description>
      </function>
      <function name="linearRepresentation" id="i67">
        <param name="v" type="Vector" href="#">
          <description><html:div>The vector supposed to be contained in the row span of the generators</html:div></description>
        </param>
        <param name="generators" type="Matrix" href="#">
          <description><html:div>A set of row vectors whose linear span should contain v</html:div></description>
        </param>
        <return type="Vector" href="#">
          <description><html:div>A vector (a1,..,an) such that v = (a1,...,an) * generators. It returns a vector of
 dimension 0, if v is not in the span of the generators. An error is thrown if the dimensions of 
 v and the generators mismatch</html:div></description>
        </return>
        <description><html:p> Takes a vector v and a matrix with column dimension equal to the dimension of v. Assuming that 
 v is in the row span of the matrix, it computes one(!) possible representation of v in these 
 generators</html:p></description>
      </function>
      <function name="lllHNF" id="i64">
        <param name="matrix" type="Matrix" href="#">
          <description><html:div>the matrix for which the transformation is computed</html:div></description>
        </param>
        <param name="tfmatrix" type="Matrix" href="#">
          <description><html:div>The matrix that will contain the transformation matrix</html:div></description>
        </param>
        <param name="kdim" type="Integer" href="#">
          <description><html:div>This will be set to dim Ker(A)</html:div></description>
        </param>
        <return type="Matrix" href="#"/>
        <description><html:p> Computes a row HNF of an integer matrix A
 It returns the normal form and stores the unimodular transformation matrix and the kernel dimension  of the transposed matrix in
 the last two parameters. The algorithm is the LLL-based HNF alg. by Havas, Majevski, Matthews</html:p></description>
      </function>
      <function name="computeMatrixBases" id="i66">
        <param name="m" type="Matrix&lt;Rational&gt;" href="#"/>
        <return type="Set&lt;int&gt;" href="#">
          <description><html:div>An array of Set&lt;int&gt;</html:div></description>
        </return>
        <description><html:p> Computes a list of sets of column indices of a matrix such that
 the corresponding column sets form a basis of the column space</html:p></description>
      </function>
      <function name="computeMatrixColoops" id="i65">
        <param name="m" type="Matrix&lt;Rational&gt;" href="#"/>
        <return type="Set&lt;int&gt;" href="#"/>
        <description><html:p> Computes a list of column indices of a matrix such that 
 the corresponding columns are contained in every column basis of the
 column space. Is equal to the intersection of all sets returned by
 <html:a href="#i66">computeMatrixBases</html:a></html:p></description>
      </function>
    </category>
    <category name="Rational functions" id="i13">
      <function name="wfan" id="i69">
        <param name="fan" type="fan::PolyhedralFan" href="#">
          <description><html:div>The fan to be converted</html:div></description>
        </param>
        <param name="homog" type="Bool" href="#">
          <description><html:div>Whether the fan is to be interpreted in homogeneous coordinates</html:div></description>
        </param>
        <return type="WeightedComplex" href="#i18">
          <description><html:div>A complex with no weights but with the same geometry as fan.</html:div></description>
        </return>
        <description><html:p> This function takes a fan::PolyhedralFan and converts it into a WeightedComplex object.</html:p></description>
      </function>
    </category>
    <category name="Tropial geometry" id="i14">
      <function name="rational_curve_from_metric" id="i70">
        <param name="v" type="Vector&lt;Rational&gt;" href="#">
          <description><html:div>A vector of length (n over 2). Its entries are 
 interpreted as the distances d(i,j) ordered lexicographically according to i,j. However, they need not be positive, as long as v is equivalent to a proper 
 metric modulo leaf lengths.</html:div></description>
        </param>
        <return type="RationalCurve" href="#i20"/>
        <description><html:p> Takes a vector from Q^(n over 2) that describes an n-marked rational abstract
 curve as a distance vector between its leaves. It then computes the 
 curve corresponding to this vector.</html:p></description>
      </function>
    </category>
  </user-functions>
</application></pm:polymake_apps>
